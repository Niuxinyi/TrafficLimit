/**
 * Created by Chenx on 2017/7/10.
 * Class 1:25000图幅图层
 */
FM.mapApi.MeshAlgorithm = L.Class.extend({
    /*
     *  根据纬度计算该点位于理想图幅分割的行序号
     *
     *  @param{number}lat                 纬度      单位‘度’
     *  @param{number}remainder           余数      单位‘千秒’
     */
    CalculateIdealRowIndex: function (lat, remainder) {
        // 相对区域纬度 = 绝对纬度 - 0.0
        var regionLatitude = lat - 0.0;
        // 相对的以秒为单位的纬度
        var secondLatitude = regionLatitude * 3600;
        var longsecond;
        // 为避免浮点数的内存影响，将秒*10的三次方(由于0.00001度为0.036秒)
        if (secondLatitude * 1000 < 0) {
            longsecond = Math.ceil(secondLatitude * 1000);
        } else {
            longsecond = Math.floor(secondLatitude * 1000);
        }
        remainder = (longsecond % 300000);
        return {
            value: Math.floor(longsecond / 300000),
            reminder: remainder
        };
    },
    /*
     *  根据纬度计算该点位于实际图幅分割的行序号
     *
     *  @param{number}lat                 纬度      单位‘度’
     *  @param{number}remainder           余数      单位‘千秒’
     */
    CalculateRealRowIndex: function (lat, remainder) {
        // 理想行号
        var idealRow = this.CalculateIdealRowIndex(lat, remainder);
        switch (idealRow % 3) {
            case 0: // 第一行
                if (300000 - idealRow.remainder <= 12) {
                    idealRow.value++;
                }
                break;
            case 1: // 第二行
                break;
            case 2: // 第三行
                if (idealRow.remainder < 12) {
                    idealRow.value--;
                }
                break;
            default:
                break;
        }
        return idealRow;
    },
    /**
     * 根据经度计算该点位于实际图幅分割的列序号
     * @param {Number} lon       经度，单位“度”
     * @param {Number} remainder [description]
     */
    CalculateRealColumnIndex: function (lon, remainder) {
        return this.CalculateIdealColumnIndex(lon, remainder);
    },
    /*
     * 根据经度计算该点位于理想图幅分割的列序号
     *
     *  @param{number}lon                经度，单位“度”
     *  @param{number}reminder           余数 单位“千秒”
     */
    CalculateIdealColumnIndex: function (lon, remainder) {
        // 相对区域经度 = 绝对经度 - 60.0
        var regionLongitude = lon - 60.0;
        // 相对的以秒为单位的经度
        var secondLongitude = regionLongitude * 3600;
        // 为避免浮点数的内存影响，将秒*10的三次方(由于0.00001度为0.036秒)
        var longsecond = Math.floor(secondLongitude * 1000);
        remainder = Math.floor(longsecond % 450000);
        return {
            value: Math.floor(longsecond / 450000),
            reminder: remainder
        };
    },
    /**
     * 计算一个经纬度点所在的图幅
     * 传入的经纬度坐标不能是图廓点，图廓点计算出来的不准确
     * @param {[type]} lon 经度
     * @param {[type]} lat 纬度
     */
    CalculateMesh_25T: function (lon, lat) {
        var remainder = 0;
        var rowResult = this.CalculateRealRowIndex(lat, remainder);
        var colResult = this.CalculateRealColumnIndex(lon, rowResult.reminder);
        // 第1、2位 : 纬度取整拉伸1.5倍
        var M1M2 = Math.floor(lat * 1.5);
        // 第3、4位 : 经度减去日本角点 60度
        var M3M4 = Math.floor(lon) - 60;
        // 第5位 :
        var M5 = rowResult.value % 8;
        // 第6位 : 每列450秒，每度包含8列
        var M6 = colResult.value % 8;
        // 连接以上数字,组成图幅号
        var sMeshId = '' + M1M2 + M3M4 + M5 + M6;
        while (sMeshId.length < 6) {
            sMeshId = '0' + sMeshId;
        }
        return sMeshId;
    },
    /**
     * 计算一个经纬度点所在的图幅，角点和图廓点都返回其右上的图幅
     * @param {[type]} lon 经度
     * @param {[type]} lat 纬度
     */
    MeshLocator_25T: function (lon, lat) {
        // 为了保证它总返回右上的图幅
        if ((this.GetBorderModel_25T(lon, lat) & 0x0F) == 0x01) {
            lat += 0.00001;
        }
        var remainder = 0;
        var rowResult = this.CalculateRealRowIndex(lat, remainder);
        var colResult = this.CalculateRealColumnIndex(lon, rowResult.reminder);
        // 第1、2位 : 纬度取整拉伸1.5倍
        var M1M2 = Math.floor(lat * 1.5);
        // 第3、4位 : 经度减去日本角点 60度
        var M3M4 = Math.floor(lon) - 60;
        // 第5位 :
        var M5 = rowResult.value % 8;
        // 第6位 : 每列450秒，每度包含8列
        var M6 = colResult.value % 8;
        // 连接以上数字,组成图幅号
        var sMeshId = '' + M1M2 + M3M4 + M5 + M6;
        while (sMeshId.length < 6) {
            sMeshId = '0' + sMeshId;
        }
        return sMeshId;
    },
    /**
     * 获取坐标点所在的25T图幅，图幅内的点返回一个，图廓线上的点返回两个，图幅角点返回四个
     * @param {LatLng} latlng 经纬度坐标点
     * @return {Array} 图幅列表
     */
    GetMeshes_25T: function (latlng) {
        var lon = latlng.lng;
        var lat = latlng.lat;
        var meshes = [];
        var meshId;
        var borderModal = this.GetBorderModel_25T(lon, lat);
        var tmpLat,
            tmpLon;
        // 横向图幅线上的点，以及角点
        if ((borderModal & 0x0F) == 0x01) {
            tmpLat = lat + 0.00001;
            meshId = this.CalculateMesh_25T(lon, tmpLat);
            meshes.push(meshId);

            tmpLat = lat - 0.00001;
            meshId = this.CalculateMesh_25T(lon, tmpLat);
            meshes.push(meshId);

            if ((borderModal & 0xF0) == 0x10) {
                tmpLon = lon - 0.00001;
                tmpLat = lat + 0.00001;
                meshId = this.CalculateMesh_25T(tmpLon, tmpLat);
                meshes.push(meshId);

                tmpLat = lat - 0.00001;
                meshId = this.CalculateMesh_25T(tmpLon, tmpLat);
                meshes.push(meshId);
            }
        } else if ((borderModal & 0xF0) == 0x10) { // 纵向图幅线上的点，
            tmpLat = lat;
            tmpLon = lon + 0.00001;
            meshId = this.CalculateMesh_25T(tmpLon, tmpLat);
            meshes.push(meshId);

            tmpLon = lon - 0.00001;
            meshId = this.CalculateMesh_25T(tmpLon, tmpLat);
            meshes.push(meshId);
        }

        // 图幅内的点
        if (borderModal == 0) {
            meshes.push(this.CalculateMesh_25T(lon, lat));
        }

        return meshes;
    },
    /**
     * 点所在的图幅号,如果点在图幅边界上,返回右上的图幅号
     *
     * @param {L.Latlng}point   经纬度点
     */
    Calculate25TMeshId: function (point) {
        var mesh = this.MeshLocator_25T(point.lng, point.lat);
        return mesh;
    },
    /**
     * 快速计算点所在的图幅左下角点
     *
     * @param{L.Latlng}point          经纬度点
     */
    Calculate25TMeshCorner: function (point) {
        return this.Calculate25TMeshCornerByMeshId(this.Calculate25TMeshId(point));
    },
    /**
     * 计算图幅角点坐标
     * @param {String}mesh
     * @returns {*}
     * @constructor
     */
    Calculate25TMeshCornerByMeshId: function (mesh) {
        var cc = mesh.split('');
        var M1 = parseInt(cc[0], 0);
        var M2 = parseInt(cc[1], 0);
        var M3 = parseInt(cc[2], 0);
        var M4 = parseInt(cc[3], 0);
        var M5 = parseInt(cc[4], 0);
        var M6 = parseInt(cc[5], 0);
        var x = (M3 * 10 + M4) * 3600 + M6 * 450 + 60 * 3600;
        var y = (M1 * 10 + M2) * 2400 + M5 * 300;
        var point = L.latLng(y / 3600.0, x / 3600.0);
        return point;
    },
    /**
     *  计算图幅border
     * @param {String}mesh
     * @returns {{minLon:
     *   (*|a.lng|L.LatLng.lng|L.LatLngBounds._southWest.lng|L.LatLngBounds._northEast.lng|o.LatLngBounds._northEast.lng),
     *   minLat:
     *   (*|a.lat|L.LatLng.lat|L.LatLngBounds._southWest.lat|L.LatLngBounds._northEast.lat|o.LatLngBounds._northEast.lat),
     *   maxLon:
     *   (*|a.lng|L.LatLng.lng|L.LatLngBounds._southWest.lng|L.LatLngBounds._northEast.lng|o.LatLngBounds._northEast.lng),
     *   maxLat:
     *   (*|a.lat|L.LatLng.lat|L.LatLngBounds._southWest.lat|L.LatLngBounds._northEast.lat|o.LatLngBounds._northEast.lat)}}
     * @constructor
     */
    Calculate25TMeshBorder: function (mesh) {
        var cc = mesh.split('');
        var M1 = parseInt(cc[0], 0);
        var M2 = parseInt(cc[1], 0);
        var M3 = parseInt(cc[2], 0);
        var M4 = parseInt(cc[3], 0);
        var M5 = parseInt(cc[4], 0);
        var M6 = parseInt(cc[5], 0);
        var xConner = (M3 * 10 + M4) * 3600 + M6 * 450 + 60 * 3600;
        var yConner = (M1 * 10 + M2) * 2400 + M5 * 300;
        var xUpper = xConner + 450.0;
        var yUpper = yConner + 300.0;
        var leftBottom = L.latLng(yConner / 3600.0, xConner / 3600.0);
        var rightTop = L.latLng(yUpper / 3600.0, xUpper / 3600.0);
        return {
            minLon: leftBottom.lng,
            minLat: leftBottom.lat,
            maxLon: rightTop.lng,
            maxLat: rightTop.lat
        };
    },
    /**
     * 计算点与图幅边线的位置关系模式
     * @param{number}lon               经度
     * @param{number}lat               纬度
     */
    GetBorderModel_25T: function (lon, lat) {
        var model = 0;
        var remainder = 0;
        var rowResult = this.CalculateIdealRowIndex(lat, remainder);
        switch (rowResult.value % 3) {
            case 0: // 第一行
                if (300000 - rowResult.reminder == 12) {
                    model |= 0x01;
                } else if (rowResult.reminder == 0) model |= 0x01;
                break;
            case 1: // 第二行由于上下边框均不在其内，因此不在图框上
                break;
            case 2: // 第三行
                if (rowResult.reminder == 12) {
                    model |= 0x01;
                }
                break;
            default:
                break;
        }
        var colResult = this.CalculateRealColumnIndex(lon, rowResult.reminder);
        if (colResult.reminder == 0) model |= 0x10;
        return model;
    },
    /**
     * 判断一个坐标点是否在25T图幅的边框上
     * @param {LatLng} latlng 经纬度坐标点
     * @return {Boolean}
     */
    IsOnMeshBorder_25T: function (latlng) {
        var model = this.GetBorderModel_25T(latlng.lng, latlng.lat);

        return (model & 0x0F) == 0x01 || (model & 0xF0) == 0x10;
    },
    /**
     * 单例销毁方法
     * @return {[type]} [description]
     */
    destroy: function () {
        fastmap.mapApi.MeshAlgorithm.instance = null;
    },

    statics: {
        instance: null,

        getInstance: function () {
            if (!fastmap.mapApi.MeshAlgorithm.instance) {
                fastmap.mapApi.MeshAlgorithm.instance =
                    new fastmap.mapApi.MeshAlgorithm();
            }
            return fastmap.mapApi.MeshAlgorithm.instance;
        }
    }
});

/**
 * Geometry
 * 基于leaflet的几何基类
 *
 * @namespace mapApi
 * @class Geometry
 */
fastmap.mapApi.Geometry = L.Class.extend({
    /**
     * 几何类型
     * type
     * @property type
     * @type String
     */
    type: 'Geometry',

    /**
     * @method initialize
     * 初始化构造函数
     *
     */
    initialize: function () {
        this.bounds = null;
    },

    /**
     * 深度拷贝几何.
     * @method clone
     * @return {!fastmap.mapApi.Geometry} Clone.
     */
    clone: fastmap.abstractMethod,

    /**
     * 获取几何的外包框.
     * @method  getExtent
     * @param {fastmap.mapApi.Extent} opt_extent Extent.
     * @return {fastmap.mapApi.Extent} extent Extent.
     */
    getExtent: fastmap.abstractMethod,

    /**
     * 清除外包框
     */
    clearBounds: function () {
        this.bounds = null;
        if (this.parent) {
            this.parent.clearBounds();
        }
    },

    /**
     * 通过wkt生成几何类
     * @method fromWkt
     *
     * @param {string} wkt.
     * @return {fastmap.mapApi.Geometry} geometry.
     */
    fromWkt: function (wkt) {
        return null;
    },

    /**
     * 几何类生成wkt
     * @method toWkt
     *
     * @return {string} geoJsonString.
     */
    toWkt: function () {
        return '';
    },

    /**
     * 计算两个几何之间的距离
     * @method distanceTo
     *
     * @param {fastmap.mapApi.Geometry} 用于计算距离的另外一个几何
     * @param {Object} Optional 计算距离时所需要的其他参数
     *
     * @return {Number | Object} 返回距离和相应的两个点
     */
    distanceTo: function (geometry, options) {

    }
});

/**
 * Function: OpenLayers.Geometry.fromWKT
 * Generate a geometry given a Well-Known Text string.  For this method to
 *     work, you must include the OpenLayers.Format.WKT in your build
 *     explicitly.
 *
 * Parameters:
 * wkt - {String} A string representing the geometry in Well-Known Text.
 *
 * Returns:
 * {<OpenLayers.Geometry>} A geometry of the appropriate class.
 */
fastmap.mapApi.Geometry.fromWKT = function (wkt) {
    var geom;
    // if (OpenLayers.Format && OpenLayers.Format.WKT) {
    //     var format = OpenLayers.Geometry.fromWKT.format;
    //     if (!format) {
    //         format = new OpenLayers.Format.WKT();
    //         OpenLayers.Geometry.fromWKT.format = format;
    //     }
    //     var result = format.read(wkt);
    //     if (result instanceof OpenLayers.Feature.Vector) {
    //         geom = result.geometry;
    //     } else if (OpenLayers.Util.isArray(result)) {
    //         var len = result.length;
    //         var components = new Array(len);
    //         for (var i = 0; i < len; ++i) {
    //             components[i] = result[i].geometry;
    //         }
    //         geom = new OpenLayers.Geometry.Collection(components);
    //     }
    // }
    return geom;
};

/**
 * Method: OpenLayers.Geometry.segmentsIntersect
 * Determine whether two line segments intersect.  Optionally calculates
 *     and returns the intersection point.  This function is optimized for
 *     cases where seg1.x2 >= seg2.x1 || seg2.x2 >= seg1.x1.  In those
 *     obvious cases where there is no intersection, the function should
 *     not be called.
 *
 * Parameters:
 * seg1 - {Object} Object representing a segment with properties x1, y1, x2,
 *     and y2.  The start point is represented by x1 and y1.  The end point
 *     is represented by x2 and y2.  Start and end are ordered so that x1 < x2.
 * seg2 - {Object} Object representing a segment with properties x1, y1, x2,
 *     and y2.  The start point is represented by x1 and y1.  The end point
 *     is represented by x2 and y2.  Start and end are ordered so that x1 < x2.
 * options - {Object} Optional properties for calculating the intersection.
 *
 * Valid options:
 * point - {Boolean} Return the intersection point.  If false, the actual
 *     intersection point will not be calculated.  If true and the segments
 *     intersect, the intersection point will be returned.  If true and
 *     the segments do not intersect, false will be returned.  If true and
 *     the segments are coincident, true will be returned.
 * tolerance - {Number} If a non-null value is provided, if the segments are
 *     within the tolerance distance, this will be considered an intersection.
 *     In addition, if the point option is true and the calculated intersection
 *     is within the tolerance distance of an end point, the endpoint will be
 *     returned instead of the calculated intersection.  Further, if the
 *     intersection is within the tolerance of endpoints on both segments, or
 *     if two segment endpoints are within the tolerance distance of eachother
 *     (but no intersection is otherwise calculated), an endpoint on the
 *     first segment provided will be returned.
 *
 * Returns:
 * {Boolean | <OpenLayers.Geometry.Point>}  The two segments intersect.
 *     If the point argument is true, the return will be the intersection
 *     point or false if none exists.  If point is true and the segments
 *     are coincident, return will be true (and the instersection is equal
 *     to the shorter segment).
 */
fastmap.mapApi.Geometry.segmentsIntersect = function (seg1, seg2, options) {
    var point = options && options.point;
    var tolerance = options && options.tolerance;
    var intersection = false;
    var x1121 = seg1.x1 - seg2.x1;
    var y1121 = seg1.y1 - seg2.y1;
    var x1211 = seg1.x2 - seg1.x1;
    var y1211 = seg1.y2 - seg1.y1;
    var y2221 = seg2.y2 - seg2.y1;
    var x2221 = seg2.x2 - seg2.x1;
    var d = (y2221 * x1211) - (x2221 * y1211);
    var n1 = (x2221 * y1121) - (y2221 * x1121);
    var n2 = (x1211 * y1121) - (y1211 * x1121);
    if (d == 0) {
        // parallel
        if (n1 == 0 && n2 == 0) {
            // coincident
            intersection = true;
        }
    } else {
        var along1 = n1 / d;
        var along2 = n2 / d;
        if (along1 >= 0 && along1 <= 1 && along2 >= 0 && along2 <= 1) {
            // intersect
            if (!point) {
                intersection = true;
            } else {
                // calculate the intersection point
                var px = seg1.x1 + (along1 * x1211);
                var py = seg1.y1 + (along1 * y1211);
                intersection = new fastmap.mapApi.Point(px, py);
            }
        }
    }
    if (tolerance) {
        var dist;
        var segs = [seg1, seg2];
        var seg;
        var x;
        var y;
        var i;
        var j;
        if (intersection) {
            if (point) {
                // check segment endpoints for proximity to intersection
                // set intersection to first endpoint within the tolerance
                outer: for (i = 0; i < 2; ++i) {
                    seg = segs[i];
                    for (j = 1; j < 3; ++j) {
                        x = seg['x' + j];
                        y = seg['y' + j];
                        dist = Math.sqrt(
                                Math.pow(x - intersection.x, 2) +
                                Math.pow(y - intersection.y, 2)
                        );
                        if (dist < tolerance) {
                            intersection.x = x;
                            intersection.y = y;
                            break outer;
                        }
                    }
                }
            }
        } else {
            // no calculated intersection, but segments could be within
            // the tolerance of one another
            var source,
                target,
                p,
                result;
            // check segment endpoints for proximity to intersection
            // set intersection to first endpoint within the tolerance
            outer: for (i = 0; i < 2; ++i) {
                source = segs[i];
                target = segs[(i + 1) % 2];
                for (j = 1; j < 3; ++j) {
                    p = { x: source['x' + j], y: source['y' + j] };
                    result = fastmap.mapApi.Geometry.distanceToSegment(p, target);
                    if (result.distance < tolerance) {
                        if (point) {
                            intersection = new fastmap.mapApi.Point(p.x, p.y);
                        } else {
                            intersection = true;
                        }
                        break outer;
                    }
                }
            }
        }
    }
    return intersection;
};

/**
 * Function: OpenLayers.Geometry.distanceToSegment
 *
 * Parameters:
 * point - {Object} An object with x and y properties representing the
 *     point coordinates.
 * segment - {Object} An object with x1, y1, x2, and y2 properties
 *     representing endpoint coordinates.
 *
 * Returns:
 * {Object} An object with distance, along, x, and y properties.  The distance
 *     will be the shortest distance between the input point and segment.
 *     The x and y properties represent the coordinates along the segment
 *     where the shortest distance meets the segment. The along attribute
 *     describes how far between the two segment points the given point is.
 */
fastmap.mapApi.Geometry.distanceToSegment = function (point, segment) {
    var result = fastmap.mapApi.Geometry.distanceSquaredToSegment(point, segment);
    result.distance = Math.sqrt(result.distance);
    return result;
};

/**
 * Function: OpenLayers.Geometry.distanceSquaredToSegment
 *
 * Usually the distanceToSegment function should be used. This variant however
 * can be used for comparisons where the exact distance is not important.
 *
 * Parameters:
 * point - {Object} An object with x and y properties representing the
 *     point coordinates.
 * segment - {Object} An object with x1, y1, x2, and y2 properties
 *     representing endpoint coordinates.
 *
 * Returns:
 * {Object} An object with squared distance, along, x, and y properties.
 *     The distance will be the shortest distance between the input point and
 *     segment. The x and y properties represent the coordinates along the
 *     segment where the shortest distance meets the segment. The along
 *     attribute describes how far between the two segment points the given
 *     point is.
 */
fastmap.mapApi.Geometry.distanceSquaredToSegment = function (point, segment) {
    var x0 = point.x;
    var y0 = point.y;
    var x1 = segment.x1;
    var y1 = segment.y1;
    var x2 = segment.x2;
    var y2 = segment.y2;
    var dx = x2 - x1;
    var dy = y2 - y1;
    var along = ((dx * (x0 - x1)) + (dy * (y0 - y1))) /
        (Math.pow(dx, 2) + Math.pow(dy, 2));
    var x,
        y;
    if (along <= 0.0) {
        x = x1;
        y = y1;
    } else if (along >= 1.0) {
        x = x2;
        y = y2;
    } else {
        x = x1 + along * dx;
        y = y1 + along * dy;
    }
    return {
        distance: Math.pow(x - x0, 2) + Math.pow(y - y0, 2),
        x: x,
        y: y,
        along: along
    };
};

fastmap.mapApi.geometry = function () {
    return new fastmap.mapApi.Geometry();
};

/**
 * Created by zhongxiaoming on 2015/10/14.
 * Class Collection 组成几何对象的几何集合
 */
fastmap.mapApi.Collection = fastmap.mapApi.Geometry.extend({

    /**
     * 几何类型
     * type
     * @property type
     * @type Collection
     */
    type: 'Collection',

    /**
     * 组成部分
     * components
     * @property components
     */
    components: [],

    initialize: function (components) {
        this.components = [];
        if (components != null) {
            this.addComponents(components);
        }
    },

    /** *
     * 返回组成集合的字符串
     * @returns {string}
     */
    getComponentsString: function () {
        var i;
        var len;
        var strings = [];
        for (i = 0, len = this.components.length; i < len; i++) {
            strings.push(this.components[i].toShortString());
        }
        return strings.join(',');
    },

    /** *
     * 计算外包框
     */
    calculateBounds: function () {},

    /** *
     * 向几何对象中加入组件数组
     * @param components
     */
    addComponents: function (components) {
        var i,
            len;
        if (!(L.Util.isArray(components))) {
            components = [components];
        }
        for (i = 0, len = components.length; i < len; i++) {
            this.addComponent(components[i]);
        }
    },

    /** *
     * 向几何对象中加入组件
     * @param component
     * @param index
     */
    addComponent: function (component, index) {
        var added = false;
        var components1;
        var components2;
        if (component) {
            if (this.componentTypes == null
                // || (OpenLayers.Util.indexOf(this.componentTypes,
                //     component.CLASS_NAME) > -1)
            ) {
                if (index != null && (index < this.components.length)) {
                    components1 = this.components.slice(0, index);
                    components2 = this.components.slice(index,
                        this.components.length);
                    components1.push(component);
                    this.components = components1.concat(components2);
                } else {
                    this.components.push(component);
                }
                component.parent = this;
                this.clearBounds();
                added = true;
            }
        }
        return added;
    },

    /** *
     * 删除指定的组件数组
     * @param components
     */
    removeComponents: function (components) {},

    /** *
     * 删除指定的组件
     * @param component
     */
    removeComponent: function (component) {},

    /** *
     * 获取几何对象节点
     * @param nodes
     */
    getVertices: function (nodes) {},

    clone: function () {
        var components = this.components.slice(0);
        var newColl = new fastmap.mapApi.Collection(components);
        newColl.type = this.type;
        return newColl;
    }
});

/* global fastmap b:true */
/**
 * Point
 * 基于Geometry的Point类
 *
 * @namespace mapApi
 * @class Point
 */
fastmap.mapApi.Point = fastmap.mapApi.Geometry.extend({
    /**
     * 几何类型
     * type
     * @property type
     * @type String
     */
    type: 'Point',
    /**
     * 点的横坐标
     * x
     * @property x
     * @type Number
     */
    x: null,

    /**
     * 点的纵坐标
     * y
     * @property y
     * @type Number
     */
    y: null,

    /**
     * @method initialize
     * 初始化构造函数
     *
     * @param {Number} x 横坐标
     * @param {Number} y 纵坐标
     *
     */
    initialize: function (x, y) {
        fastmap.mapApi.Geometry.prototype.initialize.apply(this, arguments);

        this.x = parseFloat(x);
        this.y = parseFloat(y);
    },

    /**
     * 深度拷贝几何.
     * @method clone
     * @return {fastmap.mapApi.Point} Clone.
     */
    clone: function () {
        var obj = new fastmap.mapApi.Point(this.x, this.y);

        return obj;
    },

    /**
     * 与传入几何对象间的距离
     * @method distanceTo
     * @return {object} result.
     */
    distanceTo: function (geometry, options) {
        var edge = !(options && options.edge === false);
        var details = edge && options && options.details;
        var distance,
            x0,
            y0,
            x1,
            y1,
            result;
        if (geometry instanceof fastmap.mapApi.Point) {
            x0 = this.x;
            y0 = this.y;
            x1 = geometry.x;
            y1 = geometry.y;
            distance = Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));
            result = !details ?
                distance : { x0: x0, y0: y0, x1: x1, y1: y1, distance: distance };
        } else {
            result = geometry.distanceTo(this, options);
            if (details) {
                result = {
                    x0: result.x1,
                    y0: result.y1,
                    x1: result.x0,
                    y1: result.y0,
                    distance: result.distance
                };
            }
        }
        return result;
    },

    /**
     * 计算点对象的外包框
     * @method calculateBounds
     *
     * @return {fastmap.mapApi.Bounds}.
     */
    calculateBounds: function () {
        this.bounds = new fastmap.mapApi.Bounds(this.x, this.y, this.x, this.y);
        return this.bounds;
    },
    /**
     * 移动点
     * @method move
     * @param {Number}x
     * @param {Number}y
     */
    move: function (x, y) {
        this.x = this.x + x;
        this.y = this.y + y;
        this.bounds = null;
    },

    /**
     * 获取中心点
     * @method getCentroid
     * @returns {fastmap.mapApi.Point}
     */
    getCentroid: function () {
        return new fastmap.mapApi.Point(this.x, this.y);
    },

    /**
     * 判断点与几何相关空间位置关系，是否相交
     * @method intersects
     * @param {Geometry}geometry
     * @returns {boolean}
     */
    intersects: function (geometry) {
        var intersect = false;
        if (geometry.type === 'Point') {
            intersect = this.equals(geometry);
        } else {
            intersect = geometry.intersects(this);
        }
        return intersect;
    },
    getVertices: function (nodes) {
        return [this];
    }
});
fastmap.mapApi.point = function (x, y) {
    return new fastmap.mapApi.Point(x, y);
};


/**
 * Created by liwanchong on 2015/9/8.
 * lineString对象
 * @namespace fast.mapApi
 * @class LineString
 */
fastmap.mapApi.LineString = fastmap.mapApi.Collection.extend({
    /**
     * 几何类型
     * type
     * @property type
     * @type String
     */
    type: 'LineString',

    /**
     * @class LineString
     * @constructor
     * @namespace fastmap.mapApi
     * @param {Array}Points
     */
    initialize: function (points) {
        fastmap.mapApi.Collection.prototype.initialize.apply(this, arguments);
        this.points = points;
    },

    /**
     * 删除点
     * @method removeComponent
     * @return ｛boolean｝ 是否删除成功.
     */
    removeComponent: function (point) {
        var removed = this.components && (this.components.length > 2);
        if (removed) {
            fastmap.mapApi.Collection.prototype.removeComponent.apply(this,
                arguments);
        }
        return removed;
    },

    /**
     * 复制整个lineString
     * @method clone
     * @return LineString Clone.
     */
    clone: function () {
        var newpoints = [];
        newpoints = this.points.slice(0);
        var lineString = new fastmap.mapApi.LineString(newpoints);
        return lineString;
    },
    /**
     *获取lineString坐标数据
     * @method getCoordinates
     * @param {Array}coordinates
     */

    getCoordinates: function () {
    },
    /**
     * 获取开始点
     * @method getStartPoint
     * @param {Point}coordinates
     */
    getStartPoint: function (coordinates) {

    },
    /**
     * 获取线的结束点
     * @method getEndPoint
     * @param {Point} coordinates
     */
    getEndPoint: function (coordinates) {

    },
    /**
     *点到线的小片段的距离
     * @method pointToSegmentDistance
     * @param {Point}p
     * @param {Point}p1
     * @param {Point}p2
     * @returns {number}
     */
    pointToSegmentDistance: function (/* Point*/ p, /* Point*/ p1, /* Point*/ p2) {
        return this._sqClosestPointOnSegment(p, p1, p2);
    },

    _sqClosestPointOnSegment: function (p, p1, p2) {
        var x0 = p.x;
        var y0 = p.y;
        var x1 = p1.x;
        var y1 = p1.y;
        var x2 = p2.x;
        var y2 = p2.y;
        var dx = x2 - x1;
        var dy = y2 - y1;
        var along = ((dx * (x0 - x1)) + (dy * (y0 - y1))) /
            (Math.pow(dx, 2) + Math.pow(dy, 2));
        var x,
            y;
        if (along <= 0.0) {
            x = x1;
            y = y1;
        } else if (along >= 1.0) {
            x = x2;
            y = y2;
        } else {
            x = x1 + along * dx;
            y = y1 + along * dy;
        }
        return {
            distance: Math.sqrt(Math.pow(x - x0, 2) + Math.pow(y - y0, 2)),
            x: x,
            y: y,
            along: along
        };
    },
    /**
     *判断线是否交汇
     * @method intersects
     * @param {Geometry}geometry
     * @returns {boolean}
     */
    intersects: function (geometry) {
        var intersect = false;
        var type = geometry.type;
        if (type == 'LineString' ||
            type == 'LinearRing' ||
            type == 'Point') {
            var segs1 = this.getSortedSegments();
            var segs2;
            if (type == 'Point') {
                segs2 = [{
                    x1: geometry.x,
                    y1: geometry.y,
                    x2: geometry.x,
                    y2: geometry.y
                }];
            } else {
                segs2 = geometry.getSortedSegments();
            }
            var seg1,
                seg1x1,
                seg1x2,
                seg1y1,
                seg1y2,
                seg2,
                seg2y1,
                seg2y2;
            // sweep right
            outer: for (var i = 0, len = segs1.length; i < len; ++i) {
                seg1 = segs1[i];
                seg1x1 = seg1.x1;
                seg1x2 = seg1.x2;
                seg1y1 = seg1.y1;
                seg1y2 = seg1.y2;
                for (var j = 0, jlen = segs2.length; j < jlen; ++j) {
                    seg2 = segs2[j];
                    if (seg2.x1 > seg1x2) {
                        // seg1 still left of seg2
                        break;
                    }
                    if (seg2.x2 < seg1x1) {
                        // seg2 still left of seg1
                        continue;
                    }
                    seg2y1 = seg2.y1;
                    seg2y2 = seg2.y2;
                    if (Math.min(seg2y1, seg2y2) > Math.max(seg1y1, seg1y2)) {
                        // seg2 above seg1
                        continue;
                    }
                    if (Math.max(seg2y1, seg2y2) < Math.min(seg1y1, seg1y2)) {
                        // seg2 below seg1
                        continue;
                    }
                    if (fastmap.mapApi.Geometry.segmentsIntersect(seg1, seg2)) {
                        intersect = true;
                        break outer;
                    }
                }
            }
        } else {
            intersect = geometry.intersects(this);
        }
        return intersect;
    },
    /**
     * 获取组成线的片段
     *@method getSortedSegments
     * @param {Boolean}boolsort 是否返回排序的片段
     * Returns:
     * {Array} An array of segment objects.  Segment objects have properties
     *     x1, y1, x2, and y2.  The start point is represented by x1 and y1.
     *     The end point is represented by x2 and y2.  Start and end are
     *     ordered so that x1 < x2.
     */
    getSortedSegments: function (boolsort) {
        var numSeg = this.components.length - 1;
        var segments = new Array(numSeg);
        var point1,
            point2;
        for (var i = 0; i < numSeg; ++i) {
            point1 = this.components[i];
            point2 = this.components[i + 1];
            if (point1.x < point2.x) {
                segments[i] = {
                    x1: point1.x,
                    y1: point1.y,
                    x2: point2.x,
                    y2: point2.y
                };
            } else {
                segments[i] = {
                    x1: point2.x,
                    y1: point2.y,
                    x2: point1.x,
                    y2: point1.y
                };
            }
        }
        // more efficient to define this somewhere static
        function byX1(seg1, seg2) {
            return seg1.x1 - seg2.x1;
        }

        if (boolsort == true) {
            return segments.sort(byX1);
        }
        return segments;
    },

    getSegments: function () {
        var numSeg = this.components.length - 1;
        var segments = new Array(numSeg);
        var point1,
            point2;
        for (var i = 0; i < numSeg; ++i) {
            point1 = this.components[i];
            point2 = this.components[i + 1];
            segments[i] = {
                x1: point1.x,
                y1: point1.y,
                x2: point2.x,
                y2: point2.y
            };
        }
        return segments;
    },

    /**
     *把线分离成多个片段
     *@method splitWithSegment
     * @param {Object}seg
     * @param {Object}options
     */
    splitWithSegment: function (seg, options) {
        var edge = !(options && options.edge === false);
        var tolerance = options && options.tolerance;
        var lines = [];
        var verts = this.getVertices();
        var points = [];
        var intersections = [];
        var split = false;
        var vert1,
            vert2,
            point;
        var node,
            vertex,
            target;
        var interOptions = { point: true, tolerance: tolerance };
        var result = null;
        for (var i = 0, stop = verts.length - 2; i <= stop; ++i) {
            vert1 = verts[i];
            points.push(vert1.clone());
            vert2 = verts[i + 1];
            target = { x1: vert1.x, y1: vert1.y, x2: vert2.x, y2: vert2.y };
            point = fastmap.mapApi.Geometry.segmentsIntersect(
                seg, target, interOptions
            );
            if (point instanceof fastmap.mapApi.Point) {
                if ((point.x === seg.x1 && point.y === seg.y1) ||
                    (point.x === seg.x2 && point.y === seg.y2) ||
                    point.equals(vert1) || point.equals(vert2)) {
                    vertex = true;
                } else {
                    vertex = false;
                }
                if (vertex || edge) {
                    // push intersections different than the previous
                    if (!point.equals(intersections[intersections.length - 1])) {
                        intersections.push(point.clone());
                    }
                    if (i === 0) {
                        if (point.equals(vert1)) {
                            continue;
                        }
                    }
                    if (point.equals(vert2)) {
                        continue;
                    }
                    split = true;
                    if (!point.equals(vert1)) {
                        points.push(point);
                    }
                    lines.push(new fastmap.mapApi.LineString(points));
                    points = [point.clone()];
                }
            }
        }
        if (split) {
            points.push(vert2.clone());
            lines.push(new fastmap.mapApi.LineString(points));
        }
        if (intersections.length > 0) {
            // sort intersections along segment
            var xDir = seg.x1 < seg.x2 ? 1 : -1;
            var yDir = seg.y1 < seg.y2 ? 1 : -1;
            result = {
                lines: lines,
                points: intersections.sort(function (p1, p2) {
                    return (xDir * p1.x - xDir * p2.x) || (yDir * p1.y - yDir * p2.y);
                })
            };
        }
        return result;
    },
    /**
     * 根据参数分离geometry
     *@method split
     * @param {Object}target
     * @param {Object}options
     */
    split: function (target, options) {
        var results = null;
        var mutual = options && options.mutual;
        var sourceSplit,
            targetSplit,
            sourceParts,
            targetParts;
        if (target instanceof fastmap.mapApi.LineString) {
            var verts = this.getVertices();
            var vert1,
                vert2,
                seg,
                splits,
                lines,
                point;
            var points = [];
            sourceParts = [];
            for (var i = 0, stop = verts.length - 2; i <= stop; ++i) {
                vert1 = verts[i];
                vert2 = verts[i + 1];
                seg = {
                    x1: vert1.x,
                    y1: vert1.y,
                    x2: vert2.x,
                    y2: vert2.y
                };
                targetParts = targetParts || [target];
                if (mutual) {
                    points.push(vert1.clone());
                }
                for (var j = 0; j < targetParts.length; ++j) {
                    splits = targetParts[j].splitWithSegment(seg, options);
                    if (splits) {
                        // splice in new features
                        lines = splits.lines;
                        if (lines.length > 0) {
                            lines.unshift(j, 1);
                            Array.prototype.splice.apply(targetParts, lines);
                            j += lines.length - 2;
                        }
                        if (mutual) {
                            for (var k = 0, len = splits.points.length; k < len; ++k) {
                                point = splits.points[k];
                                if (!point.equals(vert1)) {
                                    points.push(point);
                                    sourceParts.push(new fastmap.mapApi.LineString(points));
                                    if (point.equals(vert2)) {
                                        points = [];
                                    } else {
                                        points = [point.clone()];
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (mutual && sourceParts.length > 0 && points.length > 0) {
                points.push(vert2.clone());
                sourceParts.push(new fastmap.mapApi.LineString(points));
            }
        } else {
            results = target.splitWith(this, options);
        }
        if (targetParts && targetParts.length > 1) {
            targetSplit = true;
        } else {
            targetParts = [];
        }
        if (sourceParts && sourceParts.length > 1) {
            sourceSplit = true;
        } else {
            sourceParts = [];
        }
        if (targetSplit || sourceSplit) {
            if (mutual) {
                results = [sourceParts, targetParts];
            } else {
                results = targetParts;
            }
        }
        return results;
    },

    splitWith: function (geometry, options) {
        return geometry.split(this, options);
    },

    /**
     * 距线最近的点
     * @method distanceTo
     * @param {Geometry}geometry
     * @param {Object}options
     * @returns {{}}
     */
    distanceTo: function (geometry, options) {
        var edge = !(options && options.edge === false);
        var details = edge && options && options.details;
        var result;
        var best = {};
        var min = Number.POSITIVE_INFINITY;
        var i;
        if (geometry instanceof fastmap.mapApi.Point) {
            var segs = this.getSortedSegments();
            var x = geometry.x;
            var y = geometry.y;
            var seg;
            for (i = 0; i < segs.length; ++i) {
                seg = segs[i];
                result = fastmap.mapApi.Geometry.distanceToSegment(geometry, seg);
                if (result.distance < min) {
                    min = result.distance;
                    best = result;
                    if (min === 0) {
                        break;
                    }
                } else if (seg.x2 > x && ((y > seg.y1 && y < seg.y2) || (y < seg.y1 && y > seg.y2))) {
                    // if distance increases and we cross y0 to the right of x0, no need to keep looking.
                    break;
                }
            }
            if (details) {
                best = {
                    distance: best.distance,
                    x0: best.x,
                    y0: best.y,
                    x1: x,
                    y1: y
                };
            } else {
                best = best.distance;
            }
        } else if (geometry instanceof fastmap.mapApi.LineString) {
            var segs0 = this.getSortedSegments();
            var segs1 = geometry.getSortedSegments();
            var seg0,
                seg1,
                intersection,
                x0,
                y0;
            var len1 = segs1.length;
            var interOptions = { point: true };
            outer: for (i = 0; i < segs0.length; ++i) {
                seg0 = segs0[i];
                x0 = seg0.x1;
                y0 = seg0.y1;
                for (var j = 0; j < len1; ++j) {
                    seg1 = segs1[j];
                    intersection = fastmap.mapApi.Geometry.segmentsIntersect(seg0, seg1, interOptions);
                    if (intersection) {
                        min = 0;
                        best = {
                            distance: 0,
                            x0: intersection.x,
                            y0: intersection.y,
                            x1: intersection.x,
                            y1: intersection.y
                        };
                        break outer;
                    } else {
                        result = fastmap.mapApi.Geometry.distanceToSegment({ x: x0, y: y0 }, seg1);
                        if (result.distance < min) {
                            min = result.distance;
                            best = {
                                distance: min,
                                x0: x0,
                                y0: y0,
                                x1: result.x,
                                y1: result.y
                            };
                        }
                    }
                }
            }
            if (!details) {
                best = best.distance;
            }
            if (min !== 0) {
                // check the final vertex in this line's sorted segments
                if (seg0) {
                    result = geometry.distanceTo(
                        new fastmap.mapApi.Point(seg0.x2, seg0.y2),
                        options
                    );
                    var dist = details ? result.distance : result;
                    if (dist < min) {
                        if (details) {
                            best = {
                                distance: min,
                                x0: result.x1,
                                y0: result.y1,
                                x1: result.x0,
                                y1: result.y0
                            };
                        } else {
                            best = dist;
                        }
                    }
                }
            }
        } else {
            best = geometry.distanceTo(this, options);
            // swap since target comes from this line
            if (details) {
                best = {
                    distance: best.distance,
                    x0: best.x1,
                    y0: best.y1,
                    x1: best.x0,
                    y1: best.y0
                };
            }
        }
        return best;
    },

    getVertices: function (nodes) {
        var vertices;
        if (nodes === true) {
            vertices = [
                this.components[0],
                this.components[this.components.length - 1]
            ];
        } else if (nodes === false) {
            vertices = this.components.slice(1, this.components.length - 1);
        } else {
            vertices = this.components.slice();
        }
        return vertices;
    },

    /**
     *根据容差获取数据
     * @method simplify
     * @param {Number}tolerance
     */
    simplify: function (tolerance) {
        if (this && this !== null) {
            var points = this.getVertices();
            if (points.length < 3) {
                return this;
            }
            var compareNumbers = function (a, b) {
                return (a - b);
            };
            var firstPoint = 0;
            var lastPoint = points.length - 1;
            var pointIndexsToKeep = [];

            // Add the first and last index to the keepers
            pointIndexsToKeep.push(firstPoint);
            pointIndexsToKeep.push(lastPoint);

            // The first and the last point cannot be the same
            while (points[firstPoint].equals(points[lastPoint])) {
                lastPoint--;
                // Addition: the first point not equal to first point in the LineString is kept as well
                pointIndexsToKeep.push(lastPoint);
            }

            /**
             * Private function calculating the perpendicular distance
             * TODO: check whether OpenLayers.Geometry.LineString::distanceTo() is faster or slower
             */
            var perpendicularDistance = function (point1, point2, point) {
                // Area = |(1/2)(x1y2 + x2y3 + x3y1 - x2y1 - x3y2 - x1y3)|   *Area of triangle
                // Base = v((x1-x2)²+(x1-x2)²)                               *Base of Triangle*
                // Area = .5*Base*H                                          *Solve for height
                // Height = Area/.5/Base

                var area = Math.abs(0.5 * (point1.x * point2.y + point2.x * point.y + point.x * point1.y - point2.x * point1.y - point.x * point2.y - point1.x * point.y));
                var bottom = Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2));
                var height = area / bottom * 2;

                return height;
            };
            /**
             * Private function doing the Douglas-Peucker reduction
             */
            var douglasPeuckerReduction = function (points1, firstPoint1, lastPoint1, tolerance1) {
                var maxDistance = 0;
                var indexFarthest = 0;

                for (var index = firstPoint1, distance; index < lastPoint1; index++) {
                    distance = perpendicularDistance(points1[firstPoint1], points1[lastPoint1], points1[index]);
                    if (distance > maxDistance) {
                        maxDistance = distance;
                        indexFarthest = index;
                    }
                }

                if (maxDistance > tolerance1 && indexFarthest != firstPoint1) {
                    // Add the largest point that exceeds the tolerance1
                    pointIndexsToKeep.push(indexFarthest);
                    douglasPeuckerReduction(points1, firstPoint1, indexFarthest, tolerance1);
                    douglasPeuckerReduction(points1, indexFarthest, lastPoint1, tolerance1);
                }
            };
            douglasPeuckerReduction(points, firstPoint, lastPoint, tolerance);
            var returnPoints = [];
            pointIndexsToKeep.sort(compareNumbers);
            for (var index = 0; index < pointIndexsToKeep.length; index++) {
                returnPoints.push(points[pointIndexsToKeep[index]]);
            }
            // return new OpenLayers.Geometry.LineString(returnPoints);
            return new FM.Geometry.LineString(returnPoints);
        }
        return this;
    }
});
fastmap.mapApi.lineString = function (coordiates) {
    return new fastmap.mapApi.LineString(coordiates);
};


/**
 * Created by wangtun on 2015/9/10.
 * Polygon 对象
 * @namespace fast.mapApi
 * @class Polygon
 */
fastmap.mapApi.Polygon = fastmap.mapApi.Collection.extend({
    type: 'Polygon',
    components: [],
    options: {},
    /**
     * 构造函数
     * @class Polygon
     * @constructor
     * @param {Array}components
     * @param {Object}options
     */
    initialize: function (components, options) {
        this.components = components;
        this.options = options;
    },
    /**
     * 获取面积
     * @method getArea
     * @returns {number}
     */
    getArea: function () {
        var area = 0.0;
        var i,
            len;
        if (this.components && (this.components.length > 0)) {
            area += Math.abs(this.components[0].getArea());
            for (i = 1, len = this.components.length; i < len; i++) {
                area -= Math.abs(this.components[i].getArea());
            }
        }
        return area;
    },
    /**
     * 是否包含某点
     * @method containsPoint
     * @param {Point}point
     * @returns {boolean}
     */
    containsPoint: function (point) {
        var numRings = this.components.length;
        var contained = false;
        var hole,
            i,
            len;
        if (numRings > 0) {
            // check exterior ring - 1 means on edge, boolean otherwise
            contained = this.components[0].containsPoint(point);
            if (contained !== 1) {
                if (contained && numRings > 1) {
                    // check interior rings
                    for (i = 1; i < numRings; ++i) {
                        hole = this.components[i].containsPoint(point);
                        if (hole) {
                            if (hole === 1) {
                                // on edge
                                contained = 1;
                            } else {
                                // in hole
                                contained = false;
                            }
                            break;
                        }
                    }
                }
            }
        }
        return contained;
    },
    /**
     * 相交
     * @method intersects
     * @param {Geometry}geometry
     * @returns {boolean}
     */
    intersects: function (geometry) {
        var intersect = false;
        var i,
            len,
            ring;
        if (geometry.type === 'Point') {
            intersect = this.containsPoint(geometry);
        } else if (geometry.type === 'LineString' ||
            geometry.type === 'LinearRing') {
            // check if rings/linestrings intersect
            for (i = 0, len = this.components.length; i < len; ++i) {
                intersect = geometry.intersects(this.components[i]);
                if (intersect) {
                    break;
                }
            }
            if (!intersect) {
                // check if this poly contains points of the ring/linestring
                for (i = 0, len = geometry.components.length; i < len; ++i) {
                    intersect = this.containsPoint(geometry.components[i]);
                    if (intersect) {
                        break;
                    }
                }
            }
        } else {
            for (i = 0, len = geometry.components.length; i < len; ++i) {
                intersect = this.intersects(geometry.components[i]);
                if (intersect) {
                    break;
                }
            }
        }
        // check case where this poly is wholly contained by another
        if (!intersect && geometry.type === 'Polygon') {
            // exterior ring points will be contained in the other geometry
            ring = this.components[0];
            for (i = 0, len = ring.components.length; i < len; ++i) {
                intersect = geometry.containsPoint(ring.components[i]);
                if (intersect) {
                    break;
                }
            }
        }
        return intersect;
    },
    /**
     * 获取到polygon最近的点
     * @method distanceTo
     * @param {Geometry}geometry
     * @param {Object}options
     * @returns {*}
     */
    distanceTo: function (geometry, options) {
        var edge = !(options && options.edge === false);
        var result;
        // this is the case where we might not be looking for distance to edge
        if (!edge && this.intersects(geometry)) {
            result = 0;
        } else {
            result = fastmap.mapApi.Collection.prototype.distanceTo.apply(
                this, [geometry, options]
            );
        }
        return result;
    },
    /**
     * 复制完整的Polygon
     * @method Polygon
     * @returns {.mapApi.Polygon}
     */
    clone: function () {
        var polygon = new fastmap.mapApi.Polygon(null);
        return polygon;
    },
    /**
     * 获取多少为小数
     * @param num
     * @param sig
     * @returns {number}
     */
    limitSigDigs: function (num, sig) {
        var fig = 0;
        if (sig > 0) {
            fig = parseFloat(num.toPrecision(sig));
        }
        return fig;
    }
});
fastmap.mapApi.polygon = function (components, options) {
    return new fastmap.mapApi.Polygon(components, options);
};

/**
 * Created by liwanchong on 2015/9/8.
 * LinearRing对象
 * @namespace fast.mapApi
 * @class LinearRing
 */
fastmap.mapApi.LinearRing = fastmap.mapApi.LineString.extend({
    options: {},
    components: [],

    /**
     * 几何类型
     * type
     * @property type
     * @type String
     */
    type: 'LinearRing',

    /**
     * 构造函数
     * @class LinearRing
     * @constructor
     * @namespace fastmap.mapApi
     * @param {Array}components
     * @param {Object}options
     */
    initialize: function (components, options) {
        this.components = components;
        this.options = options;
    },
    /**
     *  在geometry中添加点
     *  @method addComponent
     * @param point
     * @param index
     * @returns {boolean}
     */
    addComponent: function (point, index) {
        var added = false;

        // remove last point
        var lastPoint = this.components.pop();

        // given an index, add the point
        // without an index only add non-duplicate points
        if (index != null || !point.equals(lastPoint)) {
            added = fastmap.mapApi.Collection.prototype.addComponent.apply(this,
                arguments);
        }

        // append copy of first point
        var firstPoint = this.components[0];
        fastmap.mapApi.Collection.prototype.addComponent.apply(this,
            [firstPoint]);

        return added;
    },
    /**
     * 删除geometry中的点
     * @method removeComponent
     * @param point
     * @returns {Array}
     */
    removeComponent: function (point) {
        var removed = this.components && (this.components.length > 3);
        if (removed) {
            // remove last point
            this.components.pop();

            // remove our point
            fastmap.mapApi.Collection.prototype.removeComponent.apply(this,
                arguments);
            // append copy of first point
            var firstPoint = this.components[0];
            fastmap.mapApi.Collection.prototype.addComponent.apply(this,
                [firstPoint]);
        }
        return removed;
    },
    /**
     * 根据x,y的值移动geometry
     * @method move
     * @param x
     * @param y
     */
    move: function (x, y) {
        for (var i = 0, len = this.components.length; i < len - 1; i++) {
            this.components[i].move(x, y);
        }
    },

    rotate: function (angle, origin) {
        for (var i = 0, len = this.components.length; i < len - 1; ++i) {
            this.components[i].rotate(angle, origin);
        }
    },
    /**
     * 调整geometry的大小
     * @method resize
     * @param scale
     * @param origin
     * @param ratio
     * @returns {fastmap.mapApi.LinearRing}
     */
    resize: function (scale, origin, ratio) {
        for (var i = 0, len = this.components.length; i < len - 1; ++i) {
            this.components[i].resize(scale, origin, ratio);
        }
        return this;
    },

    transform: function (source, dest) {
        if (source && dest) {
            for (var i = 0, len = this.components.length; i < len - 1; i++) {
                var component = this.components[i];
                component.transform(source, dest);
            }
            this.bounds = null;
        }
        return this;
    },

    /**
     * 获取中心点坐标
     * @method getCentroid
     */
    getCentroid: function () {
        var center = null;
        if (this.components) {
            var len = this.components.length;
            var i;
            var x;
            var y;
            if (len > 0 && len <= 2) {
                return this.components[0].clone();
            } else if (len > 2) {
                var sumX = 0.0;
                var sumY = 0.0;
                var x0 = this.components[0].x;
                var y0 = this.components[0].y;
                var area = -1 * this.getArea();
                if (area != 0) {
                    for (i = 0; i < len - 1; i++) {
                        var b = this.components[i];
                        var c = this.components[i + 1];
                        sumX += (b.x + c.x - 2 * x0) * ((b.x - x0) * (c.y - y0) - (c.x - x0) * (b.y - y0));
                        sumY += (b.y + c.y - 2 * y0) * ((b.x - x0) * (c.y - y0) - (c.x - x0) * (b.y - y0));
                    }
                    x = x0 + sumX / (6 * area);
                    y = y0 + sumY / (6 * area);
                } else {
                    for (i = 0; i < len - 1; i++) {
                        sumX += this.components[i].x;
                        sumY += this.components[i].y;
                    }
                    x = sumX / (len - 1);
                    y = sumY / (len - 1);
                }
                // return new OpenLayers.Geometry.Point(x, y);
                return new FM.Geometry.Point(x, y);
            }
            return center;
        }
        return center;
    },
    /**
     * geometry面积
     * @method getArea
     * @returns {number}
     */
    getArea: function () {
        var area = 0.0;
        if (this.components && (this.components.length > 2)) {
            var sum = 0.0;
            for (var i = 0, len = this.components.length; i < len - 1; i++) {
                var b = this.components[i];
                var c = this.components[i + 1];
                sum += (b.x + c.x) * (c.y - b.y);
            }
            area = -sum / 2.0;
        }
        return area;
    },
    /**
     * 获取geometry 周长
     * @method getGeodesicLength
     * @param projection
     * @returns {number}
     */
    getGeodesicLength: function (projection) {
        var length = 0.0;
        return length;
    },
    /**
     * 获取一份完整的LinearRing
     * @returns {fastmap.mapApi.LinearRing}
     */
    clone: function () {
        var linearRing = new fastmap.mapApi.LinearRing(null);
        return linearRing;
    },
    limitSigDigs: function (num, sig) {
        var fig = 0;
        if (sig > 0) {
            fig = parseFloat(num.toPrecision(sig));
        }
        return fig;
    },
    /**
     * 是否包含某点
     * @method containsPoint
     * @param point
     * @returns {boolean}
     */
    containsPoint: function (point) {
        var digs = 14;
        var px = this.limitSigDigs(point.x, digs);
        var py = this.limitSigDigs(point.y, digs);

        function getX(y, x1, y1, x2, y2) {
            return (y - y2) * ((x2 - x1) / (y2 - y1)) + x2;
        }

        var numSeg = this.components.length - 1;
        var start,
            end,
            x1,
            y1,
            x2,
            y2,
            cx,
            cy;
        var crosses = 0;
        for (var i = 0; i < numSeg; ++i) {
            start = this.components[i];
            x1 = this.limitSigDigs(start.x ? start.x : start[0], digs);
            y1 = this.limitSigDigs(start.y ? start.y : start[1], digs);
            end = this.components[i + 1];
            x2 = this.limitSigDigs(end.x ? end.x : end[0], digs);
            y2 = this.limitSigDigs(end.y ? end.y : end[1], digs);

            /**
             * The following conditions enforce five edge-crossing rules:
             *    1. points coincident with edges are considered contained;
             *    2. an upward edge includes its starting endpoint, and
             *    excludes its final endpoint;
             *    3. a downward edge excludes its starting endpoint, and
             *    includes its final endpoint;
             *    4. horizontal edges are excluded; and
             *    5. the edge-ray intersection point must be strictly right
             *    of the point P.
             */
            if (y1 == y2) {
                // horizontal edge
                if (py == y1) {
                    // point on horizontal line
                    if ((x1 <= x2 && (px >= x1 && px <= x2)) || // right or vert
                        (x1 >= x2 && (px <= x1 && px >= x2))) { // left or vert
                        // point on edge
                        crosses = -1;
                        break;
                    }
                }
                // ignore other horizontal edges
                continue;
            }
            cx = this.limitSigDigs(getX(py, x1, y1, x2, y2), digs);
            if (cx == px) {
                // point on line
                if ((y1 < y2 && (py >= y1 && py <= y2)) || // upward
                    (y1 > y2 && (py <= y1 && py >= y2))) { // downward
                    // point on edge
                    crosses = -1;
                    break;
                }
            }
            if (cx <= px) {
                // no crossing to the right
                continue;
            }
            if (x1 != x2 && (cx < Math.min(x1, x2) || cx > Math.max(x1, x2))) {
                // no crossing
                continue;
            }
            if ((y1 < y2 && (py >= y1 && py < y2)) || // upward
                (y1 > y2 && (py < y1 && py >= y2))) { // downward
                ++crosses;
            }
        }
        var contained = (crosses == -1) ?
            // on edge
            1 :
            // even (out) or odd (in)
            !!(crosses & 1);

        return contained;
    },
    /**
     * 相交
     * @method intersects
     * @param geometry
     * @returns {boolean}
     */
    intersects: function (geometry) {
        var intersect = false;
        if (geometry.CLASS_NAME == 'OpenLayers.Geometry.Point') {
            intersect = this.containsPoint(geometry);
        } else if (geometry.CLASS_NAME == 'OpenLayers.Geometry.LineString') {
            intersect = geometry.intersects(this);
        } else if (geometry.CLASS_NAME == 'OpenLayers.Geometry.LinearRing') {
            // intersect = OpenLayers.Geometry.LineString.prototype.intersects.apply(
            intersect = FM.Geometry.LineString.prototype.intersects.apply(
                this, [geometry]
            );
        } else {
            // check for component intersections
            for (var i = 0, len = geometry.components.length; i < len; ++i) {
                intersect = geometry.components[i].intersects(this);
                if (intersect) {
                    break;
                }
            }
        }
        return intersect;
    },
    /**
     * 是否获取geometry的坐标串
     * @method getVertices
     * @param nodes
     */
    getVertices: function (nodes) {
        return (nodes === true) ? [] : this.components.slice(0, this.components.length - 1);
    }
});
fastmap.mapApi.linearRing = function (coordiates, options) {
    return new fastmap.mapApi.LinearRing(coordiates, options);
};


/**
 * Created by wangtun on 2015/9/10.
 */
fastmap.mapApi.MultiPolygon = fastmap.mapApi.Collection.extend({
    options: {},
    /**
     * 几何类型
     * type
     * @property type
     * @type String
     */
    type: 'MultiPolygon',
    /**
     * 构造函数
     * @class MultiPolygon
     * @constructor
     * @namespace fastmap.mapApi
     * @param {Array}coordinates
     * @param {Object}options
     */
    initialize: function (coordinates, options) {
        this.coordinates = coordinates;
        this.options = options;
    },
    /**
     *添加polygon到MultiPolygon
     * @method appendPolygon
     * @param {Polygon}polygon
     */
    appendPolygon: function (polygon) {
    },
    /**
     * 复制一个完全的MultiPolygon
     * @method clone
     * @returns {.mapApi.MultiPolygon}
     */
    clone: function () {
        var polygons = new fastmap.mapApi.MultiPolygon(null);
        return polygons;
    },
    /**
     * 获取最近的点
     * @method closestPointXY
     * @param {Number}x
     * @param {Number}y
     * @param {Point}closestPoint
     * @param {Number}minSquaredDistance
     */
    closestPointXY: function (x, y, closestPoint, minSquaredDistance) {

    },
    /**
     * 是否包含x,y点
     * @method containsXY
     * @param {Number}x
     * @param {Number}y
     */
    containsXY: function (x, y) {

    },
    /**
     * 获取MultiPolygon的面积
     * @method getArea
     */
    getArea: function () {

    },
    /**
     * MultiPolygon坐标组
     * @method getCoordinates
     */
    getCoordinates: function () {

    },
    /**
     * 获取MultiPolygon内环
     * @param {Number}squaredTolerance
     * @returns {.mapApi.MultiPolygon}
     */
    getSimplifiedGeometryInternal: function (squaredTolerance) {
        var simplifiedMultiPolygonString = new fastmap.mapApi.MultiPolygon(null);
        return simplifiedMultiPolygonString;
    },
    /**
     * 获取MultiPolygon中的polygon
     * @method getPolygon
     * @param {Number}index
     * @returns {L.Polygon}
     */
    getPolygon: function (index) {
        var polygon = new fastmap.mapApi.Polygon(null);
        return polygon;
    },
    /**
     * 获取MultiPolygon中的polygons
     * @method getPolygons
     * @returns {Array}
     */
    getPolygons: function () {
        var polygons = [];
        return polygons;
    },
    /**
     *相交
     * @method intersectsExtend
     * @param {Object}extend
     */
    intersectsExtent: function (extend) {

    }
});
fastmap.mapApi.multiPolygon = function (coordiates, options) {
    return new fastmap.mapApi.MultiPolygon(coordiates, options);
};

/**
 * Created by wangtun on 2015/9/10.
 * MultiPolyline对象
 * @namespace fast.mapApi
 * @class MultiPolyline
 */
fastmap.mapApi.MultiPolyline = fastmap.mapApi.Collection.extend({
    /**
     * 几何类型
     * type
     * @property type
     * @type String
     */
    type: 'MultiPolyline',
    /**
     * 构造函数
     * @class MultiPolyline
     * @constructor
     * @namespace fastmap.mapApi
     * @param {Array}coordinates
     * @param {Object}options
     * @param {Object}activeCoordinates 除coordinates外，附加link高亮
     * @param {Object}activeOptions 附加信息的样式
     */
    initialize: function (coordinates, options, activeCoordinates, activeOptions) {
        this.coordinates = coordinates;
        this.activeCoordinates = activeCoordinates || []; // 除了coordinates高亮外activeCoordinates高亮另一个颜色
        this.options = options;
        this.activeOptions = activeOptions;
    },
    /**
     * 在MultiPolylineZ中怎加lineString
     * @method appendLineString
     * @param {LineString}lineString
     */
    appendLineString: function (lineString) {

    },
    /**
     * 获取一份完整的MultiPolyline
     * @method clone
     * @returns {L.MultiPolyline}
     */
    clone: function () {
        var lineStrings = new fastmap.mapApi.MultiPolyline(null);
        return lineStrings;
    },

    /**
     * 切分几何.
     * @method splitWith
     * @return {Array} 几何对象集合
     */
    split: function (geometry, options) {
        var results = null;
        var mutual = options && options.mutual;
        var splits,
            sourceLine,
            sourceLines,
            sourceSplit,
            targetSplit;
        var sourceParts = [];
        var targetParts = [geometry];
        for (var i = 0, len = this.components.length; i < len; ++i) {
            sourceLine = this.components[i];
            sourceSplit = false;
            for (var j = 0; j < targetParts.length; ++j) {
                splits = sourceLine.split(targetParts[j], options);
                if (splits) {
                    if (mutual) {
                        sourceLines = splits[0];
                        for (var k = 0, klen = sourceLines.length; k < klen; ++k) {
                            if (k === 0 && sourceParts.length) {
                                sourceParts[sourceParts.length - 1].addComponent(
                                    sourceLines[k]
                                );
                            } else {
                                sourceParts.push(
                                    new fastmap.mapApi.MultiPolyline([
                                        sourceLines[k]
                                    ])
                                );
                            }
                        }
                        sourceSplit = true;
                        splits = splits[1];
                    }
                    if (splits.length) {
                        // splice in new target parts
                        splits.unshift(j, 1);
                        Array.prototype.splice.apply(targetParts, splits);
                        break;
                    }
                }
            }
            if (!sourceSplit) {
                // source line was not hit
                if (sourceParts.length) {
                    // add line to existing multi
                    sourceParts[sourceParts.length - 1].addComponent(
                        sourceLine.clone()
                    );
                } else {
                    // create a fresh multi
                    sourceParts = [
                        new fastmap.mapApi.MultiPolyline(
                            sourceLine.clone()
                        )
                    ];
                }
            }
        }
        if (sourceParts && sourceParts.length > 1) {
            sourceSplit = true;
        } else {
            sourceParts = [];
        }
        if (targetParts && targetParts.length > 1) {
            targetSplit = true;
        } else {
            targetParts = [];
        }
        if (sourceSplit || targetSplit) {
            if (mutual) {
                results = [sourceParts, targetParts];
            } else {
                results = targetParts;
            }
        }
        return results;
    },

    /**
     * 切分几何.
     * @method splitWith
     * @return {Array} 几何对象集合
     */
    splitWith: function (geometry, options) {
        var results = null;
        var mutual = options && options.mutual;
        var splits,
            targetLine,
            sourceLines,
            sourceSplit,
            targetSplit,
            sourceParts,
            targetParts;
        if (geometry instanceof fastmap.mapApi.LineString) {
            targetParts = [];
            sourceParts = [geometry];
            for (var i = 0, len = this.components.length; i < len; ++i) {
                targetSplit = false;
                targetLine = this.components[i];
                for (var j = 0; j < sourceParts.length; ++j) {
                    splits = sourceParts[j].split(targetLine, options);
                    if (splits) {
                        if (mutual) {
                            sourceLines = splits[0];
                            if (sourceLines.length) {
                                // splice in new source parts
                                sourceLines.unshift(j, 1);
                                Array.prototype.splice.apply(sourceParts, sourceLines);
                                j += sourceLines.length - 2;
                            }
                            splits = splits[1];
                            if (splits.length === 0) {
                                splits = [targetLine.clone()];
                            }
                        }
                        for (var k = 0, klen = splits.length; k < klen; ++k) {
                            if (k === 0 && targetParts.length) {
                                targetParts[targetParts.length - 1].addComponent(
                                    splits[k]
                                );
                            } else {
                                targetParts.push(
                                    new fastmap.mapApi.MultiPolyline([
                                        splits[k]
                                    ])
                                );
                            }
                        }
                        targetSplit = true;
                    }
                }
                if (!targetSplit) {
                    // target component was not hit
                    if (targetParts.length) {
                        // add it to any existing multi-line
                        targetParts[targetParts.length - 1].addComponent(
                            targetLine.clone()
                        );
                    } else {
                        // or start with a fresh multi-line
                        targetParts = [
                            new fastmap.mapApi.MultiPolyline([
                                targetLine.clone()
                            ])
                        ];
                    }
                }
            }
        } else {
            results = geometry.split(this);
        }
        if (sourceParts && sourceParts.length > 1) {
            sourceSplit = true;
        } else {
            sourceParts = [];
        }
        if (targetParts && targetParts.length > 1) {
            targetSplit = true;
        } else {
            targetParts = [];
        }
        if (sourceSplit || targetSplit) {
            if (mutual) {
                results = [sourceParts, targetParts];
            } else {
                results = targetParts;
            }
        }
        return results;
    },

    /**
     * 获取坐标数组
     * @method getCoordinates
     */
    getCoordinates: function () {

    },
    /**
     * 获得MultiPolyline中的单个lineString
     * @method getLineString
     * @param {Number}index
     * @returns {fastmap.mapApi.LineString}
     */
    getLineString: function (index) {
        var lineString = new fastmap.mapApi.LineString(null);
        return lineString;
    },
    /**
     * 获得MultiPolyline中的全部lineString
     * @method getLineStrings
     * @returns {Array}
     */
    getLineStrings: function () {
        var lineStrings = [];
        return lineStrings;
    },
    /**
     * set lineStrings
     * @method setLineString
     * @param {Array}lineStrings
     */
    setLineStrings: function (lineStrings) {

    },
    /**
     * 获取最近的点
     * @method closestPointXY
     */
    closestPointXY: function () {

    },
    /**
     * 是否相交
     * @method intersectsExtend
     * @param {object}extend
     */
    intersectsExtent: function (extend) {

    },
    /**
     * 获取MultiPolyline内环
     * @param {Number}squaredTolerance
     * @returns {L.MultiPolyline}
     */
    getSimplifiedGeometryInternal: function (squaredTolerance) {
        var simplifiedFlatCoordinates = [];
        var simplifiedMultiLineString = new fastmap.mapApi.MultiPolyline(null);
        return simplifiedMultiLineString;
    }
});
fastmap.mapApi.multiPolyline = function (coordiates, options, activeCoordinates, activeOptions) {
    return new fastmap.mapApi.MultiPolyline(coordiates, options, activeCoordinates, activeOptions);
};

/**
 * Created by xujie on 2016/11/32
 * 处理geojson格式几何计算
 */
fastmap.mapApi.geometry.GeometryAlgorithm = L.Class.extend({
    initialize: function (options) {
        this.reader = new jsts.io.GeoJSONReader();
        this.writer = new jsts.io.GeoJSONWriter();
        this.wktReader = new jsts.io.WKTReader();
        this.wktWriter = new jsts.io.WKTWriter();
        this.factory = new jsts.geom.GeometryFactory();
        this.geometryTransform = FM.mapApi.GeometryTransform.getInstance();
        this.proj4Transform = FM.mapApi.Proj4Transform.getInstance();
    },

    distance: function (geometry1, geometry2) {
        var jstsGeometry1 = this.reader.read(geometry1);
        var jstsGeometry2 = this.reader.read(geometry2);
        return jstsGeometry1.distance(jstsGeometry2);
    },

    /**
     * 计算两个点之间的球面距离,单位为米
     * @param point1 geosjson格式的经纬点
     * @param point2 geosjson格式的经纬点
     * @returns {number}
     */
    sphericalDistance: function (point1, point2) {
        var self = this;
        this.geometryTransform.setEnviroment(null, null, function (map, tile, coordinates) {
            return self.proj4Transform.wgs84ToXian80(coordinates);
        });
        var p1 = this.geometryTransform.convertGeometry(point1);
        var p2 = this.geometryTransform.convertGeometry(point2);
        return this.distance(p1, p2);
    },

    nearestPoints: function (geometry1, geometry2) {
        var jstsGeometry1 = this.reader.read(geometry1);
        var jstsGeometry2 = this.reader.read(geometry2);
        var pair = jsts.operation.distance.DistanceOp.nearestPoints(jstsGeometry1, jstsGeometry2);
        var res = {
            distance: pair[0].distance(pair[1]),
            point1: this.writer.write(this.factory.createPoint(pair[0])),
            point2: this.writer.write(this.factory.createPoint(pair[1]))
        };
        return res;
    },

    contains: function (geometry1, geometry2) {
        var jstsGeometry1 = this.reader.read(geometry1);
        var jstsGeometry2 = this.reader.read(geometry2);
        return jstsGeometry1.contains(jstsGeometry2);
    },

    /* 判断两个几何是否相交
     return: boolen
     */
    intersects: function (geometry1, geometry2) {
        var jstsGeometry1 = this.reader.read(geometry1);
        var jstsGeometry2 = this.reader.read(geometry2);
        return jstsGeometry1.intersects(jstsGeometry2);
    },

    /* 计算两个几何的交集
     return: geoJson
     */
    intersection: function (geometry1, geometry2) {
        var jstsGeometry1 = this.reader.read(geometry1);
        var jstsGeometry2 = this.reader.read(geometry2);
        return this.writer.write(jstsGeometry1.intersection(jstsGeometry2));
    },

    isWithinDistance: function (geometry1, geometry2, distance) {
        var jstsGeometry1 = this.reader.read(geometry1);
        var jstsGeometry2 = this.reader.read(geometry2);
        return jstsGeometry1.isWithinDistance(jstsGeometry2, distance);
    },

    intersectsAndContains: function (geometry1, geometry2) {
        var jstsGeometry1 = this.reader.read(geometry1);
        var jstsGeometry2 = this.reader.read(geometry2);
        // 采用三元表达式,尽量减少计算相交的次数
        return jstsGeometry1.contains(jstsGeometry2) ? true : jstsGeometry1.intersects(jstsGeometry2);
    },

    bbox: function (geometry) {
        var jstsGeometry = this.reader.read(geometry);
        var envelope = jstsGeometry.getEnvelopeInternal();
        var bbox = {
            minX: envelope.getMinX(),
            minY: envelope.getMinY(),
            maxX: envelope.getMaxX(),
            maxY: envelope.getMaxY()
        };
        return bbox;
    },

    bboxToPolygon: function (bbox) {
        var geojson = {
            type: 'Polygon',
            coordinates: [
                [
                    [bbox.minX, bbox.minY],
                    [bbox.maxX, bbox.minY],
                    [bbox.maxX, bbox.maxY],
                    [bbox.minX, bbox.maxY],
                    [bbox.minX, bbox.minY]
                ]
            ]
        };
        return geojson;
    },

    centroid: function (geometry) {
        var jstsGeometry = this.reader.read(geometry);
        var coordinate = jstsGeometry.getCentroid().getCoordinate();
        var point = {
            type: 'Point',
            coordinates: [coordinate.x, coordinate.y]
        };
        return point;
    },

    buffer: function (geometry, distance) {
        var jstsGeometry = this.reader.read(geometry);
        var parameters = new jsts.operation.buffer.BufferParameters();
        parameters.setEndCapStyle(jsts.operation.buffer.BufferParameters.CAP_ROUND);
        parameters.setJoinStyle(jsts.operation.buffer.BufferParameters.JOIN_ROUND);
        // parameters.setSingleSided(true);
        var bufferOp = new jsts.operation.buffer.BufferOp(jstsGeometry, parameters);
        var buffer = bufferOp.getResultGeometry(distance);
        return this.writer.write(buffer);
    },

    convexHull: function (geometry) {
        var jstsGeometry = this.reader.read(geometry);
        var convexHull = jstsGeometry.convexHull();
        return this.writer.write(convexHull);
    },

    nearestLocations: function (point, lineString) {
        var jstsPoint = this.reader.read(point);
        var jstsLineString = this.reader.read(lineString);
        var distanceOp = new jsts.operation.distance.DistanceOp(jstsPoint, jstsLineString);
        var pair = distanceOp.nearestLocations();
        var p0 = this.factory.createPoint(pair[0].getCoordinate());
        var p1 = this.factory.createPoint(pair[1].getCoordinate());
        var segmentIndex = pair[1].getSegmentIndex();
        var res = {
            distance: p0.distance(p1),
            point: this.writer.write(p1),
            previousIndex: segmentIndex,
            nextIndex: segmentIndex + 1,
            previousPoint: this.writer.write(jstsLineString.getPointN(segmentIndex)),
            nextPoint: this.writer.write(jstsLineString.getPointN(segmentIndex + 1))
        };
        return res;
    },

    wktToGeojson: function (wkt) {
        try {
            var jstsGeometry = this.wktReader.read(wkt);
            return this.writer.write(jstsGeometry);
        } catch (e) {
            return null;
        }
    },

    geoJsonToWkt: function (geojson) {
        try {
            var jstsGeometry = this.reader.read(geojson);
            return this.wktWriter.write(jstsGeometry);
        } catch (e) {
            return null;
        }
    },

    // 将经纬度坐标转换成大地坐标后，计算长度，计算出来的长度单位为米
    getLength: function (geometry) {
        var self = this;
        var func = function (map, tile, coordinates) {
            return self.proj4Transform.wgs84ToXian80(coordinates);
        };
        this.geometryTransform.setEnviroment(null, null, func);
        var g = this.geometryTransform.convertGeometry(geometry);

        var jstsGeometry = this.reader.read(g);
        return jstsGeometry.getLength();
    },

    /**
     * 计算LineString长度,单位为米
     * @param lineString geosjson格式的经纬线
     * @returns {number}
     */
    sphericalLength: function (lineString) {
        if (lineString.coordinates.length < 2) {
            return 0;
        }

        var self = this;
        this.geometryTransform.setEnviroment(null, null, function (map, tile, coordinates) {
            return self.proj4Transform.wgs84ToXian80(coordinates);
        });
        var g = this.geometryTransform.convertGeometry(lineString);

        var jstsGeometry = this.reader.read(g);
        return jstsGeometry.getLength();
    },

    isClosed: function (lineString) {
        var length = lineString.coordinates.length;
        if (length < 3) {
            return false;
        }
        var jstsGeometry = this.reader.read(lineString);
        return jstsGeometry.isClosed();
    },

    close: function (lineString) {
        var length = lineString.coordinates.length;
        if (length < 3) {
            throw new Error('LineString至少拥有三个坐标点才能闭合!');
        }
        lineString.coordinates[length] = lineString.coordinates[0];
    },

    /**
     * 计算给定角度之间的弧几何
     * @param x 圆心x
     * @param y 圆心y
     * @param radius 半径
     * @param startAngle 起始角度,单位度
     * @param endAngle 终止角度,单位度
     * @param distance 形状点之间距离
     * @returns {{type: string, coordinates: Array}}
     */
    arc: function (x, y, radius, startAngle, endAngle, distance) {
        if (endAngle < startAngle) {
            throw new Error('endAngle必须大于startAngle');
        }
        var perimeter = 2 * Math.PI * radius;
        var count = Math.floor(perimeter / distance);
        var remainderLength = perimeter % distance;
        var remainderAngle = 180 * remainderLength / (Math.PI * radius);
        var angleStep = (360 - remainderAngle) / count;

        var vector = new fastmap.mapApi.symbol.Vector(0, -1);
        vector = vector.multiNumber(radius);
        var matrix = new fastmap.mapApi.symbol.Matrix();
        var point = new fastmap.mapApi.symbol.Point(x, y);
        var geometry = {
            type: 'LineString',
            coordinates: []
        };

        var tmpVector = null;
        var tmpPoint = null;
        var tmpMatrix = null;
        for (var i = startAngle; i < endAngle;) {
            tmpMatrix = matrix.makeRotate(i);
            tmpVector = vector.crossMatrix(tmpMatrix);
            tmpPoint = point.plusVector(tmpVector);
            geometry.coordinates.push([tmpPoint.x, tmpPoint.y]);
            i += angleStep;
        }
        tmpMatrix = matrix.makeRotate(endAngle);
        tmpVector = vector.crossMatrix(tmpMatrix);
        tmpPoint = point.plusVector(tmpVector);
        geometry.coordinates.push([tmpPoint.x, tmpPoint.y]);

        return geometry;
    },

    equals: function (geometry1, geometry2) {
        var jstsGeometry1 = this.reader.read(geometry1);
        var jstsGeometry2 = this.reader.read(geometry2);
        return jstsGeometry1.equals(jstsGeometry2);
    },

    /**
     * 计算球面多边形投影之后的面积,单位为平米
     * @param polygon polygon格式的经纬点
     * @returns {number}
     */
    sphericalArea: function (polygon) {
        if (polygon.coordinates.length === 0) {
            return 0;
        }
        if (polygon.coordinates[0].length < 3) {
            return 0;
        }

        var self = this;
        this.geometryTransform.setEnviroment(null, null, function (map, tile, coordinates) {
            return self.proj4Transform.wgs84ToXian80(coordinates);
        });

        var g = this.geometryTransform.convertGeometry(polygon);

        var jstsGeometry1 = this.reader.read(g);
        return jstsGeometry1.getArea();
    },

    isSimple: function (geometry) {
        var jstsGeometry = this.reader.read(geometry);
        return jstsGeometry.isSimple();
    },

    isValidGeometry: function (geometry) {
        try {
            var jstsGeometry = this.reader.read(geometry);
            return true;
        } catch (err) {
            // FM.Util.log(err);
            return false;
        }
    },

    getGeometriesByType: function (geometry, targetType) {
        if (!geometry) {
            return [];
        }
        var type = geometry.type;
        var geometries = [];
        switch (type) {
            case 'MultiPoint':
            case 'MultiLineString':
            case 'MultiPolygon':
                geometries = this.multiGeometryToArray(geometry);
                break;
            case 'GeometryCollection':
                for (var i = 0; i < geometry.geometries.length; ++i) {
                    var subGeometry = geometry.geometries[i];
                    geometries = geometries.concat(this.getGeometriesByType(subGeometry, targetType));
                }
                break;
            default:
                if (type === targetType) {
                    geometries.push(geometry);
                }
        }
        return geometries;
    },

    multiGeometryToArray: function (multiGeometry) {
        var geometries = [];
        var type = multiGeometry.type;
        for (var i = 0; i < multiGeometry.coordinates.length; ++i) {
            var geometry = {
                type: type.substr(5),
                coordinates: multiGeometry.coordinates[i]
            };
            geometries.push(geometry);
        }
        return geometries;
    },

    precision: function (value, num) {
        var factor = Math.pow(10, num);
        var value1 = value * factor;
        value1 += 0.5;
        value1 = Math.floor(value1);
        value1 /= factor;
        return value1;
    },

    precisionGeometry: function (geometry, num) {
        var self = this;
        this.geometryTransform.setEnviroment(null, null, function (map, tile, coordinates) {
            var x = self.precision(coordinates[0], num);
            var y = self.precision(coordinates[1], num);
            return [x, y];
        });

        var g = this.geometryTransform.convertGeometry(geometry);
        return g;
    },

    destroy: function () {
        fastmap.mapApi.geometry.GeometryAlgorithm.instance = null;
    },

    statics: {
        instance: null,

        getInstance: function () {
            if (!fastmap.mapApi.geometry.GeometryAlgorithm.instance) {
                fastmap.mapApi.geometry.GeometryAlgorithm.instance =
                    new fastmap.mapApi.geometry.GeometryAlgorithm();
            }
            return fastmap.mapApi.geometry.GeometryAlgorithm.instance;
        }
    }
});

/**
 * Created by xujie on 2016/5/11 0011.
 */
fastmap.mapApi.Feedback = L.Class.extend({
    initialize: function () {
        this.geometryFactory = fastmap.mapApi.symbol.GeometryFactory.getInstance();
        this.priority = 0;
        this.drawItems = [];
    },

    add: function (geojson, symbol) {
        if (!geojson || !symbol) {
            return;
        }
        var geometry = this.geometryFactory.fromGeojson(geojson);
        var item = {
            geometry: geometry,
            symbol: symbol,
            type: 'geometry'
        };
        this.drawItems.push(item);
    },

    addPid: function (pid, featureType, symbol) {
        if (pid && featureType && symbol) {
            this.drawItems.push({
                pid: pid,
                featureType: featureType,
                symbol: symbol,
                type: 'pid'
            });
        }
    },

    del: function (index) {
        this.drawItems.splice(index, 1);
    },

    clear: function () {
        this.drawItems = [];
    },

    getDrawItems: function () {
        return this.drawItems;
    },

    setDrawItems: function (items) {
        if (FM.Util.isObject(items)) {
            this.drawItems.push(items);
        } else if (FM.Util.isArray(items)) {
            Array.prototype.push.apply(this.drawItems, items);
        }
    }
});

/**
 * Created by xujie on 2016/5/11 0011.
 */
fastmap.mapApi.FeedbackController = L.Class.extend({

    initialize: function () {
        this.eventController = fastmap.uikit.EventController();
        this.feedbacks = [];
    },

    add: function (feedback) {
        var existFeedback = this.feedbacks.find(function (element, index, array) {
            return element === feedback;
        });

        if (existFeedback) {
            return;
        }

        this.feedbacks.push(feedback);

        this.feedbacks.sort(function (a, b) {
            return a.priority - b.priority;
        });
    },

    del: function (feedback) {
        var existFeedback = this.feedbacks.find(function (element, index, array) {
            return element === feedback;
        });

        if (!existFeedback) {
            return;
        }

        this.feedbacks = this.feedbacks.filter(function (element, index, array) {
            return element !== feedback;
        });
    },

    clear: function () {
        this.feedbacks = [];
    },

    refresh: function () {
        var drawItems = [];
        this.feedbacks.forEach(function (element, index, array) {
            drawItems = drawItems.concat(element.getDrawItems());
        });

        this.eventController.fire(L.Mixin.EventTypes.FEEDBACKREFRESH, { drawItems: drawItems });
    },

    destroy: function () {
        fastmap.mapApi.FeedbackController.instance = null;
    },

    statics: {
        instance: null,

        getInstance: function () {
            if (!fastmap.mapApi.FeedbackController.instance) {
                fastmap.mapApi.FeedbackController.instance =
                    new fastmap.mapApi.FeedbackController();
            }
            return fastmap.mapApi.FeedbackController.instance;
        }
    }
});

/**
 * Bounds类
 * 用于表示包围框
 *
 * @namespace mapApi
 * @class Bounds
 */
fastmap.mapApi.Bounds = L.Class.extend({
    /**
     * @method initialize
     * 初始化构造函数
     *
     * @param {Number} left
     * @param {Number} bottom
     * @param {Number} right
     * @param {Number} top
     *
     * @return {fastmap.mapApi.Bounds} 返回拷贝对象
     */
    initialize: function (left, bottom, right, top) {
        if (left) {
            this.left = parseFloat(left);
        }
        if (bottom) {
            this.bottom = parseFloat(bottom);
        }
        if (right) {
            this.right = parseFloat(right);
        }
        if (top) {
            this.top = parseFloat(top);
        }
    },
    /**
     * @method clone
     * 深度拷贝当前bounds对象
     *
     * @return {fastmap.mapApi.Bounds} 返回拷贝对象
     */
    clone: function () {
        return new fastmap.mapApi.Bounds(this.left, this.bottom, this.right, this.top);
    },
    /**
     * @method equals
     * 判断两个bounds是否相等
     *
     * @param {fastmap.mapApi.Bounds} 用于比较的bounds
     * @return {Boolean} 如果两个bounds的上下左右相等，则两个bounds相等，否则不相等
     */
    equals: function (bounds) {
        var equals = false;
        if (bounds != null) {
            equals = ((this.left === bounds.left) && (this.right === bounds.right)
            && (this.top === bounds.top) && (this.bottom === bounds.bottom));
        }
        return equals;
    }
});
fastmap.mapApi.bounds = function (options) {
    return new fastmap.mapApi.Bounds(options);
};

/**
 * Created by xujie on 2017/01/11
 * Recreated by chenx on 2017-5-12
 * 地图
 */
FM.mapApi.Map = L.Class.extend({
    options: {
        tileSize: 256,
        container: 'editorMap',
        center: [0, 0],
        zoom: 0
    },

    initialize: function (options) {
        FM.setOptions(this, options);

        this._tiles = [];
        this._leafletMap = null;

        this._sourceController = fastmap.mapApi.source.SourceController.getInstance();
        this._tileRequestController = fastmap.mapApi.TileRequestController.getInstance();

        this._activeLeafletVectorLayer = null;
        // 记录要素数据对应的scenelayer
        this._featureLayers = [];

        this._initLeafletMap();
    },

    _initLeafletMap: function () {
        this._leafletMap = this._createLeafletMap();
        this._bindLeafletMapEvent();
    },

    _createLeafletMap: function () {
        var leafletMap = L.map(this.options.container, {
            dragging: false,
            touchZoom: false,
            doubleClickZoom: false,
            scrollWheelZoom: false,
            boxZoom: false,
            keyboard: false,
            tap: false,
            attributionControl: false,
            zoomControl: false,
            center: this.options.center,
            zoom: this.options.zoom
        });
        return leafletMap;
    },

    _bindLeafletMapEvent: function () {
        this._leafletMap.on('moveend', this._onMapMoveEnd, this);
        this._leafletMap.on('resize', this._onMapMoveEnd, this);
    },

    getLeafletMap: function () {
        return this._leafletMap;
    },

    setZoom: function (zoom) {
        return this._leafletMap.setZoom(zoom);
    },

    getZoom: function () {
        return this._leafletMap.getZoom();
    },

    _getVectorLayers: function () {
        var layers = [];
        this._leafletMap.eachLayer(function (item) {
            if (item instanceof FM.mapApi.VectorLayer) {
                layers.push(item);
            }
        });

        return layers;
    },

    _clearVectorLayers: function () {
        var layers = [];
        this._leafletMap.eachLayer(function (item) {
            if (item instanceof FM.mapApi.VectorLayer) {
                item.clear();
            }
        });

        return layers;
    },

    _redrawNonVectorLayers: function () {
        this._leafletMap.eachLayer(function (item) {
            if (!(item instanceof FM.mapApi.VectorLayer) && item.redraw) {
                item.redraw();
            }
        });
    },

    _getFeatureLayers: function () {
        var layers = [];
        this._leafletMap.eachLayer(function (item) {
            if (item instanceof FM.mapApi.VectorLayer) {
                var visibleLayers = item.getSceneLayers().filter(function (layer) {
                    return layer.visible();
                });
                Array.prototype.push.apply(layers, visibleLayers);
            }
        });

        return layers;
    },

    // 重绘地图，删除全部数据，重新请求
    redraw: function (layers) {
        this._redrawNonVectorLayers();

        this._clearVectorLayers();

        if (layers && layers.length > 0) {
            var redLayers = [];
            for (var i = 0; i < layers.length; i++) {
                this._delLayerData(layers[i]);
                redLayers.push(layers[i].getLeafletLayer());
            }

            this._requestAndDrawTiles(this._tiles, layers);

            var vectorLayer = this._getVectorLayers();
            var greenLayers = FM.Util.difference(vectorLayer, redLayers);
            this._redrawTiles(this._tiles, greenLayers);
        } else {
            this._delTilesData(this._tiles);

            this._requestAndDrawTiles(this._tiles, this._featureLayers);
        }
    },

    // 刷新地图，对地图图层执行了新增、删除操作后，必须执行此方法
    refresh: function () {
        // this._tileRequestController.clear();
        var i;
        var vectorLayer = this._getVectorLayers();
        var featureLayers = this._getFeatureLayers();

        var addLayers = FM.Util.differenceBy(featureLayers, this._featureLayers, 'id');
        var delLayers = FM.Util.differenceBy(this._featureLayers, featureLayers, 'id');
        var remLayers = FM.Util.intersectionBy(featureLayers, this._featureLayers, 'id');

        this._clearVectorLayers();

        delLayers = delLayers.filter(function (item) {
            for (var k = 0; k < remLayers.length; k++) {
                if (item.useSameData(remLayers[k])) {
                    return false;
                }
            }
            return true;
        });

        var redLayers = [];
        for (i = 0; i < addLayers.length; i++) {
            redLayers.push(addLayers[i].getLeafletLayer());
        }
        this._requestAndDrawTiles(this._tiles, addLayers);

        var greenLayers = FM.Util.difference(vectorLayer, redLayers);
        this._redrawTiles(this._tiles, greenLayers);

        this._featureLayers = featureLayers;
    },

    // 局部瓦片刷新，处理地图移动和缩放事件
    _onMapMoveEnd: function () {
        var tiles = this._getTiles();
        var addTiles = FM.Util.differenceBy(tiles, this._tiles, 'name');
        var delTiles = FM.Util.differenceBy(this._tiles, tiles, 'name');
        var remTiles = FM.Util.intersectionBy(tiles, this._tiles, 'name');

        this._clearVectorLayers();

        this._delTilesData(delTiles);

        var layers = this._getVectorLayers();

        this._requestAndDrawTiles(addTiles, this._featureLayers);

        this._redrawTiles(remTiles, layers);

        this._tiles = tiles;
    },

    _getTiles: function () {
        var map = this._leafletMap;
        var bounds = map.getPixelBounds();
        var zoom = map.getZoom();
        var tileSize = this.options.tileSize;

        var tileBounds = L.bounds(
            bounds.min.divideBy(tileSize)._floor(),
            bounds.max.divideBy(tileSize)._floor());

        var queue = [];
        var center = tileBounds.getCenter();

        for (var j = tileBounds.min.y; j <= tileBounds.max.y; j++) {
            for (var i = tileBounds.min.x; i <= tileBounds.max.x; i++) {
                var point = new L.Point(i, j);
                queue.push(point);
            }
        }

        // load tiles in order of their distance to center
        queue.sort(function (a, b) {
            return a.distanceTo(center) - b.distanceTo(center);
        });

        var tiles = [];
        for (i = 0; i < queue.length; ++i) {
            var x = queue[i].x;
            var y = queue[i].y;
            var tile = this._createTile(x, y, zoom);
            tiles.push(tile);
        }

        return tiles;
    },

    _createTile: function (x, y, z) {
        var tile = {
            name: x + ':' + y,
            fullName: x + ':' + y + ':' + z,
            x: x,
            y: y,
            z: z,
            size: this.options.tileSize
        };
        return tile;
    },

    _requestAndDrawTiles: function (tiles, layers) {
        if (tiles.length === 0 || layers.length === 0) {
            return;
        }

        this._leafletMap.fire('TileLayersLoading', {
            layers: layers,
            tiles: tiles
        });

        var self = this;
        var vectorLayers = [];
        var i,
            temp;
        for (i = 0; i < layers.length; i++) {
            temp = layers[i].getLeafletLayer();
            if (vectorLayers.indexOf(temp) < 0) {
                vectorLayers.push(temp);
            }
        }

        var innerFunc = function (tile, index) {
            return self._requestTileData(tile, index, layers)
                .then(function () {
                    self._redrawTile(tile, vectorLayers);
                });
        };

        var promises = [];
        for (i = 0; i < tiles.length; ++i) {
            promises.push(innerFunc(tiles[i], i));
        }

        Promise.all(promises).then(function () {
            self._leafletMap.fire('TileLayersLoaded', {
                layers: layers,
                tiles: tiles
            });
        });
    },

    _redrawTiles: function (tiles, vectorLayers) {
        if (tiles.length === 0 || vectorLayers.length === 0) {
            return;
        }

        var tile;
        for (var i = 0; i < tiles.length; ++i) {
            tile = tiles[i];
            this._redrawTile(tile, vectorLayers);
        }
    },

    _redrawTile: function (tile, vectorLayers) {
        for (var i = 0; i < vectorLayers.length; ++i) {
            vectorLayers[i].draw(tile);
        }
    },

    _requestTileData: function (tile, tileIndex, layers) {
        var urlObject = this._createUrlObject(tile, layers);
        return this._sourceController.requestTileData(tile, tileIndex, urlObject);
    },

    _createUrlObject: function (tile, layers) {
        var zoom = this._leafletMap.getZoom();
        var urls = {};
        var layer,
            options,
            sourceName,
            featureType;
        for (var i = 0; i < layers.length; ++i) {
            if (!layers[i].canDraw(zoom)) {
                continue;
            }
            options = layers[i].getOptions();
            sourceName = options.source;
            featureType = options.serverFeatureType;
            if (!featureType) {
                featureType = options.featureType;
            }

            if (!urls.hasOwnProperty(sourceName)) {
                urls[sourceName] = [];
            }
            urls[sourceName].push(featureType);
        }
        return urls;
    },

    _onRequestTileDataError: function (e) {
        throw new Error(e);
    },

    _delTilesData: function (tiles) {
        for (var i = 0; i < tiles.length; ++i) {
            var tile = tiles[i];
            this._delTileData(tile);
        }
    },

    _delTileData: function (tile) {
        this._tileRequestController.del(tile.fullName);
        var sources = this._sourceController.getAllSources();
        for (var i = 0; i < sources.length; ++i) {
            var source = sources[i];
            source.delByTile(tile.fullName);
        }
    },

    _delLayerData: function (sceneLayer) {
        var sources = this._sourceController.getSource(sceneLayer.getSourceName());
        var featureType = sceneLayer.getFeatureType();
        for (var i = 0; i < this._tiles.length; i++) {
            sources.delByType(featureType, this._tiles[i].fullName);
        }
    },

    _createWmsLayer: function (sceneLayer) {
        var opts = this._getLeafletLayerOption(sceneLayer);

        return L.tileLayer.customwms(opts.source, opts);
    },

    _createRasterLayer: function (sceneLayer) {
        var opts = this._getLeafletLayerOption(sceneLayer);

        return L.tileLayer(opts.source, opts);
    },

    _createVectorLayer: function () {
        return FM.mapApi.vectorLayer();
    },

    _createGridLayer: function (sceneLayer) {
        var opts = this._getLeafletLayerOption(sceneLayer);

        return FM.mapApi.gridLayer(opts);
    },

    _createMeshLayer: function (sceneLayer) {
        var opts = this._getLeafletLayerOption(sceneLayer);

        return FM.mapApi.meshLayer(opts);
    },

    _createTileBoundsLayer: function (sceneLayer) {
        var opts = this._getLeafletLayerOption(sceneLayer);
        opts.tileSize = opts.tileSize || 256;

        return FM.mapApi.tileBoundsLayer(opts);
    },

    _createFeedbackLayer: function (sceneLayer) {
        var opts = this._getLeafletLayerOption(sceneLayer);

        return FM.mapApi.feedbackLayer(opts);
    },

    _createOverlayLayer: function (sceneLayer) {
        var opts = this._getLeafletLayerOption(sceneLayer);

        return FM.mapApi.overlayLayer(opts);
    },

    _getLeafletLayerOption: function (sceneLayer) {
        var opts = {
            id: sceneLayer.id,
            name: sceneLayer.name
        };
        FM.extend(opts, sceneLayer.options);

        return opts;
    },

    addLayer: function (sceneLayer) {
        var leafletLayer;
        var vectFlag = false;
        var temp;
        switch (sceneLayer.type) {
            case 'wms':
                leafletLayer = this._createWmsLayer(sceneLayer);
                break;
            case 'raster':
                leafletLayer = this._createRasterLayer(sceneLayer);
                break;
            case 'vector':
                if (!this._activeLeafletVectorLayer || !this._activeLeafletVectorLayer.available()) {
                    this._activeLeafletVectorLayer = this._createVectorLayer();
                    leafletLayer = this._activeLeafletVectorLayer;
                }
                this._activeLeafletVectorLayer.addSceneLayer(sceneLayer);
                vectFlag = true;
                break;
            case 'grid':
                leafletLayer = this._createGridLayer(sceneLayer);
                break;
            case 'mesh':
                leafletLayer = this._createMeshLayer(sceneLayer);
                break;
            case 'tile':
                leafletLayer = this._createTileBoundsLayer(sceneLayer);
                break;
            case 'feedback':
                leafletLayer = this._createFeedbackLayer(sceneLayer);
                break;
            case 'overlay':
                leafletLayer = this._createOverlayLayer(sceneLayer);
                break;
            default:
                throw new Error('不能识别的图层:' + sceneLayer.type);
        }

        if (leafletLayer) {
            this._leafletMap.addLayer(leafletLayer);
        }

        if (!vectFlag) {
            sceneLayer.setLeafletLayer(leafletLayer);
            this._activeLeafletVectorLayer = null;
        }

        return sceneLayer;
    },

    removeLayer: function (layer) {
        var leafletLayer = layer.getLeafletLayer();
        var temp;
        if (leafletLayer) {
            if (layer.type === 'vector') {
                leafletLayer.removeSceneLayer(layer);
                if (leafletLayer.getSceneLayers().length === 0) {
                    if (this._activeLeafletVectorLayer === leafletLayer) {
                        this._activeLeafletVectorLayer = null;
                    }
                    this._leafletMap.removeLayer(leafletLayer);
                }
            } else {
                this._leafletMap.removeLayer(leafletLayer);
                layer.setLeafletLayer(null);
            }
        }
    }
});

/**
 * Created by zhongxiaoming on 2015/9/6.
 * Class mecator坐标转换类
 */
fastmap.mapApi.MecatorTranform = function () {
    this.M_PI = Math.PI;
    this.originShift = (2 * this.M_PI * 6378137) / 2.0; // 原先为6378137，wt修改
    this.initialResolution = (2 * this.M_PI * 6378137) / 256;
};
/** *
 * 计算当前地图分辨率
 * @param {number}zoom
 * @returns {number}
 */
fastmap.mapApi.MecatorTranform.prototype.resolution = function (zoom) {
    return this.initialResolution / Math.pow(2, zoom);
};
/**
 * 经纬度到mecator转换
 * @param {Number}lon
 * @param {Number}lat
 * @returns {Array}
 */
fastmap.mapApi.MecatorTranform.prototype.lonLat2Mercator = function (lon, lat) {
    var xy = [];
    var x = (lon * this.originShift) / 180;
    var y = Math.log(Math.tan(((90 + lat) * this.M_PI) / 360)) / (this.M_PI / 180);
    y = (y * this.originShift) / 180;
    xy.push(x);
    xy.push(y);
    return xy;
};
/** *
 *
 * mercator到经纬度坐标转化
 * @param {number}mx
 * @param {number}my
 * @returns {Array}
 */
fastmap.mapApi.MecatorTranform.prototype.mer2lonlat = function (mx, my) {
    var lonlat = [];
    lonlat.push((mx / this.originShift) * 180);
    lonlat.push((my / this.originShift) * 180);
    lonlat[1] = (180 / this.M_PI) *
      ((2 * Math.atan(Math.exp((lonlat[1] * this.M_PI) / 180))) - (this.M_PI / 2));
    return lonlat;
};
/** *
 * mecator到像素坐标转换
 * @param {number}x
 * @param {number}y
 * @param {number}zoom
 * @returns {Array}
 */
fastmap.mapApi.MecatorTranform.prototype.mercator2Pixel = function (x, y, zoom) {
    var res = this.resolution(zoom);
    var px = (x + this.originShift) / res;
    var py = (-y + this.originShift) / res;
    var xy = [];
    xy.push(px);
    xy.push(py);
    return xy;
};
/** *
 * mecator到qq地图像素坐标转换
 * @param {number}x
 * @param {number}y
 * @param {number}zoom
 * @returns {Array}
 */
fastmap.mapApi.MecatorTranform.prototype.mercator2PixelQQ = function (x, y, zoom) {
    var res = this.resolution(zoom);
    var px = (x + this.originShift) / res;
    var py = (y + this.originShift) / res;
    var xy = [];
    xy.push(px);
    xy.push(py);
    return xy;
};
/** *
 * 像素坐标到瓦片坐标转换
 * @param {number}x
 * @param {number}y
 * @returns {Array}
 */
fastmap.mapApi.MecatorTranform.prototype.pixels2Tile = function (x, y) {
    var tx = Math.ceil(x / 256) - 1;
    var ty = Math.ceil(y / 256) - 1;
    var xy = [];
    xy.push(tx);
    xy.push(ty);
    return xy;
};
/** *
 * mecator到瓦片坐标转换
 * @param {number}x
 * @param {number}y
 * @returns {Array}
 */
fastmap.mapApi.MecatorTranform.prototype.mercator2Tile = function (x, y, zoom) {
    var merXY = [];
    var xy = [];
    merXY = this.mercator2Pixel(x, y, zoom);
    xy = this.pixels2Tile(merXY[0], merXY[1]);
    return xy;
};
/** *
 * 经纬度到瓦片坐标转换
 * @param {number}x
 * @param {number}y
 * @returns {Array}
 */
fastmap.mapApi.MecatorTranform.prototype.lonlat2Tile = function (lon, lat, zoom) {
    var xy = [];
    var res;
    xy = this.lonLat2Mercator(lon, lat);
    xy = this.mercator2Pixel(xy[0], xy[1], zoom);
    res = this.pixels2Tile(xy[0], xy[1]);
    return res;
};
/** *
 * 经纬度到像素坐标转换
 * @param {number}x
 * @param {number}y
 * @returns {Array}
 */
fastmap.mapApi.MecatorTranform.prototype.lonlat2Pixel = function (lon, lat, zoom) {
    var xy = [];
    xy = this.lonLat2Mercator(lon, lat);
    xy = this.mercator2Pixel(xy[0], xy[1], zoom);
    return xy;
};
fastmap.mapApi.MecatorTranform.prototype.PixelToLonlat = function (pixelX, pixelY, zoom) {
    var x = 360 * ((pixelX / (256 << zoom)) - 0.5);
    var y = 0.5 - (pixelY / (256 << zoom));
    y = 90 - ((360 * Math.atan(Math.exp(-y * 2 * Math.PI))) / Math.PI);
    return [x, y];
};
/** *
 * 地图像素到实际距离转换
 * @param {number}x
 * @param {number}y
 * @returns {Array}
 */
fastmap.mapApi.MecatorTranform.prototype.scale = function (map) {
    /* var titleSize = 256;
     var res = ((2 * Math.PI * 6378137) / titleSize) / Math.pow(2, zoom);
     return res;*/
    var bounds = map.getBounds();
    var centerLat = bounds.getCenter().lat;
    var halfWorldMeters = 6378137 * Math.PI * Math.cos((centerLat * Math.PI) / 180);
    var dist = (halfWorldMeters * (bounds.getNorthEast().lng - bounds.getSouthWest().lng)) / 180;
    var size = map.getSize();
    var res = dist / size.x;
    return res;
};
fastmap.mapApi.MecatorTranform.prototype.rad = function (d) {
    return (d * Math.PI) / 180.0;
};
/** *
 * 地图经纬度到实际距离转换
 * @param {number}x
 * @param {number}y
 * @returns {Array}
 */
fastmap.mapApi.MecatorTranform.prototype.distance = function (lat1, lon1, lat2, lon2) {
    var radius = 6378137;
    var a = fastmap.mapApi.MecatorTranform.prototype.rad(lat1)
      - fastmap.mapApi.MecatorTranform.prototype.rad(lat2);
    var b = fastmap.mapApi.MecatorTranform.prototype.rad(lon1)
      - fastmap.mapApi.MecatorTranform.prototype.rad(lon2);
    var s = 2 * Math.asin(
          Math.sqrt(
            (Math.pow(Math.sin(a / 2), 2) + (
            Math.cos(fastmap.mapApi.MecatorTranform.prototype.rad(lat1)) *
            Math.cos(fastmap.mapApi.MecatorTranform.prototype.rad(lat2)) *
            Math.pow(Math.sin(b / 2), 2)))
          )
      );
    s *= radius;
    return Math.abs(s);
};

/**
 * Created by zhongxiaoming on 2015/9/6.
 * Class Tile
 */
fastmap.mapApi.Tile = L.Class.extend({
    options: {},
    /** *
     *
     * @param {String}url 初始化url
     * @param {Object}options 可选参数
     */
    initialize: function (url, options) {
        this.options = options || {};
        L.setOptions(this, options);
        this.url = url;
        this.data = {};
        this.xmlhttprequest = {};
    },
    /** *
     * 获得当前tile的url
     * @returns {tileJson.url}
     */
    getUrl: function () {
        return this.url;
    },
    /** *
     * 获得tile的data
     * @returns {*}
     */
    getData: function () {
        return this.data;
    },
    /** *
     * 设置tile的data
     * @param {Object}data
     */
    setData: function (data) {
        this.data = data;
    },
    /** *
     * 获得tile的httmxmlrequest对象
     * @returns {{}|*}
     */
    getRequest: function () {
        return this.xmlhttprequest;
    },
    /** *
     * 设置tile的httmxmlrequest对象
     * @param {XMLHttpRequest}xmlhttprequest
     */
    setRequest: function (xmlhttprequest) {
        this.xmlhttprequest = xmlhttprequest;
    }
});
/** *
 * 初始化tile
 * @param {String}url  初始化url
 * @param {Object}options 可选参数
 * @returns {.mapApi.Tile}
 */
fastmap.mapApi.tile = function (url, options) {
    return new fastmap.mapApi.Tile(url, options);
};

/**
 * Created by wangtun on 2016/4/21.
 */
fastmap.mapApi.ShapeOptionType = {
    /*
       画线操作
     */
    DRAWPATH: 'drawPath',
    ADDBORDERTIPS: 'addBorderTips',
    DRAWRWLINK: 'drawRwLink',
    /*
      画AdLink操作
     */
    DRAWADLINK: 'drawAdLink',
    /*
     画矩形操作
     */
    SELECTPARENT: 'SelectParent',
    /*
     /*
     画矩形操作
     */
    POISAME: 'PoiSame',
    /*
      画面操作
     */
    DRAWPOLYGON: 'drawPolygon',
    /*
     拷贝线操作
     */
    PATHCOPY: 'pathcopy',
    /*
     剪切线操作
     */
    PATHCUT: 'pathcut',
    /*
     插入线形状点操作
     */
    PATHVERTEXINSERT: 'pathVertexInsert',
    /*
      线节点移动操作
     */
    PATHVERTEXMOVE: 'pathVertexMove',
    /*
      线节点删除操作
     */
    PATHVERTEXREMOVE: 'pathVertexReMove',
    /*
      添加线节点操作
     */
    PATHVERTEXADD: 'pathVertexAdd',
    /*
      打断线操作
     */
    PATHBREAK: 'pathBreak',
    /*
     改变道路方向操作
     */
    TRANSFORMDIRECT: 'transformDirect',
    /*
      线端点移动操作
     */
    PATHNODEMOVE: 'pathNodeMove',
    /*
      添加端点操作
     */
    POINTVERTEXADD: 'pointVertexAdd',
    /*
     /*
     移动点限速操作
     */
    UPDATESPEEDNODE: 'updateSpeedNode',
    /*
    移动行政区划代表点
     */
    ADADMINMOVE: 'adAdminMove',
    /*
     上下线分离
     */
    PATHBUFFER: 'pathBuffer',
    /*
     辅路
     */
    PATHSIDE: 'pathSide',

    /*
     移动显示坐标点
     */
    POILOCMOVE: 'poiLocMove',
    /*
     移动引导坐标点
     */
    POIGUIDEMOVE: 'poiGuideMove',
    /*
     引导坐标点随着显示坐标移动
     */
    POIAUTODRAG: 'poiAutoDrag',
    /*
     增加poi
     */
    POIADD: 'poiAdd',
    /*
     增加信号灯
     */
    TRAFFICSIGNAL: 'trafficSignal',
    /*
     增加危险信息
     */
    WARNINGINFO: 'warningInfo',
    /*
     增加大门
     */
    GATE: 'gate',
    /*
     增加电子眼
     */
    ELECTRONICEYE: 'electronicEye',
    /*
     电子眼旋转
     */
    ELECTRANSFORMDIRECT: 'elecTransformDirect',
    /*
     坡度
     */
    RDSLOPE: 'rdSlope',
    /*
     CRF点
     */
    CRFINTER: 'CRFInter',
    /*
     CRF道路
     */
    CRFROAD: 'CRFRoad',
    /*
     /*
     CRF对象
     */
    CRFOBJECT: 'CRFObject',
    /*
     增加顺行
     */
    RDDIRECTROUTE: 'rdDirectRoute',
    /*
     增加减速带
     */
    RDSPEEDBUMP: 'rdSpeedBump',
    /*
     增加分叉口提示
     */
    RDSE: 'rdSe',
    /*
     增加收费站
     */
    RDTOLLGATE: 'rdTollgate',
    /*
     增加语音引导
     */
    RDVOICEGUIDE: 'rdVoiceguide',
    /*
     可变限速
     */
    VARIABLESPEED: 'variableSpeed',
    /*
     详细车道
     */
    RDLANE: 'rdLane',
    /*
     车道连通
     */
    RDLANETOPODETAIL: 'rdLaneTopoDetail',
    /*
     路口修改
     */
    MODIFYRDCROSS: 'modifyRdcross',
    /*
     限高限重
     */
    RDHGWGLIMIT: 'hgwgLimitDirect',
    /*
     分离节点
     */
    PATHDEPARTNODE: 'pathDepartNode',
    /*
     * 限高限重
     * */
    UPDATEHGWHLIMIT: 'updateHgwgLimit',
    /*
     * TMC
     * */
    TMCTRANSFORMDIRECT: 'tmcTransformDirect',
    // 平滑修形
    PATHSMOOTH: 'pathSmooth',
    // 修改分歧
    MODIFYBRANCHOUTLINK: 'modifyBranchOutLink',
    // 新建分歧
    ADDBRANCH: 'addBranch',
    // 移动行政区划代表点
    UPDATEADMINPOINT: 'updateAdminPoint'
};


/**
 * Created by xujie on 2016/11/32
 * 转换geojson坐标辅助类
 */
fastmap.mapApi.GeometryTransform = L.Class.extend({

    initialize: function () {
        this.convertFunction = null;
        this.map = null;
        this.tile = null;
    },

    /**
     * 设置转换的环境
     * @param map
     * @param tile
     * @param convertFuc
     */
    setEnviroment: function (map, tile, convertFuc) {
        this.convertFunction = convertFuc;
        this.map = map;
        this.tile = tile;
    },

  /**
   * 遍历geojson对象，使用给定的方法转换坐标
   * 不会改变原对象
   * @returns geojson对象
   */
    convertGeometry: function (geojson) {
        var type = geojson.type;
        var newGeojson = {
            type: type
        };
        switch (type) {
            case 'Point':
                newGeojson.coordinates = this.convertPoint(geojson.coordinates);
                break;
            case 'MultiPoint':
            case 'LineString':
                newGeojson.coordinates = this.convertLineString(geojson.coordinates);
                break;
            case 'MultiLineString':
            case 'Polygon':
                newGeojson.coordinates = this.convertPolygon(geojson.coordinates);
                break;
            // case 'Polygon':
            //     newGeojson.coordinates = this.convertPolygon(geojson.coordinates[0]);
            //     break;
            case 'MultiPolygon':
                newGeojson.coordinates = this.convertMultiPolygon(geojson.coordinates);
                break;
            case 'GeometryCollection':
                newGeojson.geometries = this.convertGeometryCollection(geojson.geometries);
                break;
            default:
                throw new Error('未知的几何类型:' + type);
        }

        return newGeojson;
    },

    convertPoint: function (coordinates) {
        return this.convertFunction(this.map, this.tile, coordinates);
    },

    convertLineString: function (coordinates) {
        var newCoordinates = [];
        for (var i = 0; i < coordinates.length; ++i) {
            newCoordinates.push(this.convertPoint(coordinates[i]));
        }

        return newCoordinates;
    },

    convertPolygon: function (coordinates) {
        var newCoordinates = [];
        for (var i = 0; i < coordinates.length; ++i) {
            newCoordinates.push(this.convertLineString(coordinates[i]));
        }

        return newCoordinates;
    },

    convertMultiPolygon: function (coordinates) {
        var newCoordinates = [];
        for (var i = 0; i < coordinates.length; ++i) {
            newCoordinates.push(this.convertPolygon(coordinates[i]));
        }

        return newCoordinates;
    },

    convertGeometryCollection: function (geometries) {
        var newGeometries = [];
        for (var i = 0; i < geometries.length; ++i) {
            newGeometries.push(this.convertGeometry(geometries[i]));
        }

        return newGeometries;
    },

    destroy: function () {
        fastmap.mapApi.GeometryTransform.instance = null;
    },

    statics: {
        instance: null,

        getInstance: function () {
            if (!fastmap.mapApi.GeometryTransform.instance) {
                fastmap.mapApi.GeometryTransform.instance =
                    new fastmap.mapApi.GeometryTransform();
            }
            return fastmap.mapApi.GeometryTransform.instance;
        }
    }
});

/**
 * Created by xujie on 2016/11/32
 * 处理坐标系转换
 */
fastmap.mapApi.Proj4Transform = L.Class.extend({
    initialize: function (options) {
        // epsg编号定义详见http://spatialreference.org/ref/epsg/
        // 坐标系参数含义详见:http://proj4.org/parameters.html#

        // 源坐标系使用wgs84,espg编号4326
        this.sourceProjection = '+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees +no_defs';

        // 目标坐标系使用西安80坐标系:高斯克吕格投影3°分带，中央经线120°（相当于第40带），
        // 横向坐标不含带号,epsg编号2385
        this.targetProjection = '+title=Xian80.GK3d/CM-120E +proj=tmerc +lat_0=0 +lon_0=120 +k=1 +x_0=500000 +y_0=0 +a=6378140 +b=6356755.288157528 +units=m +no_defs';

        this.transform = proj4(this.sourceProjection, this.targetProjection);
        this.forward = this.transform.forward;
        this.inverse = this.transform.inverse;
    },

    /**
     * wgs84转西安80坐标
     * 输入的坐标格式可以是{x:x,y:y}或者[]
     * 返回的坐标格式和输入格式相同
     * 直角坐标中不包含带号
     * @param coordinate
     * @returns {*}
     */
    wgs84ToXian80: function (coordinate) {
        return this.forward(coordinate);
    },

    /**
     * 西安80坐标转wgs84坐标
     * 输入的坐标格式可以是{x:x,y:y}或者[]
     * 返回的坐标格式和输入格式相同
     * 直角坐标中不包含带号
     * @param coordinate
     * @returns {*}
     */
    xian80ToWGS84: function (coordinate) {
        return this.inverse(coordinate);
    },

    destroy: function () {
        fastmap.mapApi.Proj4Transform.instance = null;
    },

    statics: {
        instance: null,

        getInstance: function () {
            if (!fastmap.mapApi.Proj4Transform.instance) {
                fastmap.mapApi.Proj4Transform.instance =
                    new fastmap.mapApi.Proj4Transform();
            }
            return fastmap.mapApi.Proj4Transform.instance;
        }
    }
});

/**
 * Created by xujie on 2017/04/14.
 */
fastmap.mapApi.TileRequestController = L.Class.extend({

    initialize: function () {
        this.tiles = {};
    },

    add: function (tileName, request) {
        if (!tileName || !request) {
            return;
        }

        if (!this.tiles[tileName]) {
            this.tiles[tileName] = [];
        }

        this.tiles[tileName].push(request);
    },

    del: function (tileName) {
        if (!tileName) {
            return;
        }

        if (!this.tiles.hasOwnProperty(tileName)) {
            return;
        }

        this.abortTileRequests(tileName);

        delete this.tiles[tileName];
    },

    getRequests: function (tileName) {
        return this.tiles[tileName];
    },

    containTile: function (tileName) {
        return this.tiles.hasOwnProperty(tileName);
    },

    abortTileRequests: function (tileName) {
        var requests = this.tiles[tileName];
        for (var i = 0; i < requests.length; ++i) {
            var request = requests[i];
            request.abort();
        }
    },

    clear: function () {
        var keys = Object.getOwnPropertyNames(this.tiles);
        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            this.del(key);
        }
        this.tiles = {};
    },

    destroy: function () {
        fastmap.mapApi.TileRequestController.instance = null;
    },

    statics: {
        instance: null,

        getInstance: function () {
            if (!fastmap.mapApi.TileRequestController.instance) {
                fastmap.mapApi.TileRequestController.instance =
                    new fastmap.mapApi.TileRequestController();
            }
            return fastmap.mapApi.TileRequestController.instance;
        }
    }
});

/**
 * Created by zhongxiaoming on 2015/9/2.
 * Class Ilayer接口
 */
fastmap.mapApi.Layer = L.Class.extend({
    /** *
     * @param {Object}options
     * isVisiable图层是否可见，默认为false
     * isSelectable图层是否可选择，默认为false
     */
    initialize: function (options) {
        FM.setOptions(this, options);
        // this.isVisiable = options.isVisiable ? true : false;
        // this.isSelectable = options.isSelectable ? true : false;
        this.isVisiable = this.options.isVisiable;
        this.isSelectable = this.options.isSelectable;
    },
    /** *
     * 图层加入到地图时调用
     * onAdd所有继承Ilayer接口的类需要重写该方法
     * @param {L.Map}map
     */
    onAdd: function (map) {
        this._map = map;
        // map.addLayer(this)
    },
    /** *
     * 图层被移除时调用
     * onRemove所有继承Ilayer接口的类需要重写该方法
     * @param {L.Map}map
     */
    onRemove: function (map) {
        // map.removeLayer(this);
        this._map = null;
    }
});
fastmap.mapApi.layer = function (options) {
    return new fastmap.mapApi.Layer(options);
};

/**
 * Created by zhongxiaoming on 2015/9/2.
 * Class WholeLayer 整福地图图层由一个canvas组成
 */
fastmap.mapApi.WholeLayer = fastmap.mapApi.Layer.extend({
    /** *
     *
     * @param options 初始化可选options
     */
    // initialize: function (options) {
    //     fastmap.mapApi.Layer.prototype.initialize.call(this, options);
    // },
    /** *
     * 图层添加到地图时调用
     * @param map
     */
    onAdd: function (map) {
        this.map = map;
        this._initContainer(this.options);
        map.on('moveend', this._redraw, this);
        this._redraw();
    },
    /** *
     * 图层被移除时调用
     * @param map
     */
    onRemove: function (map) {
        map.getPanes().overlayPane.removeChild(this._div);
        map.off('moveend', this._redraw, this);
    },
    /** *
     * 初始化图层容器
     * @param options
     * @private
     */
    _initContainer: function (options) {
        this.options = options || {};
        var container = L.DomUtil.create('div', 'leaflet-canvas-container');
        container.id = options.id || '';
        container.style.position = 'absolute';
        container.style.width = this.map.getSize().x + 'px';
        container.style.height = this.map.getSize().y + 'px';
        this.canv = document.createElement('canvas');
        this._ctx = this.canv.getContext('2d');
        this.canv.width = this.map.getSize().x;
        this.canv.height = this.map.getSize().y;
        this.canv.style.width = this.canv.width + 'px';
        this.canv.style.height = this.canv.height + 'px';
        container.appendChild(this.canv);
        this._div = container;
        this.map.getPanes().overlayPane.appendChild(this._div);
        this._div.style.zIndex = this.options.zIndex;
    },
    setZIndex: function (zIndex) {
        this._div.style.zIndex = zIndex;
        return this;
    },
    bringToFront: function () {
        this._div.style.zIndex = 100;
        return this;
    },
    bringToBack: function () {
        this._div.style.zIndex = 0;
        return this;
    },
    _setAutoZIndex: function (pane, compare) {
        this.options.zIndex = this._div.style.zIndex = 100;
    },
    /** *
     * 绘制图层内容
     */
    draw: function () {},
    /** *
     * 重绘图层
     * @private
     */
    _redraw: function () {
        this._resetCanvasPosition();
    },
    /** *
     * 清空图层
     */
    clear: function () {},
    /** *
     * 重新调整图层位置
     * @private
     */
    _resetCanvasPosition: function () {
        var bounds = this.map.getBounds();
        var topLeft = this.map.latLngToLayerPoint(bounds.getNorthWest());
        L.DomUtil.setPosition(this._div, topLeft);
    }
});
fastmap.mapApi.wholeLayer = function (options) {
    return new fastmap.mapApi.WholeLayer(options);
};

/**
 * Created by zhongxiaoming on 2015/9/6.
 * Class canvas瓦片图层
 */
fastmap.mapApi.WholeTileLayer = L.TileLayer.extend({
    options: {
        minZoom: 0,
        maxZoom: 20,
        tileSize: 256,
        opacity: 1
    },

    initialize: function (options) {
        L.setOptions(this, options);
        // 绑定函数作用域
        FM.Util.bind(this);
        this._dataSource = fastmap.mapApi.source.DataSource.getInstance();
        this._sceneController = fastmap.mapApi.scene.SceneController.getInstance();
        this._geojsonTransform = fastmap.mapApi.GeometryTransform.getInstance();
        this._geometryTransform = fastmap.mapApi.symbol.GeometryTransform.getInstance();
        this._eventController = fastmap.uikit.EventController();
        this._eventController.on(L.Mixin.EventTypes.SCENECREFRESH, this._onSceneRefresh);
        this._drawnFeatures = {};
    },

    _onSceneRefresh: function () {
        this.redraw();
    },

    _initContainer: function () {
        L.TileLayer.prototype._initContainer.call(this);

        var canvas = document.createElement('canvas');
        canvas.width = this._map.getSize().x;
        canvas.height = this._map.getSize().y;
        this._canvas = canvas;
        this._tileContainer.appendChild(this._canvas);
    },

    _resetCanvasPosition: function () {
        var bounds = this._map.getBounds();
        var topLeft = this._map.latLngToLayerPoint(bounds.getNorthWest());
        L.DomUtil.setPosition(this._tileContainer, topLeft);
    },

    _reset: function (e) {
        L.TileLayer.prototype._reset.call(this);

        this._resetCanvasPosition();

        this._drawnFeatures = {};

        this._dataSource.clear();
    },

    _removeTile: function (key) {
        var tile = this._tiles[key];

        this.fire('tileunload', { tile: tile });

        if (this.options.reuseTiles) {
            L.DomUtil.removeClass(tile, 'leaflet-tile-loaded');
            this._unusedTiles.push(tile);
        }

        delete this._tiles[key];
    },

    _addTile: function (tilePoint, container) {
        var tilePos = this._getTilePos(tilePoint);

        var tile = this._getTile(tilePoint);

        this._tiles[tile.name] = tile;

        this._loadTile(tile);
    },

    _getTile: function (tilePoint) {
        if (this.options.reuseTiles && this._unusedTiles.length > 0) {
            var tile = this._unusedTiles.pop();
            this._resetTile(tile);
            return tile;
        }
        return this._createTile(tilePoint);
    },

    _createTile: function (tilePoint) {
        var tile = {
            name: tilePoint.x + ':' + tilePoint.y,
            x: tilePoint.x,
            y: tilePoint.y
        };
        return tile;
    },

    _loadTile: function (tile) {
        var zoom = this._map.getZoom();
        var promise = this._createTilePromise(tile, zoom);
        promise.then(this._tilePromiseSuccess)
            .catch(function (e) {
                FM.Util.log(e);
            });
    },

    _createTilePromise: function (tile, zoom) {
        var promises = this._createPromises(tile, zoom);
        var promise = new Promise(function (resolve, reject) {
            Promise.all(promises)
                .then(function (res) {
                    resolve({ tile: tile, res: res });
                })
                .catch(function (e) {
                    reject(e);
                });
        });

        return promise;
    },

    _tileOnLoad: function (tile) {
        L.DomUtil.addClass(this._tileContainer, 'leaflet-tile-loaded');

        this.fire('tileload', {
            tile: tile
        });

        this._tileLoaded();
    },

    _tileOnError: function (tile) {
        this.fire('tileerror', {
            tile: tile
        });

        this._tileLoaded();
    },

    _createPromises: function (tile, zoom) {
        var urlObject = this._createUrlObject(tile);
        this._uniqueFeatureType(urlObject);

        var promises = [];
        var keys = Object.getOwnPropertyNames(urlObject);
        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            var value = urlObject[key];
            if (!value.featureTypes.length) {
                continue;
            }
            var parameter = this._dataSource.getDataLayer(key).requestParameter;
            parameter.types = value.featureTypes;
            parameter.x = tile.x;
            parameter.y = tile.y;
            parameter.z = zoom;
            var url = App.Config.serviceUrl + value.sourceUrl + '?';
            var promise = this._createAjaxPromise(url, parameter, {
                tile: tile,
                source: key,
                parse: value.parse
            });
            promises.push(promise);
        }

        return promises;
    },

    _createUrlObject: function (tile) {
        var urls = {};
        var currentScene = this._sceneController.getCurrentScene();
        if (!currentScene) {
            return urls;
        }
        var sceneItems = currentScene.layers;
        for (var i = 0; i < sceneItems.length; ++i) {
            var item = sceneItems[i];
            var source = item.getSourceName();
            var visiable = item.options.visible;
            var featureType = item.getFeatureType();
            if (!visiable || !source || !featureType) {
                continue;
            }

            var layer = this._dataSource.getDataLayer(source);
            var sourceUrl = layer.sourceUrl;
            var parse = layer.parse;
            if (!sourceUrl || !parse) {
                continue;
            }
            if (!urls.hasOwnProperty(source)) {
                urls[source] = {
                    sourceUrl: sourceUrl,
                    featureTypes: [],
                    parse: parse
                };
            }
            urls[source].featureTypes.push(featureType);
        }
        return urls;
    },

    _uniqueFeatureType: function (urlObject) {
        var keys = Object.getOwnPropertyNames(urlObject);
        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            var value = urlObject[key];
            urlObject[key].featureTypes = FM.Util.unique(value.featureTypes);
        }
    },

    _createAjaxPromise: function (url, requestParameter, addtionParameter) {
        var promise = new Promise(function (resolve, reject) {
            var options = {
                url: url,
                requestParameter: requestParameter,
                parameter: addtionParameter,
                timeout: 10000,
                responseType: 'json',
                // debug: true,
                onSuccess: function (json, parameter) {
                    if (json.errcode == 0) { // 操作成功
                        resolve({ data: json.data, parameter: parameter });
                    } else {
                        reject({ errmsg: json.errmsg, parameter: parameter });
                    }
                },
                onFail: function (errmsg, parameter) {
                    reject({ errmsg: errmsg, parameter: parameter });
                },
                onError: function (errmsg, parameter) {
                    reject({ errmsg: errmsg, parameter: parameter });
                },
                onTimeout: function (errmsg, parameter) {
                    reject({ errmsg: errmsg, parameter: parameter });
                }
            };
            fastmap.mapApi.ajax.get(options);
        });

        return promise;
    },

    _tilePromiseSuccess: function (res) {
        var allFeatures = {};
        var tile = res.tile;
        var tmpRes = res.res;
        for (var i = 0; i < tmpRes.length; ++i) {
            var item = tmpRes[i];
            var data = item.data;
            var parameter = item.parameter;
            var layer = this._dataSource.getDataLayer(parameter.source);
            var features = parameter.parse(data);
            this._convertGeometry(this._map, parameter.tile, features);
            this._classifyFeaturesByGeoLiveType(allFeatures, features);
            this._addFeaturesToDataSource(layer, allFeatures);
        }
        console.log(tile.name + '********************************');
        var urls = this._getDependencyResource(allFeatures);
        var loader = new fastmap.mapApi.symbol.ImageLoader(urls);

        var self = this;
        loader.load()
            .then(function () {
                self._onDependencyResourceLoaded(allFeatures);
                self._tileOnLoad(tile);
            })
            .catch(function (e) {
                FM.Util.log(e);
            });
    },

    _classifyFeaturesByGeoLiveType: function (allFeatures, features) {
        for (var i = 0; i < features.length; i++) {
            var feature = features[i];
            if (!this._isDrawnFeature(feature)) {
                var geoLiveType = feature.properties.geoLiveType;
                if (!allFeatures.hasOwnProperty(geoLiveType)) {
                    allFeatures[geoLiveType] = [];
                }
                allFeatures[geoLiveType].push(feature);

                var id = feature.properties.id;
                var key = geoLiveType + ':' + id;
                this._drawnFeatures[key] = true;
            }
        }
    },

    _getDependencyResource: function (allFeatures) {
        var features = this._getFeatures(allFeatures);

        var urls = [];
        for (var i = 0; i < features.length; i++) {
            var feature = features[i];
            var symbol = feature.properties.symbol;
            if (!symbol) {
                continue;
            }

            if (FM.Util.isArray(symbol)) {
                urls = urls.concat(this._getUrlsFromSymbolArray(symbol));
            } else {
                var symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();
                urls = urls.concat(symbolFactory.getUrlsFromSymbol(symbol));
            }
        }

        return urls;
    },

    _getFeatures: function (allFeatures) {
        var features = [];
        var keys = Object.getOwnPropertyNames(allFeatures);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            var tmpFeatures = allFeatures[key];
            features = features.concat(tmpFeatures);
        }
        return features;
    },

    _getUrlsFromSymbolArray: function (symbols) {
        var symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();
        var urls = [];
        for (var i = 0; i < symbols.length; i++) {
            var symbol = symbols[i];
            var symbolUrls = symbolFactory.getUrlsFromSymbol(symbol);
            urls = urls.concat(symbolUrls);
        }

        return urls;
    },

    _addFeaturesToDataSource: function (layer, allFeatures) {
        var keys = Object.getOwnPropertyNames(allFeatures);
        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            var features = allFeatures[key];
            for (var j = 0; j < features.length; ++j) {
                var feature = features[j];
                layer.add(feature);
            }
        }
    },

    _isDrawnFeature: function (feature) {
        var key = feature.properties.geoLiveType + ':' + feature.properties.id;
        if (this._drawnFeatures.hasOwnProperty(key)) {
            return true;
        }

        return false;
    },

    _convertGeometry: function (map, tile, features) {
        this._geojsonTransform.setEnviroment(map, tile, this._convertGeojsonToLngLat);
        for (var i = 0; i < features.length; ++i) {
            var feature = features[i];
            feature.geometry = this._geojsonTransform.convertGeometry(feature.geometry);
        }
    },

    _convertGeojsonToLngLat: function (map, tileInfo, coordinates) {
        var x = tileInfo.x * this.options.tileSize + coordinates[0];
        var y = tileInfo.y * this.options.tileSize + coordinates[1];
        var lnglat = map.unproject([x, y]);
        return [lnglat.lng, lnglat.lat];
    },

    _onDependencyResourceLoaded: function (allFeatures) {
        var sceneItems = this._sceneController.currentScene.items;
        for (var i = 0; i < sceneItems.length; ++i) {
            var item = sceneItems[i];
            var source = item.source;
            var visiable = item.visible;
            var featureType = item.featureType;
            var render = item.render;
            if (!visiable || !source || !featureType || !render) {
                continue;
            }

            // eslint-disable-next-line new-cap
            render = new render();

            var features = allFeatures[featureType];
            if (features) {
                console.log(featureType + '+++++++++++++++++++++++++++++++++++++');
                this._drawFeatures(features, render);
            }
        }
    },

    _drawFeatures: function (features, render) {
        var g = this._canvas.getContext('2d');
        var zoom = this._map.getZoom();
        var pids = [];
        for (var i = 0; i < features.length; i++) {
            var feature = features[i];
            pids.push(feature.properties.id);
            var symbol = render.symbolize(feature, zoom);
            if (feature.properties.id === 737370) {
                var a = 0;
            }

            if (FM.Util.isArray(symbol)) {
                this._drawSymbolArray(g, symbol);
            } else {
                this._drawSymbol(symbol, g);
            }
        }
        pids = pids.sort();
        console.log(JSON.stringify(pids));
        // this.eventController.fire(this.eventController.eventTypes.TILEDRAWEND, {
        //     layer: this,
        //     id: ctx.tile.x + ':' + ctx.tile.y,
        //     zoom: ctx.zoom
        // });
    },

    _drawSymbolArray: function (g, array) {
        array.forEach(function (item) {
            this._drawSymbol(item, g);
        }, this);
    },

    _drawSymbol: function (symbol, g) {
        this._geometryTransform.setEnviroment(this._map, null, this._convertGeometryToPixel);
        var convertedGeometry = this._geometryTransform.convertGeometry(symbol.geometry);
        symbol.geometry = convertedGeometry;
        symbol.draw(g);
    },

    _convertGeometryToPixel: function (map, tile, geometry) {
        var point = map.latLngToContainerPoint([geometry.y, geometry.x]);
        geometry.x = point.x;
        geometry.y = point.y;
        return geometry;
    }
});

/**
 * Created by xujie on 2016-11-26.
 * WholeCanvasLayer类代表整体的图层
 */
fastmap.mapApi.WholeCanvasLayer = fastmap.mapApi.WholeLayer.extend({
    /** *
     *
     * @param options 初始化可选options
     */
    initialize: function (options) {
        fastmap.mapApi.WholeLayer.prototype.initialize.call(this, options);

        // 绑定函数作用域
        // FM.Util.bind(this);

        this._drawItems = {};

        this._transform = fastmap.mapApi.symbol.GeometryTransform.getInstance();
    },

    /** *
     * 图层添加到地图时调用
     * @param map
     */
    onAdd: function (map) {
        this.map = map;
        this._initContainer(this.options);
    },
    /** *
     * 图层被移除时调用
     * @param map
     */
    onRemove: function (map) {
        map.getPanes().overlayPane.removeChild(this._div);
    },

    /** *
     * 绘制图层内容
     */
    draw: function (tile, features) {
        var symbols = this._symbolizeFeatures(features);
        var urls = this._getDependencyResource(symbols);
        var loader = new fastmap.mapApi.symbol.ImageLoader(urls);
        var self = this;
        loader.load()
            .then(function () {
                self._onDependencyResourceLoaded(tile, symbols);
            })
            .catch(function (e) {
                FM.Util.log(e);
            });
    },

    /** *
     * 清空图层
     */
    clear: function () {
        this._resetCanvasPosition();
        this._ctx.clearRect(0, 0, this.canv.width, this.canv.height);
        this._drawItems = {};
    },

    _symbolizeFeatures: function (features) {
        var zoom = this.map.getZoom();
        var render = this.options.render;

        // eslint-disable-next-line new-cap
        render = new render();

        var symbols = [];
        for (var i = 0; i < features.length; ++i) {
            var feature = features[i];
            if (!this._canDraw(zoom, feature)) {
                continue;
            }

            var symbol = render.getSymbol(feature, this.map.getZoom());
            if (!symbol) {
                // 如果要素在某种情况下不需要绘制会返回null
                continue;
            }
            if (FM.Util.isArray(symbol)) {
                symbols = symbols.concat(symbol);
            } else {
                symbols.push(symbol);
            }
        }

        return symbols;
    },

    _canDraw: function (zoom, feature) {
        if (zoom < 17) {
            // 小于17级时不需要做去重处理,所以总是可绘制
            return true;
        }

        var geoLiveType = feature.properties.geoLiveType;
        var id = feature.properties.id;
        var key = geoLiveType + ':' + id;
        if (this._drawItems.hasOwnProperty(key)) {
            // 已经绘制过了
            return false;
        }

        this._drawItems[key] = true;
        return true;
    },

    _onDependencyResourceLoaded: function (tile, symbols) {
        this._transform.setEnviroment(this.map, tile, this._convertGeometry);
        var g = this._ctx.canvas.getContext('2d');
        for (var i = 0; i < symbols.length; ++i) {
            var symbol = symbols[i];
            var convertedGeometry = this._transform.convertGeometry(symbol.geometry);
            symbol.geometry = convertedGeometry;
            symbol.draw(g);
        }
    },

    _getDependencyResource: function (symbols) {
        var symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();
        var urls = [];
        for (var i = 0; i < symbols.length; i++) {
            var symbol = symbols[i];
            urls = urls.concat(symbolFactory.getUrlsFromSymbol(symbol));
        }

        return urls;
    },

    _convertGeometry: function (map, tile, geometry) {
        var origin = this.map.getPixelBounds().min;
        var x = tile.size * tile.x + geometry.x - origin.x;
        var y = tile.size * tile.y + geometry.y - origin.y;
        geometry.x = x;
        geometry.y = y;
        return geometry;
    }
});

fastmap.mapApi.wholeCanvasLayer = function (options) {
    return new fastmap.mapApi.WholeCanvasLayer(options);
};

fastmap.mapApi.FrozenCanvasLayer = fastmap.mapApi.WholeCanvasLayer.extend({
    _symbolizeFeatures: function (features) {
        var zoom = this.map.getZoom();
        var renderMap = this.options.renderMap;

        var render;
        var symbols = [];
        for (var i = 0; i < features.length; ++i) {
            var feature = features[i];
            if (!this._canDraw(zoom, feature)) {
                continue;
            }

            render = renderMap[feature.properties.geoLiveType];
            var symbol = render.getSymbol(feature, this.map.getZoom());
            if (!symbol) {
                // 如果要素在某种情况下不需要绘制会返回null
                continue;
            }
            if (FM.Util.isArray(symbol)) {
                symbols = symbols.concat(symbol);
            } else {
                symbols.push(symbol);
            }
        }

        return symbols;
    },

    setRenderMap: function (geoLiveType, Render) {
        this.options.renderMap = this.options.renderMap || {};

        if (Render) {
            this.options.renderMap[geoLiveType] = new Render();
        } else {
            delete this.options.renderMap[geoLiveType];
        }
    }
});

fastmap.mapApi.frozenCanvasLayer = function (options) {
    return new fastmap.mapApi.FrozenCanvasLayer(options);
};

FM.mapApi.VectorLayer = FM.mapApi.WholeCanvasLayer.extend({
    initialize: function (options) {
        FM.mapApi.WholeCanvasLayer.prototype.initialize.call(this, options);

        this._sourceController = FM.mapApi.source.SourceController.getInstance();
        this._sceneLayers = [];
        this._size = 20; // 最多可加载的sceneLayer的个数
    },
    /** *
     * 绘制图层内容
     */
    draw: function (tile) {
        var symbols = this._getSymbols(tile);
        var urls = this._getDependencyResource(symbols);
        var loader = new FM.mapApi.symbol.ImageLoader(urls);
        var self = this;
        loader.load()
            .then(function () {
                self._onDependencyResourceLoaded(tile, symbols);
            })
            .catch(function (e) {
                FM.Util.log(e);
            });
    },

    _getSymbols: function (tile) {
        var symbols = [];
        var zoom = this.map.getZoom();
        var sceneLayer,
            options,
            geoLiveType,
            source,
            render,
            features;
        for (var i = 0; i < this._sceneLayers.length; i++) {
            sceneLayer = this._sceneLayers[i];
            if (!sceneLayer.canDraw(zoom)) {
                continue;
            }

            options = sceneLayer.getOptions();
            if (!options.featureType || !options.render || !options.source) {
                continue;
            }

            // eslint-disable-next-line new-cap
            render = new options.render();
            source = this._sourceController.getSource(options.source);
            features = source.queryFeaturesByType(options.featureType, tile.fullName);

            Array.prototype.push.apply(symbols, this._symbolizeFeatures(features, sceneLayer, render));
        }

        return symbols;
    },

    _symbolizeFeatures: function (features, sceneLayer, render) {
        var symbols = [];
        var feature,
            symbol;
        for (var i = 0; i < features.length; ++i) {
            feature = features[i];
            if (!this._canDraw(feature, sceneLayer)) {
                continue;
            }

            symbol = render.getSymbol(feature, this.map.getZoom());
            if (!symbol) {
                // 如果要素在某种情况下不需要绘制会返回null
                continue;
            }
            if (FM.Util.isArray(symbol)) {
                Array.prototype.push.apply(symbols, symbol);
            } else {
                symbols.push(symbol);
            }
        }

        return symbols;
    },

    _canDraw: function (feature, sceneLayer) {
        var zoom = this.map.getZoom();
        var filterObj = sceneLayer.options.unique;
        var minEditZoom = sceneLayer.options.minEditZoom || sceneLayer.options.minZoom;
        if (filterObj) {
            if (zoom < filterObj.level) {
                return true;
            }
        } else {
            if (zoom < minEditZoom) {
                // 小于最小可编辑级别时不需要做去重处理,所以总是可绘制
                return true;
            }
        }

        var geoLiveType = feature.properties.geoLiveType;
        var id = feature.properties.id;
        var key = sceneLayer.id + ':' + geoLiveType + ':' + id;
        if (this._drawItems.hasOwnProperty(key)) {
            // 已经绘制过了
            return false;
        }

        this._drawItems[key] = true;
        return true;
    },

    addSceneLayer: function (sceneLayer) {
        sceneLayer.setLeafletLayer(this);
        this._sceneLayers.push(sceneLayer);
    },

    removeSceneLayer: function (sceneLayer) {
        var index = this._sceneLayers.indexOf(sceneLayer);
        if (index >= 0) {
            this._sceneLayers.splice(index, 1);
            sceneLayer.setLeafletLayer(null);
        }
    },

    getSceneLayers: function () {
        return this._sceneLayers;
    },

    available: function () {
        return this._sceneLayers.length <= this._size;
    }
});

FM.mapApi.vectorLayer = function (options) {
    return new FM.mapApi.VectorLayer(options);
};

/**
 * Created by zhongxiaoming on 2015/9/2.
 * Class 1:25000图幅图层
 */
fastmap.mapApi.MeshLayer = fastmap.mapApi.WholeLayer.extend({
    /** *
     * 初始化可选参数
     * @param {Object}options
     */
    initialize: function (options) {
        fastmap.mapApi.WholeLayer.prototype.initialize.call(this, options);
        this.minZoom = this.options.minZoom || 9;
        this.maxZoom = this.options.maxZoom || 20;
        this.latStep = 0.083333333333333;
        // this.latStep = 0.08333;
        this.lngStep = 0.125;
    },
    /** *
     * 图层添加到地图时调用
     * @param{L.Map} map
     */
    onAdd: function (map) {
        this.map = map;
        this._initContainer(this.options);
        map.on('moveend', this._redraw, this);
        this._redraw();
    },
    /** *
     * 根据bounds绘制图幅
     * @param {L.Bounds}bounds
     */
    draw: function (bounds) {
        var pointDL = bounds.getSouthWest();
        // 右上角点
        var pointUR = bounds.getNorthEast();
        // var ret= this.CalculateMeshIds(pointDL.lng, pointUR.lng, pointDL.lat, pointUR.lat);
        var minPoint = this.Calculate25TMeshCorner(pointDL);
        var minLon = minPoint.lng;
        var minLat = minPoint.lat;
        this.gridArr = [];
        var labelArr = [];
        while (minLon <= pointUR.lng) {
            var gridObj = this.createGrid(minLon, minLon + this.lngStep, minLat, pointUR.lat);
            this.gridArr = this.gridArr.concat(gridObj);
            minLon += this.lngStep;
        }
        for (var i = 0, len = this.gridArr.length; i < len; i++) {
            var latlngbounds = this.gridArr[i].getBounds();
            var bound = L.bounds(this.map.latLngToContainerPoint(latlngbounds.getNorthWest()), this.map.latLngToContainerPoint(latlngbounds.getSouthEast()));
            var size = bound.getSize();
            this.drawRect(this._ctx, this.gridArr[i].options.meshid, bound);
        }
    },
    /** *
     * 绘制图幅
     * @param {Object}context canvas context
     * @param meshId 图幅id
     * @param options 可选参数
     */
    drawRect: function (context, meshId, options) {
        var fontSize = this.map.getZoom();
        if (fontSize >= 10) {
            fontSize += 5;
            context.font = fontSize + 'px Verdana';
            context.fillText(meshId, options.min.x + (options.max.x - options.min.x) / 2 - fontSize * 2, options.min.y + (options.max.y - options.min.y) / 2 + fontSize / 3);
        }
        context.strokeStyle = '#00ff00'; // 边框颜色
        context.linewidth = 3; // 边框宽
        context.strokeRect(options.min.x, options.min.y, options.getSize().x, options.getSize().y); // 填充边框 x y坐标 宽 高
        context.stroke();
    },
    /** *
     * 重绘
     * @returns {fastmap.mapApi.MeshLayer}
     * @private
     */
    _redraw: function () {
        this._resetCanvasPosition();
        this.clear();
        if (this.map.getZoom() >= this.minZoom && this.map.getZoom() <= this.maxZoom) {
            this.draw(this.map.getBounds());
        }
        return this;
    },
    /** *
     * 生成图幅格网
     * @param {number}minLon 最小经度
     * @param {number}maxLon 最大经度
     * @param {number}origin 原点
     * @param {number}destination 最大经度
     * @returns {Array}
     */
    createGrid: function (minLon, maxLon, origin, destination) {
        // 保存生成的网格
        var grids = [];
        var minLat = origin;
        var maxLat;
        var meshId;
        var bounds;
        while (minLat <= destination) {
            maxLat = minLat + this.latStep;
            meshId = this.Calculate25TMeshId({
                lng: (minLon + maxLon) / 2,
                lat: (minLat + maxLat) / 2
            });
            // var bound = this.Calculate25TMeshBorder(meshId); // commented by chenx on 2016-11-22, 这里时不需要计算的
            bounds = L.latLngBounds([this.checkAccuracy(minLat, 100000), this.checkAccuracy(minLon, 100000)], [this.checkAccuracy(maxLat, 100000), this.checkAccuracy(maxLon, 10000)]);
            grids.push(L.rectangle(bounds, {
                meshid: meshId
            }));
            minLat = maxLat;
        }
        return grids;
    },

    /**
     * 坐标精度校正，保留小数点后五位
     * @param number
     * @param accuracy
     */
    checkAccuracy: function (number, accuracy) {
        return parseInt(number * accuracy + 0.5, 10) / accuracy;
    },

    /** *
     * 清空图层
     */
    clear: function () {
        this.canv.getContext('2d').clearRect(0, 0, this.canv.width, this.canv.height);
    },
    /** *
     * 重新调整图层位置
     * @private
     */
    _resetCanvasPosition: function () {
        var bounds = this.map.getBounds();
        var topLeft = this.map.latLngToLayerPoint(bounds.getNorthWest());
        L.DomUtil.setPosition(this._div, topLeft);
    },
    /*
     *  根据纬度计算该点位于理想图幅分割的行序号
     *
     *  @param{number}lat                 纬度      单位‘度’
     *  @param{number}remainder           余数      单位‘千秒’
     */
    CalculateIdealRowIndex: function (lat, remainder) {
        // 相对区域纬度 = 绝对纬度 - 0.0
        var regionLatitude = lat - 0.0;
        // 相对的以秒为单位的纬度
        var secondLatitude = regionLatitude * 3600;
        var longsecond;
        // 为避免浮点数的内存影响，将秒*10的三次方(由于0.00001度为0.036秒)
        if (secondLatitude * 1000 < 0) {
            longsecond = Math.ceil(secondLatitude * 1000);
        } else {
            longsecond = Math.floor(secondLatitude * 1000);
        }
        remainder = (longsecond % 300000);
        return {
            value: Math.floor(longsecond / 300000),
            reminder: remainder
        };
    },
    /*
     *  根据纬度计算该点位于实际图幅分割的行序号
     *
     *  @param{number}lat                 纬度      单位‘度’
     *  @param{number}remainder           余数      单位‘千秒’
     */
    CalculateRealRowIndex: function (lat, remainder) {
        // 理想行号
        var idealRow = this.CalculateIdealRowIndex(lat, remainder);
        switch (idealRow % 3) {
            case 0: // 第一行
                if (300000 - idealRow.remainder <= 12) {
                    idealRow.value++;
                }
                break;
            case 1: // 第二行
                break;
            case 2: // 第三行
                if (idealRow.remainder < 12) {
                    idealRow.value--;
                }
                break;
            default:
                break;
        }
        return idealRow;
    },
    /*
     *  根据经度计算该点位于实际图幅分割的列序号
     *
     *  @param{number}lon                经度，单位“度”
     */
    CalculateRealColumnIndex: function (lon, remainder) {
        return this.CalculateIdealColumnIndex(lon, remainder);
    },
    /*
     * 根据经度计算该点位于理想图幅分割的列序号
     *
     *  @param{number}lon                经度，单位“度”
     *  @param{number}reminder           余数 单位“千秒”
     */
    CalculateIdealColumnIndex: function (lon, remainder) {
        // 相对区域经度 = 绝对经度 - 60.0
        var regionLongitude = lon - 60.0;
        // 相对的以秒为单位的经度
        var secondLongitude = regionLongitude * 3600;
        // 为避免浮点数的内存影响，将秒*10的三次方(由于0.00001度为0.036秒)
        var longsecond = Math.floor(secondLongitude * 1000);
        remainder = Math.floor(longsecond % 450000);
        return {
            value: Math.floor(longsecond / 450000),
            reminder: remainder
        };
    },
    MeshLocator_25T: function (lon, lat) {
        // 为了保证它总返回右上的图幅
        if ((this.IsAt25TMeshBorder(lon, lat) & 0x0F) == 0x01) {
            lat += 0.00001;
        }
        var remainder = 0;
        var rowResult = this.CalculateRealRowIndex(lat, remainder);
        var colResult = this.CalculateRealColumnIndex(lon, rowResult.reminder);
        // 第1、2位 : 纬度取整拉伸1.5倍
        var M1M2 = Math.floor(lat * 1.5);
        // 第3、4位 : 经度减去日本角点 60度
        var M3M4 = Math.floor(lon) - 60;
        // 第5位 :
        var M5 = rowResult.value % 8;
        // 第6位 : 每列450秒，每度包含8列
        var M6 = colResult.value % 8;
        // 连接以上数字,组成图幅号
        var sMeshId = '' + M1M2 + M3M4 + M5 + M6;
        while (sMeshId.length < 6) {
            sMeshId = '0' + sMeshId;
        }
        return sMeshId;
    },
    /*
     *  点所在的图幅号,如果点在图幅边界上,返回右上的图幅号
     *
     *  @param {L.Latlng}point   经纬度点
     */
    Calculate25TMeshId: function (point) {
        var mesh = this.MeshLocator_25T(point.lng, point.lat);
        return mesh;
    },
    /*
     *  快速计算点所在的图幅左下角点
     *
     *  @param{L.Latlng}point          经纬度点
     */
    Calculate25TMeshCorner: function (point) {
        return this.Calculate25TMeshCornerByMeshId(this.Calculate25TMeshId(point));
    },
    /** *
     * 计算图幅角点坐标
     * @param {String}mesh
     * @returns {*}
     * @constructor
     */
    Calculate25TMeshCornerByMeshId: function (mesh) {
        var cc = mesh.split('');
        var M1 = parseInt(cc[0], 0);
        var M2 = parseInt(cc[1], 0);
        var M3 = parseInt(cc[2], 0);
        var M4 = parseInt(cc[3], 0);
        var M5 = parseInt(cc[4], 0);
        var M6 = parseInt(cc[5], 0);
        var x = (M3 * 10 + M4) * 3600 + M6 * 450 + 60 * 3600;
        var y = (M1 * 10 + M2) * 2400 + M5 * 300;
        var point = L.latLng(y / 3600.0, x / 3600.0);
        return point;
    },
    /** *
     *  计算图幅border
     * @param {String}mesh
     * @returns {{minLon:
     *   (*|a.lng|L.LatLng.lng|L.LatLngBounds._southWest.lng|L.LatLngBounds._northEast.lng|o.LatLngBounds._northEast.lng),
     *   minLat:
     *   (*|a.lat|L.LatLng.lat|L.LatLngBounds._southWest.lat|L.LatLngBounds._northEast.lat|o.LatLngBounds._northEast.lat),
     *   maxLon:
     *   (*|a.lng|L.LatLng.lng|L.LatLngBounds._southWest.lng|L.LatLngBounds._northEast.lng|o.LatLngBounds._northEast.lng),
     *   maxLat:
     *   (*|a.lat|L.LatLng.lat|L.LatLngBounds._southWest.lat|L.LatLngBounds._northEast.lat|o.LatLngBounds._northEast.lat)}}
     * @constructor
     */
    Calculate25TMeshBorder: function (mesh) {
        var cc = mesh.split('');
        var M1 = parseInt(cc[0], 0);
        var M2 = parseInt(cc[1], 0);
        var M3 = parseInt(cc[2], 0);
        var M4 = parseInt(cc[3], 0);
        var M5 = parseInt(cc[4], 0);
        var M6 = parseInt(cc[5], 0);
        var xConner = (M3 * 10 + M4) * 3600 + M6 * 450 + 60 * 3600;
        var yConner = (M1 * 10 + M2) * 2400 + M5 * 300;
        var xUpper = xConner + 450.0;
        var yUpper = yConner + 300.0;
        var leftBottom = L.latLng(yConner / 3600.0, xConner / 3600.0);
        var rightTop = L.latLng(yUpper / 3600.0, xUpper / 3600.0);
        return {
            minLon: leftBottom.lng,
            minLat: leftBottom.lat,
            maxLon: rightTop.lng,
            maxLat: rightTop.lat
        };
    },
    /*
     *  点是否在图框上
     *
     *  @param{number}lon               经度
     *  @param{number}lat               纬度
     */
    IsAt25TMeshBorder: function (lon, lat) {
        var model = 0;
        var remainder = 0;
        var rowResult = this.CalculateIdealRowIndex(lat, remainder);
        switch (rowResult.value % 3) {
            case 0: // 第一行
                if (300000 - rowResult.reminder == 12) {
                    model |= 0x01;
                } else if (rowResult.reminder == 0) model |= 0x01;
                break;
            case 1: // 第二行由于上下边框均不在其内，因此不在图框上
                break;
            case 2: // 第三行
                if (rowResult.reminder == 12) {
                    model |= 0x01;
                }
                break;
            default:
                break;
        }
        var colResult = this.CalculateRealColumnIndex(lon, rowResult.reminder);
        if (colResult.reminder == 0) model |= 0x10;
        return model;
    }
});
fastmap.mapApi.meshLayer = function (options) {
    return new fastmap.mapApi.MeshLayer(options);
};

/**
 * Created by zhongxiaoming on 2016/3/23.
 * Class fastmap.mapApi.LayerRender
 */
fastmap.mapApi.LayerRender = {
    /** *
     * 绘制点
     * @param ctx {canvas: canvas,tile: tilePoint,zoom: zoom}
     * @param geom 点对象
     * @param style 样式
     * @param boolPixelCrs 是否是像素坐标
     * @private
     */
    _drawPoint: function (options) {
        var p = null;
        if (options.boolPixelCrs) {
            p = {
                x: options.geom[0],
                y: options.geom[1]
            };
        } else {
            p = this._tilePoint(options.ctx, options.geom);
        }
        var c = options.ctx.canvas;
        var g = c.getContext('2d');
        g.beginPath();
        if (options.fillColor) {
            g.fillStyle = options.fillColor;
        }
        if (options.fillOpacity) {
            g.fillOpacity = options.fillOpacity;
        }
        if (options.strokeColor) {
            g.strokeColor = options.strokeColor;
        }
        if (options.strokeOpacity) {
            g.strokeOpacity = options.strokeOpacity;
        }
        g.arc(p.x, p.y, options.radius, 0, Math.PI * 2);
        g.closePath();
        g.fill();
        g.restore();
    },
    /** *
     * 绘制空心圆
     * @param ctx {canvas: canvas,tile: tilePoint,zoom: zoom}
     * @param geom 点对象
     * @param style 样式
     * @param boolPixelCrs 是否是像素坐标
     * @private
     */
    _drawCircle: function (ctx, geom, style, boolPixelCrs) {
        if (!style) {
            return;
        }
        var p = null;
        if (boolPixelCrs) {
            p = {
                x: geom[0],
                y: geom[1]
            };
        } else {
            p = this._tilePoint(ctx, geom);
        }
        var c = ctx.canvas;
        var g = c.getContext('2d');
        g.beginPath();
        g.fillStyle = style.color;
        g.arc(p.x, p.y, style.radius, 0, Math.PI * 2);
        g.stroke(); // 画空心圆
        g.closePath();
    },
    /** *
     * @param options
     * @param geo几何对象
     * @param boolPixelCrs是否以像素坐标绘制
     * @param ctx 绘制上下文
     * @param rotate旋转角度
     * @param scaley 缩放比例
     * @param drawx 绘制时x方向平移
     * @param drawy 绘制时y方向平移
     * @param fillStyle边框填充样式
     * @private
     */
    _drawImg: function (options) {
        var p = null;
        var style = options.style;
        if (options.boolPixelCrs) {
            p = {
                x: options.geo[0],
                y: options.geo[1]
            };
        } else {
            p = this._tilePoint(options.ctx, options.geom);
        }
        var c = options.ctx.canvas;
        var g = c.getContext('2d');
        var image = new Image();
        var rotate = options.rotate;
        image.src = style.src;
        image.onload = function () {
            var scalex = options.scalex ? options.scalex : 1;
            var scaley = options.scaley ? options.scaley : 1;
            var drawx = options.drawx ? options.drawx : -image.width * scalex / 2;
            var drawy = options.drawy ? options.drawy : -image.height * scalex / 2;
            // var drawx = -options.c * image.width/2;
            // var drawy = 0
            g.save();
            g.translate(p.x, p.y);
            if (options.fillStyle) {
                g.strokeStyle = options.fillStyle.lineColor; // 边框颜色
                g.fillStyle = options.fillStyle.fillColor;
                g.linewidth = options.fillStyle.lineWidth; // 边框宽
                if (options.fillStyle.fillType == 'IXPOI') {
                    g.beginPath();
                    g.arc(0, 0, image.width * scalex / 2 + 2, 0, 2 * Math.PI);
                    g.stroke();
                } else {
                    g.fillRect(drawx, drawy, image.width, image.height); // 填充颜色 x y坐标 宽 高
                    g.strokeRect(drawx, drawy, image.width, image.height); // 填充边框 x y坐标 宽 高
                }
            }
            if (rotate) {
                g.rotate(rotate); // 旋转度数
            }
            g.drawImage(image, drawx, drawy, image.width * scalex, image.height * scaley);
            g.restore();
        };
    },
    _drawBackground: function (options) {
        var p = null;
        if (options.boolPixelCrs) {
            p = {
                x: options.geo[0],
                y: options.geo[1]
            };
        } else {
            p = this._tilePoint(options.ctx, options.geom);
        }
        var c = options.ctx.canvas;
        var g = c.getContext('2d');
        var rotate = options.rotate;
        var scalex = options.scalex ? options.scalex : 1;
        var scaley = options.scaley ? options.scaley : 1;
        var drawx = options.drawx;
        var drawy = options.drawy;
        g.save();
        g.translate(p.x, p.y);
        if (rotate) {
            g.rotate(rotate); // 旋转度数
        }
        g.strokeStyle = options.lineColor; // 边框颜色
        g.fillStyle = options.fillColor;
        g.linewidth = options.lineWidth; // 边框宽
        g.fillRect(drawx, drawy, options.width, options.height); // 填充颜色 x y坐标 宽 高
        g.strokeRect(drawx, drawy, options.width, options.height); // 填充边框 x y坐标 宽 高
        g.restore();
    },
    _drawLinkNameText: function (ctx, geom, name) {
        var startLen = geom.concat().length;
        geom = this._clip(ctx, geom);
        var endLen = geom.length;
        var c = ctx.canvas;
        var g = c.getContext('2d');
        g.font = '10px Courier New';
        g.textAlign = 'center';
        var angle;
        var nameArr = name.split('');
        var nameLen = name.length * 10;
        var lineLen = 0;
        if (geom.length === 2) {
            angle = this._rotateAngle(geom[0], geom[1]);
            lineLen = this.distance(geom[0], geom[1]);
            if (nameLen < lineLen / 2 && lineLen > 160) {
                this._showTextOfAngle(ctx, 0, name, angle, [(geom[0][0] + geom[1][0]) / 2, (geom[0][1] + geom[1][1]) / 2]);
            }
        } else {
            var startPoint = geom[0];
            var startPointForLen = geom[0];
            var endPoint = geom[geom.length - 1];
            var textLength = 0;
            var startText = 0;
            var textIndex = 0;
            var betPointsLen;
            var realLineLen = 0;
            var linkArrLen = geom.length;
            for (var m = 1; m < linkArrLen; m++) {
                betPointsLen = this.distance(geom[m], startPointForLen);
                realLineLen += betPointsLen;
                startPointForLen = geom[m];
            }
            if (nameLen < realLineLen / 2 && realLineLen > 50) {
                startPoint = geom[2];
                for (var linkFLag = 1; linkFLag < linkArrLen; linkFLag++) {
                    if (textLength < nameArr.length) {
                        betPointsLen = this.distance(geom[linkFLag], startPoint);
                        angle = this._rotateAngle(startPoint, geom[linkFLag]);
                        if (betPointsLen > 10) {
                            textIndex = parseInt(betPointsLen / 10, 10);
                            this._showTextOfAngle(ctx, 0, name, angle, startPoint);
                            break;
                        } else {
                            startPoint = geom[linkFLag];
                        }
                    }
                }
            }
        }
    },
    _drawBridge: function (cav, geom, that) {
        var c = cav.canvas;
        var ctx = c.getContext('2d');
        var oriStart,
            oriEnd;
        oriStart = geom[0][0];
        for (var i = 1, len = geom.length; i < len; i++) {
            oriEnd = geom[i][0];
            var angle = that._rotateAngle(oriStart, oriEnd);
            var points = [];
            points = that._pointsFromAngle([oriStart, oriEnd], angle);
            that._drawObliqueLine(ctx, points, angle);
            oriStart = geom[i][0];
        }
    },
    _drawObliqueLine: function (ctx, points, angle) {
        var len = Math.floor(this.distance(points[0], points[1]) / 20);
        ctx.lineWidth = 1;
        ctx.strokeStyle = '#FF0000';
        ctx.save();
        ctx.translate(points[0][0], points[0][1]);
        ctx.rotate(angle);
        ctx.beginPath();
        for (var i = 0; i < len; i++) {
            ctx.moveTo(i * 20, 0);
            ctx.lineTo(i * 20, -6);
        }
        // 最后一个点
        ctx.moveTo(points[1][0] - points[0][0], 0);
        ctx.lineTo(points[1][0] - points[0][0], -6);
        ctx.stroke();
        ctx.restore();
    },
    /**
     * 字体的旋转角度
     * @param startPoint
     * @param endPoint
     * @returns {*}
     * @private
     */
    _rotateAngle: function (startPoint, endPoint) {
        var angle;
        if ((startPoint[0] - endPoint[0]) === 0) {
            angle = Math.PI / 2;
        } else if ((startPoint[1] - endPoint[1]) === 0) {
            angle = 0;
        } else {
            angle = Math.atan((startPoint[1] - endPoint[1]) / (startPoint[0] - endPoint[0]));
        }
        return angle;
    },
    _showTextOfAngle: function (ctx, start, name, angle, textGeom, font, align) {
        var c = ctx.canvas;
        var g = c.getContext('2d');
        g.font = font || '10px Courier New';
        g.textAlign = align || 'center';
        var nameArr = name.split('');
        var PI = Math.PI;
        var end = nameArr.length;
        if (angle === 0) {
            g.fillText(name, textGeom[0], textGeom[1]);
            g.save();
        } else if ((angle < PI && angle > 2 * (PI / 5))) {
            for (var i = start; i < end; i++) {
                g.fillText(nameArr[i], textGeom[0], textGeom[1] + i * 13);
                g.save();
            }
        } else {
            var showName = name.substr(start, end);
            g.save();
            g.translate(textGeom[0], textGeom[1]);
            g.rotate(angle);
            g.fillText(showName, 0, 0);
            g.restore();
        }
    },
    // _drawConditionSpeedLimit: function (ctx, name, angle, textGeom, font, align) {
    _drawText: function (options) {
        var c = options.ctx.canvas;
        var g = c.getContext('2d');
        g.font = options.font ? options.font : '10px Courier New';
        g.textAlign = options.textAlign ? options.textAlign : 'center';
        g.save();
        g.translate(options.geo[0], options.geo[1]);
        if (options.rotate) {
            g.rotate(options.rotate);
        }
        // g.fillText(options.text, 0, 12 / 2);
        g.fillText(options.text, options.drawx, options.drawy);
        g.restore();
    },
    /** *
     * _drawArrow绘制方向箭头
     * @param {Object}ctx
     * @param {Number}direct 绘制方向
     * @param {Array}data 点数组
     * @private
     */
    _drawArrow: function (ctx, direct, data) {
        var g = ctx.canvas.getContext('2d');
        g.linewidth = 2;
        g.strokeStyle = '#ff0000';
        if (direct == 0 || direct == 1) {
            return;
        }
        for (var i = 0, len = data.length; i < len; i++) {
            for (var j = 0, len2 = data[i].length; j < len2 - 1; j += 2) {
                g.beginPath();
                g.translate(0, 0, 0);
                var point1 = data[i][j];
                var point2 = data[i][j + 1];
                var distance = this.distance(point1, point2);
                if (distance < 30) {
                    return;
                }
                g.save();
                var centerPoint = L.point((point1.x + point2.x) / 2, (point1.y + point2.y) / 2);
                g.translate(centerPoint.x, centerPoint.y);
                // 先计算向量与y轴负方向向量(0,-1)的夹角
                var ang = 0;
                if (point1.y - point2.y == 0) {
                    if (point1.x - point2.x > 0) {
                        ang = Math.PI / -2;
                    } else {
                        ang = Math.PI / 2;
                    }
                } else {
                    ang = (point1.x - point2.x) / (point1.y - point2.y);
                    ang = Math.atan(ang);
                }
                if (point2.y - point1.y >= 0) {
                    if (direct == 2) {
                        g.rotate(-ang);
                    } else if (direct == 3) {
                        g.rotate(-ang + Math.PI);
                    }
                } else if (direct == 2) {
                    g.rotate(Math.PI - ang); // 加个180度，反过来
                } else if (direct == 3) {
                    g.rotate(-ang);
                }
                g.lineTo(-3, -6);
                g.lineTo(0, 1);
                g.lineTo(3, -6);
                g.lineTo(0, 0);
                g.stroke();
                g.fill(); // 箭头是个封闭图形
                g.closePath();
                g.restore(); // 恢复到堆的上一个状态，其实这里没什么用。
            }
        }
    },
    /**
     * 画区域内的道路
     * @param ctx
     * @param points
     * @param dashLength
     * @param that
     * @private
     */
    _drawDashLineOfAngle: function (ctx, points, dashLength, that) {
        var endPoint;
        var startPoint = points[0][0];
        for (var i = 1, len = points.length; i < len; i++) {
            endPoint = points[i][0];
            var angle = that._rotateAngle(startPoint, endPoint);
            that._drawDashLine(ctx, [startPoint, endPoint], angle, dashLength, that);
            startPoint = points[i][0];
        }
    },
    /**
     * 画虚线
     * @param ctx
     * @param points
     * @param angle
     * @param dashLength
     * @param self
     * @private
     */
    _drawDashLine: function (ctx, points, angle, dashLength, self) {
        var pointsOfChange = self._pointsFromAngle(points, angle);
        ctx.lineWidth = 2;
        ctx.strokeStyle = 'red';
        var xPos = points[1][0] - points[0][0];
        var yPos = points[1][1] - points[0][1];
        var dash = Math.floor(Math.sqrt(xPos * xPos + yPos * yPos) / dashLength);
        ctx.save();
        ctx.translate(pointsOfChange[0][0], pointsOfChange[0][1]);
        ctx.rotate(angle);
        ctx.beginPath();
        for (var i = 0; i < dash; i++) {
            if (i % 2) {
                ctx.lineTo(dashLength * i, 0);
            } else {
                ctx.moveTo(dashLength * i, 0);
            }
        }
        ctx.stroke();
        ctx.restore();
    },
    /** *
     * 绘制线
     * @param {Object}ctx {canvas: canvas,tile: tilePoint,zoom: zoom}
     * @param {Array}geom 绘制几何对象
     * @param {Object}style 样式
     * @param {Boolean}boolPixelCrs 是否像素坐标
     * @private
     */
    _drawLineString: function (ctx, geom, boolPixelCrs, linestyle, nodestyle, properties) {
        if (!linestyle) {
            return;
        }
        var proj = [];
        var coords = this._clip(ctx, geom);
        for (var i = 0; i < coords.length; i++) {
            // if (this._map.getZoom() >= this.showNodeLevel && (i == 0 || i == coords.length - 1)) {
            //    this._drawPoint(ctx, coords[i], nodestyle, true);
            // }
            if (boolPixelCrs) {
                proj.push({
                    x: coords[i][0],
                    y: coords[i][1]
                });
            } else {
                proj.push(this._tilePoint(ctx, coords[i]));
            }
        }
        var g = ctx.canvas.getContext('2d');
        g.strokeStyle = linestyle.strokeColor;
        g.lineWidth = linestyle.strokeWidth;
        g.globalAlpha = linestyle.strokeOpacity || 1; // Opacity
        g.lineCap = linestyle.lineCap || 'butt';
        g.beginPath();
        for (var j = 0; j < proj.length; j++) {
            var method = (j === 0 ? 'move' : 'line') + 'To';
            g[method](proj[j].x, proj[j].y);
        }
        g.stroke();
        g.restore();
        if (properties.hasOwnProperty('symbol')) {
            // 如果有symbol，则使用符号绘制
            this._drawLineStringWithSymbol(ctx, geom, boolPixelCrs, properties.symbol);
        }
    },
    /** *
     * 根据指定的符号名绘制线
     * @param {Object}ctx {canvas: canvas,tile: tilePoint,zoom: zoom}
     * @param {Array}geom 绘制几何对象
     * @param {Boolean}boolPixelCrs 是否像素坐标
     * @symbol {Array}style 符号
     * @private
     */
    _drawLineStringWithSymbol: function (ctx, geom, boolPixelCrs, symbol) {
        if (!symbol) {
            return;
        }
        var geometry = [];
        // coords = this._clip(ctx, geom);
        for (var i = 0; i < geom.length; i++) {
            if (boolPixelCrs) {
                geometry.push([geom[i][0], geom[i][1]]);
            } else {
                var point = this._tilePoint(ctx, geom[i]);
                geometry.push([point.x, point.y]);
            }
        }
        var lsGeometry = new fastmap.mapApi.symbol.LineString(geometry);
        var g = ctx.canvas.getContext('2d');
        symbol.geometry = lsGeometry;
        symbol.draw(g);
    },
    /** *
     * 绘制polygon
     * @param {Object}ctx {canvas: canvas,tile: tilePoint,zoom: zoom}
     * @param {Array}geom 几何对象
     * @param {Object}style 样式
     * @private
     */
    _drawPolygon: function (ctx, geom, style, boolPixelCrs) {
        if (!style) {
            return;
        }
        var coords = geom[0];
        var proj = [];
        var i;
        coords = this._clip(ctx, coords);
        for (i = 0; i < coords.length; i++) {
            if (boolPixelCrs) {
                proj.push({
                    x: coords[i][0],
                    y: coords[i][1]
                });
            } else {
                proj.push(this._tilePoint(ctx, coords[i]));
            }
        }
        var g = ctx.canvas.getContext('2d');
        g.globalAlpha = style.fillOpacity;
        g.fillStyle = style.fillColor;
        if (style.strokeWidth > 0) {
            g.strokeStyle = style.strokeColor;
            g.lineWidth = style.strokeWidth;
        }
        g.beginPath();
        for (i = 0; i < proj.length; i++) {
            var method = (i === 0 ? 'move' : 'line') + 'To';
            g[method](proj[i].x, proj[i].y);
        }
        g.closePath();
        g.fill();
        if (style.strokeWidth > 0) {
            g.stroke();
        }
    },
    /** 互联网rtic*/
    _drawrdrtic: function (ctx, geom, properties, boolPixelCrs) {
        var direct = null;
        var stolecolor = null;
        var reversecolor = null;
        var coords = geom;
        var proj = [];
        var arrowlist = [];
        coords = this._clip(ctx, coords);
        for (var rtic = 0; rtic < coords.length; rtic++) {
            if (boolPixelCrs) {
                proj.push({
                    x: coords[rtic][0][0],
                    y: coords[rtic][0][1]
                });
            } else {
                proj.push(this._tilePoint(ctx, coords[rtic]));
            }
        }
        var g = ctx.canvas.getContext('2d');
        for (var rticj = 0; rticj < proj.length; rticj++) {
            var method = (rticj === 0 ? 'move' : 'line') + 'To';
            g[method](proj[rticj].x, proj[rticj].y);
            if (rticj < proj.length - 1) {
                var oneArrow = [proj[rticj], proj[rticj + 1]];
                arrowlist.push(oneArrow);
            }
        }
        if (properties.forwardLevel == 0) {
            stolecolor = '#808080'; // 灰色
        } else if (properties.forwardLevel == 1) {
            stolecolor = '#FF0000'; // 红色
        } else if (properties.forwardLevel == 2) {
            stolecolor = '#006400'; // 绿色
        } else if (properties.forwardLevel == 3) {
            stolecolor = '#00008B'; // 蓝色
        } else if (properties.forwardLevel == 4) {
            stolecolor = '#FF1493'; // 粉色
        }
        if (properties.reverseLevel == 0) {
            reversecolor = '#808080'; // 灰色
        } else if (properties.reverseLevel == 1) {
            reversecolor = '#FF0000'; // 红色
        } else if (properties.reverseLevel == 2) {
            reversecolor = '#006400'; // 绿色
        } else if (properties.reverseLevel == 3) {
            reversecolor = '#00008B'; // 蓝色
        } else if (properties.reverseLevel == 4) {
            reversecolor = '#FF1493'; // 粉色
        }
        if (properties.forwardLevel && properties.reverseLevel) {
            if (this._map.getZoom() >= this.showNodeLevel) {
                this._drawIntRticArrow(g, 2, arrowlist, stolecolor);
                this._drawIntRticArrow(g, 3, arrowlist, reversecolor);
                this._drawIntRticText(ctx, geom, properties.forwardInformation + '上', 2);
                this._drawIntRticText(ctx, geom, properties.reverseInformation + '下', 3);
            }
        } else {
            if (properties.forwardLevel) {
                direct = 2; // 顺方向
            } else if (properties.reverseLevel) {
                direct = 3; // 逆方向
            }
            if (direct && this._map.getZoom() >= this.showNodeLevel) {
                this._drawIntRticArrow(g, direct, arrowlist, (direct == 2 ? stolecolor : reversecolor));
                if (direct === 2) {
                    this._drawIntRticText(ctx, geom, properties.forwardInformation + '上', 2);
                }
                if (direct === 3) {
                    this._drawIntRticText(ctx, geom, properties.reverseInformation + '下', 3);
                }
            }
        }
    },
    /** *
     * _drawArrow绘制方向箭头
     * @param {Object}ctx
     * @param {Number}direct 绘制方向
     * @param {Array}data 点数组
     * * @param colors 点数组
     * @private
     */
    _drawIntRticArrow: function (elem, direct, data, colors) {
        var ctx = elem.canvas.getContext('2d');
        ctx.linewidth = 2;
        ctx.fillStyle = colors;
        if (direct == 0 || direct == 1) {
            return;
        }
        ctx.beginPath();
        var point1,
            point2;
        if (direct === 2) {
            point1 = data[data.length - 1][0];
            point2 = data[data.length - 1][1];
        } else if (direct === 3) {
            point1 = data[0][0];
            point2 = data[0][1];
        }
        var distance = this.distance(point1, point2);
        if (distance < 30) {
            return;
        }
        ctx.save();
        // var centerPoint = L.point((point1.x + point2.x) / 2, (point1.y + point2.y) / 2);
        var centerPoint;
        if (direct == 2) {
            centerPoint = L.point(point2.x, point2.y);
        } else {
            centerPoint = L.point(point1.x, point1.y);
        }
        ctx.translate(centerPoint.x, centerPoint.y);
        // 先计算向量与y轴负方向向量(0,-1)的夹角
        var ang = 0;
        if (point1.y - point2.y == 0) {
            if (point1.x - point2.x > 0) {
                ang = Math.PI / -2;
            } else {
                ang = Math.PI / 2;
            }
        } else {
            ang = (point1.x - point2.x) / (point1.y - point2.y);
            ang = Math.atan(ang);
        }
        if (point2.y - point1.y >= 0) {
            if (direct == 2) {
                ctx.rotate(-ang);
            } else if (direct == 3) {
                ctx.rotate(-ang + Math.PI);
            }
        } else if (direct == 2) {
            ctx.rotate(Math.PI - ang); // 加个180度，反过来
        } else if (direct == 3) {
            ctx.rotate(-ang);
        }
        ctx.lineTo(-6, -9);
        ctx.lineTo(0, 1);
        ctx.lineTo(6, -9);
        ctx.stroke();
        ctx.fill(); // 箭头是个封闭图形
        ctx.closePath();
        ctx.restore(); // 恢复到堆的上一个状态，其实这里没什么用。
    },
    _drawIntRticText: function (ctx, geom, name, direct) {
        geom = this._clip(ctx, geom);
        var c = ctx.canvas;
        var g = c.getContext('2d');
        g.font = '10px Courier New';
        g.textAlign = 'center';
        var angle;
        var nameArr = name.split('');
        var nameLen = name.length * 10;
        var lineLen = 0;
        if (geom.length === 2) {
            angle = this._rotateAngle(geom[0], geom[1]);
            lineLen = this.distance(geom[0], geom[1]);
            if (nameLen < lineLen / 2 && lineLen > 160) {
                this._showIntRticTextOfAngle(g, 0, nameArr.length, name, angle, [(geom[0][0] + geom[1][0]) / 2, (geom[0][1] + geom[1][1]) / 2], direct);
            }
        } else {
            var startPoint = geom[0];
            var startPointForLen = geom[0];
            var endPoint = geom[geom.length - 1];
            var textLength = 0;
            var startText = 0;
            var textIndex = 0;
            var betPointsLen;
            var realLineLen = 0;
            var linkArrLen = geom.length;
            for (var m = 1; m < linkArrLen; m++) {
                betPointsLen = this.distance(geom[m], startPointForLen);
                realLineLen += betPointsLen;
                startPointForLen = geom[m];
            }
            if (nameLen < realLineLen / 2 && realLineLen > 50) {
                startPoint = geom[1];
                for (var linkFLag = 1; linkFLag < linkArrLen; linkFLag++) {
                    if (textLength < nameArr.length) {
                        betPointsLen = this.distance(geom[linkFLag], startPoint);
                        angle = this._rotateAngle(startPoint, geom[linkFLag]);
                        if (betPointsLen > 10) {
                            textIndex = parseInt(betPointsLen / 10, 10);
                            this._showIntRticTextOfAngle(g, 0, nameArr.length, name, angle, startPoint, direct);
                            break;
                        } else {
                            startPoint = geom[linkFLag];
                        }
                    }
                }
            }
        }
    },
    _showIntRticTextOfAngle: function (ctx, start, end, name, angle, textGeom, direct) {
        var nameArr = name.split('');
        var PI = Math.PI;
        if (angle === 0) {
            if (direct === 2) {
                ctx.fillText(name, textGeom[0], textGeom[1] - 10);
            } else {
                ctx.fillText(name, textGeom[0], textGeom[1] + 13);
            }
            ctx.save();
        } else if ((angle < PI && angle > 2 * (PI / 5))) {
            if (direct === 2) {
                for (var l = start; l < end; l++) {
                    ctx.fillText(nameArr[l], textGeom[0] - 8, textGeom[1] + l * 14);
                    ctx.save();
                }
            } else {
                for (var i = start; i < end; i++) {
                    ctx.fillText(nameArr[i], textGeom[0] + 8, textGeom[1] + i * 14);
                    ctx.save();
                }
            }
        } else {
            var showName = name.substr(start, end);
            ctx.save();
            if (direct === 2) {
                ctx.translate(textGeom[0], textGeom[1] - 10);
            } else {
                ctx.translate(textGeom[0], textGeom[1] + 13);
            }
            ctx.rotate(angle);
            ctx.fillText(showName, 0, 0);
            ctx.restore();
        }
    },
    /**
     *行政区划画点画线
     * @param ctx
     * @param geom
     * @param boolPixelCrs
     * @param linestyle
     * @param nodestyle
     * @param properties
     * @private
     */
    _drawAdLineString: function (ctx, geom, boolPixelCrs, linestyle, nodestyle, properties) {
        if (!linestyle) {
            return;
        }
        var coords = geom;
        var proj = [];
        var arrowlist = [];
        coords = this._clip(ctx, coords);
        for (var i = 0; i < coords.length; i++) {
            if (this._map.getZoom() >= this.showNodeLevel && (i == 0 || i == coords.length - 1)) {
                if (i == 0) {
                    this._drawCircle(ctx, coords[i][0], nodestyle, true);
                } else if (coords[0][0][0] != coords[coords.length - 1][0][0] && coords[0][0][1] != coords[coords.length - 1][0][1]) {
                    this._drawCircle(ctx, coords[coords.length - 1][0], nodestyle, true);
                }
            }
            if (boolPixelCrs) {
                proj.push({
                    x: coords[i][0][0],
                    y: coords[i][0][1]
                });
            } else {
                proj.push(this._tilePoint(ctx, coords[i]));
            }
        }
        var g = ctx.canvas.getContext('2d');
        g.strokeStyle = linestyle.color;
        g.lineWidth = linestyle.size;
        g.beginPath();
        for (var j = 0; j < proj.length; j++) {
            var method = (j === 0 ? 'move' : 'line') + 'To';
            g[method](proj[j].x, proj[j].y);
        }
        g.stroke();
        g.restore();
    }
};

/**
 * Created by zhongxiaoming on 2015/9/6.
 * Class canvas瓦片图层
 */
fastmap.mapApi.TileJSON = L.TileLayer.Canvas.extend({
    options: {
        debug: true
    },
    includes: [L.Mixin.Events, fastmap.mapApi.LayerRender],
    tileSize: 256,
    /** *
     *
     * @param {Object}options
     */
    initialize: function (url, options) {
        this.options = this.options || {};
        L.Util.setOptions(this, options);
        this.url = url;
        this.style = this.options.style || '';
        this.type = this.options.type || '';
        this.editable = this.options.editable || '';
        this.requestType = this.options.requestType || '';
        this.gap = this.options.gap || 30;
        this.tiles = {};
        this.directColor = this.options.directColor || '#ff0000';
        this.mecator = this.options.mecator || '';
        this.clickFunction = this.options.clickFunction || null;
        this.eventController = fastmap.uikit.EventController();
        this.redrawTiles = [];
        this.options.async = true;
        this.drawTile = function (canvas, tilePoint, zoom) {
            var ctx = {
                canvas: canvas,
                tile: tilePoint,
                zoom: zoom
            };
            if (this.options.debug) {
                this._drawDebugInfo(ctx);
            }
            this._draw(ctx, this.options.boolPixelCrs, this.options.parse);
        };
        // by chenx on 2016-9-23:打印瓦片图层加载时间，调试效率的时候用，正常情况下可以注释掉
        // this.on('loading', function() {
        //     this._beginTime = new Date().getTime();
        // });
        // var that = this;
        // this.on('load', function() {
        //     var endTime = new Date().getTime();
        //     var cnt = 0,
        //         dataCnt = 0;
        //     for (var key in that.tiles) {
        //         if (that.tiles[key].data.length) {
        //             dataCnt += that.tiles[key].data.length;
        //         }
        //         cnt++;
        //     }
        //     console.log('------Tilelayer load info:' + this._beginTime + '|' + endTime + '|' +
        // cnt + '|' + dataCnt); });
    },
    redraw: function () {
        if (this._map) {
            this._reset({
                hard: true
            });
            this._update();
        }
        return this;
    },
    _redrawTile: function (tile) {
        this.drawTile(tile, tile._tilePoint, this._map._zoom);
    },
    /** *
     * 根据瓦片id移除瓦片
     * @param {String}key
     * @private
     */
    _removeTile: function (key) {
        var tile = this._tiles[key];
        this.fire('tileunload', {
            tile: tile,
            url: tile.src
        });
        if (this.options.reuseTiles) {
            L.DomUtil.removeClass(tile, 'leaflet-tile-loaded');
            this._unusedTiles.push(tile);
        } else if (tile.parentNode === this._tileContainer) {
            this._tileContainer.removeChild(tile);
        }
        // for https://github.com/CloudMade/Leaflet/issues/137
        if (!L.Browser.android) {
            tile.onload = null;
            tile.src = L.Util.emptyImageUrl;
        }
        if (this.tiles[key] !== undefined) {
            this.tiles[key].xmlhttprequest.abort();
        }
        delete this.tiles[key];
        delete this._tiles[key];
    },
    /** *
     * 重置图层
     * @param {Object}e
     * @private
     */
    _reset: function (e) {
        for (var key in this._tiles) {
            if (!this._tiles.hasOwnProperty(key)) {
                continue;
            }
            this.fire('tileunload', {
                tile: this._tiles[key]
            });
            if (this.tiles[key] !== undefined) {
                this.tiles[key].xmlhttprequest.abort();
            }
            delete this.tiles[key];
        }
        this._tiles = {};
        this._tilesToLoad = 0;
        if (this.options.reuseTiles) {
            this._unusedTiles = [];
        }
        this._tileContainer.innerHTML = '';
        if (this._animated && e && e.hard) {
            this._clearBgBuffer();
        }
        this._initContainer();
    },
    /** *
     * 打印调试信息
     * @param {Object}ctx
     * @private
     */
    _drawDebugInfo: function (ctx) {
        var max = this.tileSize;
        var g = ctx.canvas.getContext('2d');
        g.strokeStyle = '#000000';
        g.fillStyle = '#FFFF00';
        g.strokeRect(0, 0, max, max);
        g.font = '12px Arial';
        g.fillRect(0, 0, 5, 5);
        g.fillRect(0, max - 5, 5, 5);
        g.fillRect(max - 5, 0, 5, 5);
        g.fillRect(max - 5, max - 5, 5, 5);
        g.fillRect(max / 2 - 5, max / 2 - 5, 10, 10);
        g.strokeText(ctx.tile.x + ' ' + ctx.tile.y + ' ' + ctx.zoom, max / 2 - 30, max / 2 - 10);
    },
    /** *
     * 计算tilepoint
     * @param {Object}ctx  {canvas: canvas,tile: tilePoint,zoom: zoom}
     * @param {Array}coords 坐标
     * @returns {{x: number, y: number}}
     * @private
     */
    _tilePoint: function (ctx, coords) {
        // start coords to tile 'space'
        var s = ctx.tile.multiplyBy(this.tileSize);
        // actual coords to tile 'space'
        var p = this._map.project(new L.LatLng(coords[1], coords[0]));
        // point to draw
        var x = Math.round(p.x - s.x);
        var y = Math.round(p.y - s.y);
        return {
            x: x,
            y: y
        };
    },
    /** *
     *  根据鼠标坐标计算所处的瓦片编号
     * @param coords
     */
    mousePointToTilepoint: function (coords) {
        var p = this._map.project(new L.LatLng(coords[1], coords[0]));
        return p.divideBy(this.tileSize, false);
    },
    /** *
     *
     * @param {Object}ctx {canvas: canvas,tile: tilePoint,zoom: zoom}
     * @param {Array}points 计算瓦片范围内的点
     * @returns {Array}
     * @private
     */
    _clip: function (ctx, points) {
        var nw = ctx.tile.multiplyBy(this.tileSize);
        var se = nw.add(new L.Point(this.tileSize, this.tileSize));
        var bounds = new L.Bounds([nw, se]);
        var len = points.length;
        var out = [];
        for (var i = 0; i < len - 1; i++) {
            var seg = L.LineUtil.clipSegment(points[i], points[i + 1], bounds, i);
            if (!seg) {
                continue;
            }
            out.push(seg[0]);
            // if segment goes out of screen, or it's the last one, it's the end of the line part
            if ((seg[1] !== points[i + 1]) || (i === len - 2)) {
                out.push(seg[1]);
            }
        }
        return out;
    },
    /** *
     * 计算点是否可见
     * @param {Array}coords
     * @returns {boolean}
     * @private
     */
    _isActuallyVisible: function (coords) {
        var coord = coords[0];
        var min = [coord.x, coord.y];
        var max = [coord.x, coord.y];
        for (var i = 1; i < coords.length; i++) {
            coord = coords[i];
            min[0] = Math.min(min[0], coord.x);
            min[1] = Math.min(min[1], coord.y);
            max[0] = Math.max(max[0], coord.x);
            max[1] = Math.max(max[1], coord.y);
        }
        var diff0 = max[0] - min[0];
        var diff1 = max[1] - min[1];
        // if (this.options.debug) {
        //    console.log(diff0 + ' ' + diff1);
        // }
        var visible = diff0 > 1 || diff1 > 1;
        return visible;
    },
    /**
     * 为了兼容返回的数据不是geojson的形式的情况，增加了一个parse参数处理返回数据
     * @param {Object}ctx
     * @param {Boolean}boolPixelCrs
     * @param parse
     * @private
     */
    _draw: function (ctx, boolPixelCrs, parse) {
        //
        this.options.zoomlevel = this._map;
        var nwPoint = ctx.tile.multiplyBy(this.tileSize);
        var sePoint = nwPoint.add(new L.Point(this.tileSize, this.tileSize));
        // optionally, enlarge request area.
        // with this I can draw points with coords outside this tile area,
        // but with part of the graphics actually inside this tile.
        // NOTE: that you should use this option only if you're actually drawing points!
        var buf = this.options.buffer;
        if (buf > 0) {
            var diff = new L.Point(buf, buf);
            nwPoint = nwPoint.subtract(diff);
            sePoint = sePoint.add(diff);
        }
        var nwCoord = this._map.unproject(nwPoint, ctx.zoom, true);
        var seCoord = this._map.unproject(sePoint, ctx.zoom, true);
        var bounds = [nwCoord.lng, seCoord.lat, seCoord.lng, nwCoord.lat];
        var url = this.createUrl(bounds);
        if (!url) { // 如果url未定义的话，不请求
            this.tileDrawn(ctx.canvas);
            return;
        }
        this.key = ctx.tile.x + ':' + ctx.tile.y;
        var zoom = this._map.getZoom();
        var self = this;
        this.tileobj = fastmap.mapApi.tile(url);
        this.tileobj.options.context = ctx.canvas;
        this.tiles[this.key] = this.tileobj;
        var options = {
            url: url,
            responseType: 'json',
            onSuccess: this._onAjaxSuccess,
            parameter: {
                self: self,
                key: this.key,
                zoom: zoom,
                parse: parse,
                ctx: ctx
            }
        };
        this.request = fastmap.mapApi.ajax.get(options);
        this.tiles[this.key].setRequest(this.request);
    },
    _onAjaxSuccess: function (json, parameter) {
        var self = parameter.self;
        var key = parameter.key;
        var zoom = parameter.zoom;
        var parse = parameter.parse;
        var ctx = parameter.ctx;
        var data = parse(json.data, key, zoom);
        self.tiles[key].setData(data);
        var urls = self._getDependencyResource(data);
        var loader = new fastmap.mapApi.symbol.ImageLoader(urls);
        loader.load(function () {
            self._drawFeature(data, ctx);
            self.tileDrawn(ctx.canvas);
        });
    },
    /** *
     * 绘制要素
     * @param data data绘制的数据
     * @param {Object}ctx {canvas: canvas,tile: tilePoint,zoom: zoom}
     * @param {Boolean}boolPixelCrs 是否像素坐标
     * @private
     */
    _drawFeature: function (data, ctx, boolPixelCrs) {
        for (var i = 0; i < data.length; i++) {
            var feature = data[i];
            var symbol = feature.properties.symbol;
            if (!symbol) {
                continue;
            }

            var g = ctx.canvas.getContext('2d');
            if (FM.Util.isArray(symbol)) {
                this._drawSymbolArray(g, symbol);
            } else {
                symbol.draw(g);
            }
        }
        this.eventController.fire(this.eventController.eventTypes.TILEDRAWEND, {
            layer: this,
            id: ctx.tile.x + ':' + ctx.tile.y,
            zoom: ctx.zoom
        });
    },
    _drawSymbolArray: function (g, array) {
        array.forEach(function (item) {
            item.draw(g);
        });
    },
    _getDependencyResource: function (data) {
        var urls = [];
        for (var i = 0; i < data.length; i++) {
            var feature = data[i];
            var symbol = feature.properties.symbol;
            if (!symbol) {
                continue;
            }

            if (FM.Util.isArray(symbol)) {
                urls = urls.concat(this._getUrlsFromSymbolArray(symbol));
            } else {
                var symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();
                urls = urls.concat(symbolFactory.getUrlsFromSymbol(symbol));
            }
        }

        return urls;
    },
    _getUrlsFromSymbolArray: function (symbols) {
        var symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();
        var urls = [];
        for (var i = 0; i < symbols.length; i++) {
            var symbol = symbols[i];
            var symbolUrls = symbolFactory.getUrlsFromSymbol(symbol);
            urls = urls.concat(symbolUrls);
        }

        return urls;
    },
    /** *
     * 根据瓦片bounds构建url
     * @param {Array}bounds 瓦片bounds
     * @returns url
     */
    createUrl: function (bounds) {
        var tiles = this.mecator.lonlat2Tile((bounds[0] + bounds[2]) / 2, (bounds[1] + bounds[3]) / 2, this._map.getZoom());
        var tempUrl = null;
        if (this.options.subdomains && this.options.id != 'highlightLayer' && this.options.id != 'mousemovelightlayer') {
            tempUrl = L.Util.template(this.url.url, { s: this._getSubdomain(L.point(tiles[0], tiles[1])) });
        }
        var parameter = null;
        if (this.url != '') {
            if (this._map.getZoom() >= this.options.minZoom && this._map.getZoom() <= this.options.maxZoom) {
                parameter = this.url.parameter;
                if (parameter != null) {
                    parameter.z = this._map.getZoom();
                    parameter.x = tiles[0];
                    parameter.y = tiles[1];
                }
                tempUrl = tempUrl + 'parameter=' + JSON.stringify(parameter);
            }
        }
        return tempUrl;
    },
    // 两点之间的距离
    distance: function (pointA, pointB) {
        var len;
        if (pointA.x) {
            len = Math.pow((pointA.x - pointB.x), 2) + Math.pow((pointA.y - pointB.y), 2);
        } else {
            len = Math.pow((pointA[0] - pointB[0]), 2) + Math.pow((pointA[1] - pointB[1]), 2);
        }
        return Math.sqrt(len);
    }
});
fastmap.mapApi.TileJSON.addInitHook(function () {
    this.isVisiable = this.options.visible;
    this.isSelectable = this.options.selectable;
});
fastmap.mapApi.tileJSON = function (url, options) {
    return new fastmap.mapApi.TileJSON(url, options);
};

/**
 * Created by zhongxiaoming on 2015/10/19
 * Class EditLayer 可编辑层
 */
fastmap.mapApi.EditLayer = fastmap.mapApi.WholeLayer.extend({
    /**
     * 事件管理器
     * @property includes
     */
    includes: L.Mixin.Events,

    /** *
     * 初始化可选参数
     * @param {Object}options
     */
    initialize: function (url, options) {
        this.options = options || {};
        this.url = url;
        fastmap.mapApi.WholeLayer.prototype.initialize(this, options);
        this.eventController = fastmap.uikit.EventController();
        this.minShowZoom = this.options.minShowZoom || 9;
        this.maxShowZoom = this.options.maxShowZoom || 18;
        this.eventController = fastmap.uikit.EventController();
        this.initEvent();
        this.drawGeometry = null;
    },

    initEvent: function () {
        var that = this;
        this.shapeEditor = fastmap.uikit.ShapeEditorController();

        this.eventController.on(this.eventController.eventTypes.SNAPED, function (event) {
            that.snaped = event.snaped;
        });
        function delegateDraw(event) {
            that.selectCtrl = fastmap.uikit.SelectController();
            if (that.shapeEditor.shapeEditorResult == null) {
                return;
            }
            that.drawGeometry = that.shapeEditor.shapeEditorResult.getFinalGeometry();
            that.clear();
            that.draw(that.drawGeometry, that, event.index);
            if (that.snaped == true) {
                var crosspoint = (event.index != null && that.drawGeometry && that.drawGeometry.components[event.index]) ? that.drawGeometry.components[event.index] : event.point;
                if (crosspoint != undefined) {
                    crosspoint = fastmap.mapApi.point(crosspoint.x, crosspoint.y);
                    crosspoint.type = 'Cross';
                    that.draw(crosspoint, that);
                }
            }
        }
        this.eventController.on(this.eventController.eventTypes.STARTSHAPEEDITRESULTFEEDBACK, delegateDraw);


        this.eventController.on(this.eventController.eventTypes.STOPSHAPEEDITRESULTFEEDBACK, function () {
            that.map._container.style.cursor = '';

            var coordinate1 = [];
            if (that.drawGeometry) {
                if (that.drawGeometry.components) {
                    var keys = Object.getOwnPropertyNames(that.drawGeometry.components);
                    for (var j = 0; j < keys.length; j++) {
                        var index = keys[j];
                        coordinate1.push([that.drawGeometry.components[index].x, that.drawGeometry.components[index].y]);
                    }
                }
                that._redraw();
            }
        });

        this.eventController.on(this.eventController.eventTypes.ABORTSHAPEEDITRESULTFEEDBACK, function () {
            that.drawGeometry = that.shapEditor.shapeEditorResult.getOriginalGeometry();
            that.shapEditor.shapeEditorResult.setFinalGeometry(that.drawGeometry.clone());
            that._redraw();
        });
    },
    /** *
     * 图层添加到地图时调用
     * @param{L.Map} map
     */
    onAdd: function (map) {
        this.map = map;
        this._initContainer(this.options);
        map.on('moveend', this._redraw, this);
        this._redraw();
    },

    /** *
     * 图层被移除时调用
     * @param {L.Map}map
     */
    onRemove: function (map) {
        map.getPanes().tilePane.removeChild(this._div);
        map.off('moveend', this._redraw, this);
    },

    /** *
     * 绘制几何图形
     * @param currentGeo 当前几何
     * @param self
     * @param index 鼠标拖动的当前点
     */
    draw: function (currentGeo, self, index) {
        // this.clear();
        if (!currentGeo) {
            return;
        }

        function drawPoint(geom, style, boolPixelCrs) {
            if (!geom) {
                return;
            }
            var p = null;
            if (boolPixelCrs) {
                p = { x: geom.x, y: geom.y };
            } else {
                p = this.map.latLngToContainerPoint([geom.y, geom.x]);
            }

            var g = self._ctx;
            g.beginPath();
            g.fillStyle = style.color;
            g.arc(p.x, p.y, style.radius, 0, Math.PI * 2);
            g.closePath();
            g.fill();
            g.restore();
        }

        function drawArrow(ctx, direct, data, self1) {
            var g = ctx.canvas.getContext('2d');
            g.linewidth = 2;
            g.strokeStyle = '#ff0000';
            if (direct == 0 || direct == 1) {
                return;
            }

            for (var i = 0, len = data.length; i < len; i++) {
                for (var j = 0, len2 = data[i].length; j < len2 - 1; j += 2) {
                    g.beginPath();
                    g.translate(0, 0, 0);

                    var point1 = data[i][j];
                    var point2 = data[i][j + 1];
                    var distance = self1.distance(point1, point2);
                    if (distance < 20) {
                        break;
                    }

                    g.save();
                    var centerPoint = L.point((point1.x + point2.x) / 2, (point1.y + point2.y) / 2);

                    g.translate(centerPoint.x, centerPoint.y);
                    // 先计算向量与y轴负方向向量(0,-1)的夹角


                    var ang = 0;
                    if (point1.y - point2.y == 0) {
                        if (point1.x - point2.x > 0) {
                            ang = Math.PI / -2;
                        } else {
                            ang = Math.PI / 2;
                        }
                    } else {
                        ang = (point1.x - point2.x) / (point1.y - point2.y);
                        ang = Math.atan(ang);
                    }
                    if (point2.y - point1.y >= 0) {
                        if (direct == 2) {
                            g.rotate(-ang);
                        } else if (direct == 3) {
                            g.rotate(-ang + Math.PI);
                        }
                    } else if (direct == 2) {
                        g.rotate(Math.PI - ang); // 加个180度，反过来
                    } else if (direct == 3) {
                        g.rotate(-ang);
                    }
                    g.lineTo(-6, -12);
                    g.lineTo(0, 2);
                    g.lineTo(6, -12);
                    g.lineTo(0, 0);
                    g.stroke();
                    g.fill(); // 箭头是个封闭图形
                    g.closePath();
                    g.restore();   // 恢复到堆的上一个状态，其实这里没什么用。
                }
            }
        }

        function drawLineString(geom, direct, style, boolPixelCrs, index1, boolnode, boolselectnode, self1) {
            if (!geom) {
                return;
            }

            var proj = [];
            var i;

            for (i = 0; i < geom.length; i++) {
                if (boolPixelCrs) {
                    proj.push({ x: geom[i].x, y: geom[i].y });
                } else {
                    proj.push(this.map.latLngToContainerPoint([geom[i].y, geom[i].x]));

                    if (boolselectnode && self1.selectCtrl) {
                        if (self1.selectCtrl.selectedFeatures.latlng && self1.selectCtrl.selectedFeatures.latlng.lat == geom[i].y && self1.selectCtrl.selectedFeatures.latlng.lng == geom[i].x) {
                            drawPoint(this.map.latLngToContainerPoint([geom[i].y, geom[i].x]), {
                                color: 'blue',
                                radius: 4
                            }, true);
                        }
                    } else if (i == 0 || i == geom.length - 1) {
                        drawPoint(this.map.latLngToContainerPoint([geom[i].y, geom[i].x]), {
                            color: 'red',
                            radius: 4
                        }, true);
                    } else if (!boolnode) {
                        drawPoint(this.map.latLngToContainerPoint([geom[i].y, geom[i].x]), {
                            color: 'blue',
                            radius: 4
                        }, true);
                    }
                }
            }

            var g = self1._ctx;
            g.strokeStyle = style.color;
            g.lineWidth = style.size;
            // g.opacity = 0.5;
            g.beginPath();
            for (i = 0; i < proj.length; i++) {
                var method = (i === 0 ? 'move' : 'line') + 'To';
                g[method](proj[i].x, proj[i].y);
            }
            g.stroke();
            g.restore();
            if (direct == 2 || direct == 3) {
                var coords = proj;
                var arrowList = [];
                for (var k = 0; k < coords.length; k++) {
                    if (k < coords.length - 1) {
                        var oneArrow = [{ x: coords[k].x, y: coords[k].y }, {
                            x: coords[k + 1].x,
                            y: coords[k + 1].y
                        }];
                        arrowList.push(oneArrow);
                    }
                }
                drawArrow(self1._ctx, direct, arrowList, self1);
            }
        }

        function drawCross(geom, style, boolPixelCrs, self1) {
            if (!geom) {
                return;
            }
            var p = null;
            if (boolPixelCrs) {
                p = { x: geom.x, y: geom.y };
            } else {
                p = this.map.latLngToContainerPoint([geom.y, geom.x]);
            }

            var verLineArr = [{ x: p.x, y: p.y + 20 }, { x: p.x, y: p.y - 20 }];
            drawLineString(verLineArr, null, { color: 'blue', size: 1 }, true, null, null, null, self1);
            var horLineArr = [{ x: p.x - 20, y: p.y }, { x: p.x + 20, y: p.y }];
            drawLineString(horLineArr, null, { color: 'blue', size: 1 }, true, null, null, null, self1);
        }
        function drawGSC(geom, style, boolPixelCrs, self1) {
            if (!geom) {
                return;
            }
            geom.conPoints = [];
            for (var i = 0; i < geom.length; i++) {
                var p = null;
                var q = null;
                if (boolPixelCrs) {
                    p = { x: geom[i][0].x, y: geom[i][0].y };
                    q = { x: geom[i][geom[i].length - 1].x, y: geom[i][geom[i].length - 1].y };
                } else {
                    p = this.map.latLngToContainerPoint([geom[i][0].y, geom[i][0].x]);
                    q = this.map.latLngToContainerPoint([geom[i][geom[i].length - 1].y, geom[i][geom[i].length - 1].x]);
                }
                geom.conPoints.push([{ x: p.x, y: p.y }, { x: q.x, y: q.y }]);
                var verLineArr = [{ x: p.x, y: p.y }, { x: q.x, y: q.y }];
                drawLineString(verLineArr, null, { color: style[i], size: 4 }, true, null, null, null, self1);
            }
        }

        function drawBuffer(geom, width, self1) {
            var proj = [];
            var method;
            this.transform = new fastmap.mapApi.MecatorTranform();
            var scale = this.transform.scale(map);
            var linkWidth = parseFloat(width * scale);
            linkWidth = linkWidth.toFixed(2);
            for (var i = 0; i < geom.length; i++) {
                proj.push(this.map.latLngToContainerPoint([geom[i].y, geom[i].x]));
            }
            var ctx = self1._ctx;
            ctx.lineWidth = width * 2;
            ctx.save();
            ctx.beginPath();
            ctx.lineCap = 'round';
            for (i = 0; i < proj.length; i++) {
                method = (i === 0 ? 'move' : 'line') + 'To';
                ctx[method](proj[i].x, proj[i].y);
            }
            ctx.stroke();
            for (i = 0; i < proj.length; i++) {
                method = (i === 0 ? 'move' : 'line') + 'To';
                ctx[method](proj[i].x, proj[i].y);
            }
            ctx.lineWidth = (width - 1) * 2;
            ctx.strokeStyle = 'white';
            ctx.stroke();
            ctx.clip();
            ctx.restore();
            for (i = 0; i < proj.length; i++) {
                method = (i === 0 ? 'move' : 'line') + 'To';
                ctx[method](proj[i].x, proj[i].y);
            }
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.fillText(linkWidth + 'm', proj[0].x, proj[0].y);
        }

        // // 制作辅路算平行线的方法;
        function lineEquation(pt1, pt2) {
            if (pt1.x != pt2.x) {
                var a = (pt2.y - pt1.y) / (pt2.x - pt1.x);
                return {
                    a: a,
                    b: pt1.y - a * pt1.x
                };
            }
            if (pt1.y != pt2.y) {
                return { x: pt1.x };
            }
            return null;
        }

        function intersection(l1a, l1b, l2a, l2b) {
            var line1 = lineEquation(l1a, l1b);
            var line2 = lineEquation(l2a, l2b);

            if (line1 == null || line2 == null) {
                return null;
            }

            if (line1.hasOwnProperty('x')) {
                if (line2.hasOwnProperty('x')) {
                    return null;
                }
                return L.point(line1.x, line2.a * line1.x + line2.b);
            }
            if (line2.hasOwnProperty('x')) {
                return L.point(line2.x, line1.a * line2.x + line1.b);
            }

            if (line1.a == line2.a) {
                return null;
            }

            var x = (line2.b - line1.b) / (line1.a - line2.a);
            var y = line1.a * x + line1.b;

            return L.point(x, y);
        }

        function joinSegments(s1, s2, offset, joinStyle) {
            var jointPoints = [];
            jointPoints = [intersection(s1.offset[0], s1.offset[1], s2.offset[0], s2.offset[1])];
            return jointPoints.filter(function (v) {
                return v;
            });
        }

        function joinLineSegments(segments, offset, joinStyle) {
            var l = segments.length;
            var joinedPoints = [];
            var s1 = segments[0];
            var s2 = segments[0];
            joinedPoints.push(s1.offset[0]);

            for (var i = 1; i < l; i++) {
                s2 = segments[i];
                joinedPoints = joinedPoints.concat(joinSegments(s1, s2, offset, joinStyle));
                s1 = s2;
            }
            joinedPoints.push(s2.offset[1]);

            return joinedPoints;
        }

        function translatePoint(pt, dist, radians) {
            return L.point(pt.x + dist * Math.cos(radians), pt.y + dist * Math.sin(radians));
        }

        function offsetPointLine(points, distance) {
            var l = points.length;
            if (l < 2) {
                throw new Error('Line should be defined by at least 2 points');
            }
            var a = points[0];
            var offsetSegments = [];
            var offsetAngle,
                segmentAngle,
                b;
            for (var i = 1; i < l; i++) {
                b = points[i];
                // angle in (-PI, PI]
                segmentAngle = Math.atan2(a.y - b.y, a.x - b.x);
                // angle in (-1.5 * PI, PI/2]
                offsetAngle = segmentAngle - Math.PI / 2;
                // store offset point and other information to avoid recomputing it later
                offsetSegments.push({
                    angle: segmentAngle,
                    offsetAngle: offsetAngle,
                    distance: distance,
                    original: [a, b],
                    offset: [
                        translatePoint(a, distance, offsetAngle),
                        translatePoint(b, distance, offsetAngle)
                    ]
                });
                a = b;
            }
            return offsetSegments;
        }

        function drawSideBuffer(geom, width, showSide, self1) {
            var proOriginArr = [];
            var proLeftProArr = [];
            var proRightProArr = [];
            var proMiddleArr = [];
            this.transform = new fastmap.mapApi.MecatorTranform();
            var scale = this.transform.scale(map);
            var linkWidth = parseFloat(width * scale);
            linkWidth = linkWidth.toFixed(2);
            geom = Utils.distinctArr(geom);
            for (var i = 0; i < geom.length; i++) {
                geom[i] = geom[i].split(',');
                proOriginArr.push(this.map.latLngToContainerPoint([geom[i][1], geom[i][0]]));
            }
            proMiddleArr = joinLineSegments(offsetPointLine(proOriginArr, 0), 0);
            proRightProArr = joinLineSegments(offsetPointLine(proOriginArr, parseFloat(width)), parseFloat(width));
            proLeftProArr = joinLineSegments(offsetPointLine(proOriginArr, -parseFloat(width)), -parseFloat(width));
            var ctx = self1._ctx;
            ctx.strokeStyle = 'blue';
            ctx.save();
            ctx.beginPath();
            for (i = 0; i < proMiddleArr.length; i++) {
                var method1 = (i === 0 ? 'move' : 'line') + 'To';
                ctx[method1](proMiddleArr[i].x, proMiddleArr[i].y);
            }
            ctx.stroke();
            if (showSide == 3 || showSide == 1) {
                for (i = 0; i < proLeftProArr.length; i++) {
                    var method2 = (i === 0 ? 'move' : 'line') + 'To';
                    ctx[method2](proLeftProArr[i].x, proLeftProArr[i].y);
                }
                ctx.stroke();
            }
            if (showSide == 2 || showSide == 1) {
                for (i = 0; i < proRightProArr.length; i++) {
                    var method3 = (i === 0 ? 'move' : 'line') + 'To';
                    ctx[method3](proRightProArr[i].x, proRightProArr[i].y);
                }
                ctx.stroke();
            }
            ctx.fillText(linkWidth + 'm', proOriginArr[0].x, proOriginArr[0].y);
        }

        function drawDirectionLine(x1, y1, x2, y2, ctx) {
            var angle = Math.abs(Math.atan((x2 - x1) / (y2 - y1))); // 倾斜角余角
            var length = 10; // 箭头斜线长度
            var degree = Math.PI / 6; // 箭头倾斜角
            var theta = 0;
            var altha = 0;
            var a1 = 0;
            var b1 = 0;
            var a2 = 0;
            var b2 = 0;

            if (angle >= degree && angle <= Math.PI / 2 - degree) {
                theta = angle - degree;
                altha = Math.PI / 2 - 2 * degree - theta;
                if (x2 >= x1) {
                    a1 = x2 - length * Math.sin(theta);
                    a2 = x2 - length * Math.cos(altha);
                } else {
                    a1 = x2 + length * Math.sin(theta);
                    a2 = x2 + length * Math.cos(altha);
                }
                if (y2 >= y1) {
                    b1 = y2 - length * Math.cos(theta);
                    b2 = y2 - length * Math.sin(altha);
                } else {
                    b1 = y2 + length * Math.cos(theta);
                    b2 = y2 + length * Math.sin(altha);
                }
            } else {
                theta = angle - degree;
                altha = theta + 2 * degree - Math.PI / 2;
                if (x2 >= x1 && y2 >= y1) {
                    a1 = x2 - length * Math.sin(theta);
                    b1 = y2 - length * Math.cos(theta);
                    a2 = x2 - length * Math.cos(altha);
                    b2 = y2 + length * Math.sin(altha);
                } else if (x2 >= x1 && y2 < y1) {
                    a1 = x2 - length * Math.sin(theta);
                    b1 = y2 + length * Math.cos(theta);
                    a2 = x2 - length * Math.cos(altha);
                    b2 = y2 - length * Math.sin(altha);
                } else if (x2 < x1 && y2 < y1) {
                    a1 = x2 + length * Math.sin(theta);
                    b1 = y2 + length * Math.cos(theta);
                    a2 = x2 + length * Math.cos(altha);
                    b2 = y2 - length * Math.sin(altha);
                } else {
                    a1 = x2 + length * Math.sin(theta);
                    b1 = y2 - length * Math.cos(theta);
                    a2 = x2 + length * Math.cos(altha);
                    b2 = y2 + length * Math.sin(altha);
                }
            }

            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.lineTo(a1, b1);
            ctx.stroke();
            ctx.moveTo(x2, y2);
            ctx.lineTo(a2, b2);
            ctx.stroke();
        }
        // 获取geo长度，计算获取中间一段坐标
        function getMiddleGeo(geom, geoms) {
            // 偶数
            if (geom.coordinates.length % 2 == 0) {
                geoms.push(geom.coordinates[geom.coordinates.length / 2 - 1]);
                geoms.push(geom.coordinates[geom.coordinates.length / 2]);
            } else { // 奇数
                geoms.push(geom.coordinates[Math.floor(geom.coordinates.length / 2)]);
                geoms.push(geom.coordinates[Math.floor(geom.coordinates.length / 2) + 1]);
            }
            return geoms;
        }
        // 绘制link辅助箭头方向
        function drawLinkArrowGuide(geom, links, width, showSide, self1) {
            var proOriginArr = [];
            var proLeftProArr = [];
            var proRightProArr = [];
            var proMiddleArr = [];
            var geoms = [];
            this.transform = new fastmap.mapApi.MecatorTranform();
            var scale = this.transform.scale(map);
            var linkWidth = parseFloat(width * scale);
            linkWidth = linkWidth.toFixed(2);

            geoms = Utils.distinctArr(geom);

            for (var i = 0; i < geoms.length; i++) {
                geoms[i] = geoms[i].split(',');
                proOriginArr.push(this.map.latLngToContainerPoint([geoms[i][1], geoms[i][0]]));
            }
            // proOriginArr.push(this.map.latLngToContainerPoint([geoms[1], geoms[0]]));
            proRightProArr = joinLineSegments(offsetPointLine(proOriginArr, parseFloat(width)), parseFloat(width));
            proLeftProArr = joinLineSegments(offsetPointLine(proOriginArr, -parseFloat(width)), -parseFloat(width));
            var ctx = self1._ctx;
            ctx.strokeStyle = 'red';
            ctx.save();
            ctx.beginPath();
            if (showSide == 0) {
                proLeftProArr = proLeftProArr.reverse();
                for (i = 0; i < proLeftProArr.length; i++) {
                    if (i != proLeftProArr.length - 1) {
                        drawDirectionLine(proLeftProArr[i].x, proLeftProArr[i].y, proLeftProArr[i + 1].x, proLeftProArr[i + 1].y, ctx);
                    }
                }
            }
            if (showSide == 1) {
                for (i = 0; i < proRightProArr.length; i++) {
                    if (i != proRightProArr.length - 1) {
                        drawDirectionLine(proRightProArr[i].x, proRightProArr[i].y, proRightProArr[i + 1].x, proRightProArr[i + 1].y, ctx);
                    }
                }
            }
            ctx.fillText('', proOriginArr[0].x, proOriginArr[0].y);
        }
        // 单条link画辅助箭头
        function drawLinkArrow(geoms, width, showSide, self1) {
            this.transform = new fastmap.mapApi.MecatorTranform();
            var scale = this.transform.scale(map);
            for (var i = 0; i < geoms.length; i++) {
                var proOriginArr = [];
                var proLeftProArr = [];
                var proRightProArr = [];
                proOriginArr.push(this.map.latLngToContainerPoint([geoms[i][0][1], geoms[i][0][0]]));
                proOriginArr.push(this.map.latLngToContainerPoint([geoms[i][1][1], geoms[i][1][0]]));
                proRightProArr = joinLineSegments(offsetPointLine(proOriginArr, parseFloat(width)), parseFloat(width));
                proLeftProArr = joinLineSegments(offsetPointLine(proOriginArr, -parseFloat(width)), -parseFloat(width));
                var ctx = self1._ctx;
                ctx.strokeStyle = 'red';
                ctx.save();
                ctx.beginPath();
                if (showSide == 0) {
                    proLeftProArr = proLeftProArr.reverse();
                    drawDirectionLine(proLeftProArr[0].x, proLeftProArr[0].y, proLeftProArr[1].x, proLeftProArr[1].y, ctx);
                }
                if (showSide == 1) {
                    drawDirectionLine(proRightProArr[0].x, proRightProArr[0].y, proRightProArr[1].x, proRightProArr[1].y, ctx);
                }
            }
        }

        function drawSymbol(geom, style, boolPixelCrs) {
            if (!geom) {
                return;
            }
            var p = null;
            if (boolPixelCrs) {
                p = { x: geom.x, y: geom.y };
            } else {
                p = this.map.latLngToContainerPoint([geom.y, geom.x]);
            }

            var g = self._ctx;
            g.beginPath();
            g.fillStyle = style.color;
            g.arc(p.x, p.y, style.radius, 0, Math.PI * 2);
            g.closePath();
            g.fill();
            g.restore();
        }

        function drawMultiPolyline(geom, style, self1) {
            for (var i = 0, len = geom.length; i < len; i++) {
                drawLineString(geom[i].components, 1, style, false, null, true, true, self1);
            }
        }

        function drawPolygon(geom, style) {
            if (!style) {
                return;
            }

            var coords = geom.components;
            var proj = [];
            var i;

            for (i = 0; i < coords.length; i++) {
                proj.push(this.map.latLngToContainerPoint([coords[i].y, coords[i].x]));
            }

            var g = self._ctx;
            var outline = style.outline;
            g.fillStyle = style.color;
            if (outline) {
                g.strokeStyle = outline.color;
                g.lineWidth = outline.size;
            }
            g.beginPath();
            for (i = 0; i < proj.length; i++) {
                var method = (i === 0 ? 'move' : 'line') + 'To';
                g[method](proj[i].x, proj[i].y);
            }
            g.closePath();
            g.fill();
            if (outline) {
                g.stroke();
            }
        }

        function loadImg(url, callBack) {
            var img = new Image();
            img.onload = function () {
                callBack(img);
            };
            img.src = url;
        }

        function directOfPoint(point, length, width, angle) {
            point.x += length;
            point.y += width / 2;
            point.x += Math.tan(angle);
            point.y += Math.tan(angle);
            // point=this.map.containerPointToLatLng(point);
            return point;
        }

        function drawMarker(geom, type, angle, boolPixelCrs, self1) {
            var url;
            var p = null;
            var angleOfTran = angle;
            var that = this;
            if (!geom) {
                return;
            }

            if (boolPixelCrs) {
                p = { x: geom.x, y: geom.y };
            } else {
                p = this.map.latLngToContainerPoint([geom.y, geom.x]);
            }
            // if(type==="3") {
            //    angleOfTran = angleOfTran + Math.PI;
            // }
            url = '../../images/road/img/' + type + '.svg';
            var g = self1._ctx;
            loadImg(url, function (img) {
                g.save();
                g.translate(p.x, p.y);
                g.rotate(angleOfTran);
                g.drawImage(img, 0, 0);
                g.restore();
                currentGeo.pointForDirect = directOfPoint(p, 61, 32, angle);
                self1.eventController.fire(self1.eventController.eventTypes.DIRECTEVENT, { geometry: currentGeo });
            });
        }

        function drawRticMarker(geom, type, angle, boolPixelCrs, self1) {
            var url;
            var p = null;
            var angleOfTran = angle;
            var that = this;
            if (!geom) {
                return;
            }

            if (boolPixelCrs) {
                p = { x: geom.x, y: geom.y };
            } else {
                p = this.map.latLngToContainerPoint([geom.y, geom.x]);
            }
            if (type === '1') {
                angleOfTran += Math.PI;
            }
            url = '../../images/road/intRtic/' + type + '.svg';
            var g = self1._ctx;
            loadImg(url, function (img) {
                g.save();
                g.translate(p.x, p.y);
                g.rotate(angleOfTran);
                g.drawImage(img, 0, 0);
                g.restore();
                currentGeo.pointForDirect = directOfPoint(p, 61, 32, angle);
                self1.eventController.fire(self1.eventController.eventTypes.DIRECTEVENT, { geometry: currentGeo });
            });
        }

        function drawPoi(geom, style, boolPixelCrs) {
            if (!geom) {
                return;
            }
            var p = null;
            if (boolPixelCrs) {
                p = { x: geom.x, y: geom.y };
            } else {
                p = this.map.latLngToContainerPoint([geom.y, geom.x]);
            }
            var g = self._ctx;
            var image = new Image();
            image.src = style.src;
            image.onload = function () {
                var scalex = style.scalex ? style.scalex : 1;
                var scaley = style.scaley ? style.scaley : 1;
                var drawx = style.drawx ? style.drawx : -image.width * scalex / 2;
                var drawy = style.drawy ? style.drawy : -image.height * scalex / 2;
                g.save();
                g.translate(p.x, p.y);
                g.drawImage(image, drawx, drawy, image.width * scalex, image.height * scaley);
                g.restore();
            };
        }
        function drawSymbolLineString(ctx, geom, boolPixelCrs, symbol) {
            var that = this;
            if (!symbol) {
                return;
            }
            var geometry = [];
            for (var i = 0; i < geom.length; i++) {
                if (boolPixelCrs) {
                    geometry.push([geom[i][0], geom[i][1]]);
                } else {
                    var point = this._tilePoint(ctx, geom[i]);
                    geometry.push([point.x, point.y]);
                }
            }

            var gf = fastmap.mapApi.symbol.GeometryFactory.getInstance();
            var a = gf.createLineString(geometry);
            var g = ctx.canvas.getContext('2d');
            symbol.geometry = a;
            symbol.draw(g);
        }

        function drawPoiAndLink(geom, style, self1) {
            if (!geom) {
                return;
            }
            this.transform = new fastmap.mapApi.MecatorTranform();
            var proj = [];
            for (var i = 0; i < geom.length; i++) {
                var point = this.map.latLngToContainerPoint([geom[i].y, geom[i].x]);
                proj.push([point.x, point.y]);
                if (i == 0) {
                    drawPoi(point, {
                        src: '../../images/poi/map/marker_blue_32.png',
                        drawy: -32
                    }, true);
                } else if (i == 1) {
                    drawPoi(point, {
                        src: '../../images/poi/map/marker_circle_blue_16.png'
                    }, true);
                }
            }
            var symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();
            var symbol = symbolFactory.createSymbol({
                type: 'SimpleLineSymbol',
                style: 'dash',
                color: 'blue'
            });
            drawSymbolLineString(self1._ctx, proj, true, symbol);
        }

        function drawAdminPointAndLink(geom, style, self1) {
            if (!geom) {
                return;
            }
            this.transform = new fastmap.mapApi.MecatorTranform();
            var proj = [];
            var flag = geom[0].y > geom[1].y;
            for (var i = 0; i < geom.length; i++) {
                var point = this.map.latLngToContainerPoint([geom[i].y, geom[i].x]);
                proj.push([point.x, point.y]);
                if (i == 0) {
                    drawPoi(point, {
                        src: '../../images/road/img/star.png',
                        drawy: flag ? -8 : 0,
                        drawX: flag ? -8 : 0
                    }, true);
                } else if (i == 1) {
                    drawPoi(point, {
                        src: '../../images/poi/map/marker_circle_blue_16.png'
                    }, true);
                }
            }
            var symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();
            var symbol = symbolFactory.createSymbol({
                type: 'SimpleLineSymbol',
                style: 'dash',
                color: 'blue'
            });
            drawSymbolLineString(self1._ctx, proj, true, symbol);
        }

        switch (currentGeo.type) {
            case 'LineString':
                if (currentGeo.noFormNode) {
                    drawLineString(currentGeo.components, null, {
                        color: 'red',
                        size: 2
                    }, false, null, true, false, self);
                } else {
                    drawLineString(currentGeo.components, null, {
                        color: 'red',
                        size: 2
                    }, false, null, false, false, self);
                }
                break;
            case 'Link':
                self.clear();
                drawLineString(currentGeo.geometry.components, currentGeo.direct, {
                    color: 'red',
                    size: 2
                }, false, null, false, true, self);
                break;
            case 'Point':
                drawPoint(currentGeo, { color: 'red', radius: 3 }, false);
                break;
            case 'Symbol':
                drawSymbol(currentGeo, { color: 'red', radius: 3 }, false);
                break;
            case 'SpeedLimit':
                drawPoint(currentGeo.components[0], { color: 'red', radius: 3 }, false);
                break;
            case 'Polygon':
                drawPolygon(currentGeo, { color: 'red', outline: 3 }, false);
                break;
            case 'Cross':
                drawCross(currentGeo, { color: 'blue', width: 1 }, false, self);
                break;
            case 'GSC':
                drawGSC(currentGeo.geos, currentGeo.style, false, self);
                break;
            case 'marker':
                drawMarker(currentGeo.point, currentGeo.orientation, currentGeo.angle, false, self);
                break;
            case 'MultiPolyline':
                // MultiPolyline中分两层高亮，用于需要有区分层级的情况
                if (currentGeo.activeCoordinates.length) {
                    drawMultiPolyline(currentGeo.activeCoordinates, {
                        color: 'red',
                        size: (currentGeo.activeOptions && currentGeo.activeOptions.size) ? currentGeo.activeOptions.size : 2
                    }, self);
                }
                drawMultiPolyline(currentGeo.coordinates, {
                    color: (currentGeo.options && currentGeo.options.color) ? currentGeo.options.color : 'red',
                    size: (currentGeo.options && currentGeo.options.size) ? currentGeo.options.size : 2
                }, self);
                break;
            case 'intRticMarker':
                drawRticMarker(currentGeo.point, currentGeo.orientation, currentGeo.angle, false, self);
                break;
            case 'Buffer':
                drawBuffer(currentGeo.geometry.components, currentGeo.linkWidth, self, currentGeo.type);
                break;
            case 'sideBuffer':
                drawSideBuffer(currentGeo.geometry, currentGeo.linkWidth, currentGeo.showSide, self, currentGeo.type);
                break;
            case 'linkArrowGuide':
                drawLinkArrow(currentGeo.geometry, currentGeo.linkWidth, currentGeo.showSide, self, currentGeo.type);
                break;
            case 'IXPOI':
                drawPoiAndLink(currentGeo.components, { color: 'blue', size: 2 }, self);
                break;
            case 'ADMINPOINT':
                drawAdminPointAndLink(currentGeo.components, { color: 'blue', size: 2 }, self);
                break;
            default:
                break;
        }
    },


    /** *
     * 清空图层
     */
    clear: function () {
        this.canv.getContext('2d').clearRect(0, 0, this.canv.width, this.canv.height);
    },
    distance: function (pointA, pointB) {
        var len;
        if (pointA.x) {
            len = Math.pow((pointA.x - pointB.x), 2) + Math.pow((pointA.y - pointB.y), 2);
        } else {
            len = Math.pow((pointA[0] - pointB[0]), 2) + Math.pow((pointA[1] - pointB[1]), 2);
        }

        return Math.sqrt(len);
    },
    _redraw: function () {
        this.clear();

        this.draw(this.drawGeometry, this);
        this._resetCanvasPosition();
        return this;
    }

});

fastmap.mapApi.editLayer = function (url, options) {
    return new fastmap.mapApi.EditLayer(url, options);
};


/**
 * Created by xujie on 2016-11-26.
 * FeedbackLayer类代表整体的图层
 * 所有的高亮，编辑等创建的反馈都应该在此图层中绘制
 */
fastmap.mapApi.FeedbackLayer = fastmap.mapApi.WholeLayer.extend({
    /** *
     *
     * @param options 初始化可选options
     */
    initialize: function (options) {
        FM.setOptions(this, options);

        this.eventController = fastmap.uikit.EventController();
        this.geometryFactory = fastmap.mapApi.symbol.GeometryFactory.getInstance();
        this.transform = fastmap.mapApi.symbol.GeometryTransform.getInstance();
        this.featureSelector = fastmap.mapApi.FeatureSelector.getInstance();
        this.symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();
        this.geometryAlgorithm = fastmap.mapApi.geometry.GeometryAlgorithm.getInstance();
    },

    onAdd: function (map) {
        this.map = map;
        this._initContainer(this.options);

        this._unloaded = 0;
        this._drawItems = [];
        this.eventController.on(L.Mixin.EventTypes.FEEDBACKREFRESH, this._onFeedbackRefresh, this);
        map.on('moveend', this._redraw, this);
        this.map.on('TileLayersLoaded', this._onTilesLoaded, this);
    },

    onRemove: function (map) {
        this.map.getPanes().overlayPane.removeChild(this._div);

        this.eventController.off(L.Mixin.EventTypes.FEEDBACKREFRESH, this._onFeedbackRefresh, this);
        map.off('moveend', this._redraw, this);
        this.map.off('TileLayersLoaded', this._onTilesLoaded, this);

        this.map = null;
    },

    /**
     * 响应FEEDBACKREFRESH事件
     * @param items
     */
    _onFeedbackRefresh: function (event) {
        this._unloaded = 0;
        this._drawItems = [];

        var temp = event.drawItems || [];
        for (var i = 0; i < temp.length; i++) {
            if (temp[i].type === 'pid') {
                this._drawItems.push({
                    origin: temp[i],
                    geometry: null,
                    symbol: temp[i].symbol || null,
                    drawable: false
                });
                this._unloaded++;
            } else if (temp[i].type === 'geometry') {
                this._drawItems.push({
                    origin: temp[i],
                    geometry: temp[i].geometry || null,
                    symbol: temp[i].symbol || null,
                    drawable: true
                });
            }
        }

        this._redraw();
    },

    /** *
     * 绘制图层内容
     */
    _draw: function () {
        var urls = this._getDependencyResource(this._drawItems);
        var loader = new fastmap.mapApi.symbol.ImageLoader(urls);
        var self = this;
        loader.load()
              .then(function () {
                  self._onDependencyResourceLoaded();
              })
              .catch(function (e) {
                  FM.Util.log(e);
              });
    },

    _onDependencyResourceLoaded: function () {
        // 由于绘制是异步的,所有只有在异步请求完成之后清空canvas才能
        // 保证在连续绘制的时候不出现重复绘制问题
        this._clear();
        this.transform.setEnviroment(this.map, null, this._convertGeometry);
        var g = this._ctx.canvas.getContext('2d');
        for (var i = 0; i < this._drawItems.length; ++i) {
            var item = this._drawItems[i];
            if (!item.drawable) {
                continue;
            }
            var convertedGeometry = this.transform.convertGeometry(item.geometry);
            var symbol = item.symbol;
            symbol.geometry = convertedGeometry;
            symbol.draw(g);
        }
    },

    _getDependencyResource: function (drawItems) {
        var urls = [];
        for (var i = 0; i < drawItems.length; i++) {
            var item = drawItems[i];
            if (!item.drawable) {
                continue;
            }
            var symbol = item.symbol;
            if (!symbol) {
                continue;
            }

            var symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();
            urls = urls.concat(symbolFactory.getUrlsFromSymbol(symbol));
        }

        return urls;
    },

    _convertGeometry: function (map, tile, geometry) {
        var point = map.latLngToContainerPoint([geometry.y, geometry.x]);
        geometry.x = point.x;
        geometry.y = point.y;
        return geometry;
    },

    _loadData: function () {
        var item,
            feature,
            i,
            j;
        var temp,
            geomType,
            geoms;
        for (i = 0; i < this._drawItems.length; i++) {
            item = this._drawItems[i];
            if (!item.drawable) {
                if (item.origin.pid && item.origin.featureType) {
                    feature = this.featureSelector.selectByFeatureId(item.origin.pid, item.origin.featureType);
                    if (feature) {
                        geomType = this.symbolFactory.getGeometryTypeBySymbol(item.symbol);
                        geoms = this.geometryAlgorithm.getGeometriesByType(feature.geometry, geomType);

                        if (geoms.length === 0) {
                            this._drawItems.splice(i, 1);
                            i--;
                        } else {
                            item.geometry = this.geometryFactory.fromGeojson(geoms[0]);
                            item.drawable = true;
                            for (j = 1; j < geoms.length; j++) {
                                temp = {
                                    geometry: this.geometryFactory.fromGeojson(geoms[j]),
                                    symbol: item.symbol,
                                    drawable: true
                                };
                                this._drawItems.splice(i++, 0, temp);
                            }
                        }
                        this._unloaded--;
                    }
                }
            }
        }
    },

    /** *
     * 重绘图层
     * @private
     */
    _redraw: function () {
        this._resetCanvasPosition();

        if (this._unloaded > 0) {
            this._loadData();
        }

        this._draw();
    },

    /** *
     * 清空图层
     */
    _clear: function () {
        this._ctx.clearRect(0, 0, this.canv.width, this.canv.height);
    },

    _onTilesLoaded: function () {
        if (this._unloaded > 0) {
            this._loadData();

            this._draw();
        }
    }
});

fastmap.mapApi.feedbackLayer = function (options) {
    return new fastmap.mapApi.FeedbackLayer(options);
};

/**
 * Created by liwanchong on 2016/5/16.
 */
fastmap.mapApi.GuideLineLayer = fastmap.mapApi.WholeLayer.extend({
    /**
     * 事件管理器
     * @property includes
     */
    includes: L.Mixin.Events,

    /** *
     * 初始化可选参数
     * @param {Object}options
     */
    initialize: function (url, options) {
        fastmap.mapApi.WholeLayer.prototype.initialize.call(this, options);
        this.url = url;
        this.g = this._ctx;
        this.linkFObj = {};
    },
    draw: function (guideObj) {
        var g = this._ctx;
        if (guideObj) {
            if (!this.linkFObj[guideObj.id]) {
                this.linkFObj[guideObj.id] = guideObj;
                this.drawLineString(guideObj.coordinates, guideObj.guidePoint, g, false, this);
            }
        }
    },
    drawMove: function (obj) {
        var g = this._ctx;
        // g.strokeStyle = "red";
        // g.lineWidth = 2;
        var keys = Object.getOwnPropertyNames(obj);
        for (var i = 0; i < keys.length; i++) {
            var item = keys[i];
            this.drawLineString(obj[item].coordinates, obj[item].guidePoint, g, false, this);
        }
    },
    /** *
     * 清空图层
     */
    clear: function () {
        this.canv.getContext('2d').clearRect(0, 0, this.canv.width, this.canv.height);
    },

    drawLineString: function (geom, guidePoint, g, boolPixelCrs, self) {
        if (!geom) {
            return;
        }
        if (this.map.getZoom() >= 17) {
            var proj = [];
            proj.push(this.map.latLngToLayerPoint([geom[1], geom[0]]));
            if (guidePoint) {
                proj.push(this.map.latLngToLayerPoint([guidePoint[1], guidePoint[0]]));
            }
            if (g.setLineDash) {
                g.setLineDash([6, 6]);
                //  Get the current offset
                g.lineDashOffset = 0;  // To animate the lines
                g.lineJoin = 'round';
                g.lineWidth = '1';
                g.strokeStyle = 'gray';
                g.beginPath();
                for (var i = 0; i < proj.length; i++) {
                    var method = (i === 0 ? 'move' : 'line') + 'To';
                    g[method](proj[i].x, proj[i].y);
                }
                g.stroke();
            }
        }
    },
    _redraw: function () {
        // this._resetCanvasPosition();
        this.clear();
        this.drawMove(this.linkFObj);

        return this;
    }

});
fastmap.mapApi.guideLineLayer = function (url, options) {
    return new fastmap.mapApi.GuideLineLayer(url, options);
};

/**
 * Created by wangtun on 2016/2/2.
 */
/**
 * Created by zhongxiaoming on 2015/9/2.
 * Class 1:25000图幅图层
 */
fastmap.mapApi.GridLayer = fastmap.mapApi.MeshLayer.extend({
    /** *
     * 初始化可选参数
     * @param {Object}options
     */
    initialize: function (options) {
        fastmap.mapApi.MeshLayer.prototype.initialize.call(this, options);
        this.minZoom = this.options.minZoom || 9;
        this.maxZoom = this.options.maxZoom || 20;
        this.divideX = this.options.divideX || 0;
        this.divideY = this.options.divideY || 0;
    },
    /** *
     * 图层添加到地图时调用
     * @param{L.Map} map
     */
    onAdd: function (map) {
        this.map = map;
        this._initContainer(this.options);
        var that = this;
        var center = null;
        this.canv.onclick = function (e) {
            var event = e;
            event.stopPropagation();
            event.preventDefault();
            var showFlag = false;
            for (var i = 0; i < that.gridArr.length; i++) {
                var latlngbounds = that.gridArr[i].getBounds();
                var bound = L.bounds(that.map.latLngToContainerPoint(latlngbounds.getNorthWest()), that.map.latLngToContainerPoint(latlngbounds.getSouthEast()));
                if (e.x <= bound.max.x && e.x >= bound.min.x && e.y <= bound.max.y && e.y >= bound.min.y) {
                    center = latlngbounds.getCenter();
                    if (that.options.gridInfo[that.gridArr[i].options.gridId]) {
                        if (that.options.gridInfo[that.gridArr[i].options.gridId].couldBorrow) {
                            that.map.openPopup('<a href="javascript:void(0)" class="btn btn-warning">借数据</a>', center);
                        } else if (that.options.gridInfo[that.gridArr[i].options.gridId].couldReturn) {
                            that.map.openPopup('<a href="javascript:void(0)" class="btn btn-warning">还数据</a>', center);
                        } else if (that.options.gridInfo[that.gridArr[i].options.gridId].userId) {
                            that.map.openPopup('<div style="width:200px;text-align: center"><img src="css/img/pie.jpg" style="width:100px;height:100px"/></div>', center);
                        }
                        showFlag = true;
                    }
                }
            }
            if (!showFlag) {
                that.map.closePopup();
            }
        };
        this.canv.ondblclick = function () {
            window.location.href = 'edit.html';
        };
        map.on('moveend', this._redraw, this);
        this._redraw();
    },
    /** *
     * 根据bounds绘制图幅
     * @param {L.Bounds}bounds
     */
    draw: function (bounds) {
        var pointDL = bounds.getSouthWest();
        // 右上角点
        var pointUR = bounds.getNorthEast();
        // var ret= this.CalculateMeshIds(pointDL.lng, pointUR.lng, pointDL.lat, pointUR.lat);
        var minPoint = this.Calculate25TMeshCorner(pointDL);
        var minLon = minPoint.lng;
        var minLat = minPoint.lat;
        this.gridArr = [];
        var labelArr = [];
        while (minLon <= pointUR.lng) {
            var gridObj = this.createGrid(minLon, minLon + 0.125, minLat, pointUR.lat);
            this.gridArr = this.gridArr.concat(gridObj);
            minLon += 0.125;
        }
        for (var i = 0, len = this.gridArr.length; i < len; i++) {
            var latlngbounds = this.gridArr[i].getBounds();
            var bound = L.bounds(this.map.latLngToContainerPoint(latlngbounds.getNorthWest()), this.map.latLngToContainerPoint(latlngbounds.getSouthEast()));
            var size = bound.getSize();
            this.drawRect(this._ctx, this.gridArr[i], {
                x: bound.min.x,
                y: bound.min.y,
                width: size.x,
                height: size.y
            });
        }
    },
    /** *
     * 绘制格网
     * @param {Object}context canvas context
     * @param meshId 图幅id
     * @param options 可选参数
     */
    drawRect: function (context, grid, options) {
        context.globalAlpha = 0.3;
        context.linewidth = 1; // 边框宽
        context.strokeStyle = '#000AFF'; // 边框颜色
        context.strokeRect(options.x, options.y, options.width, options.height);
    },
    /** *
     * 重绘
     * @returns {fastmap.mapApi.MeshLayer}
     * @private
     */
    _redraw: function () {
        this._resetCanvasPosition();
        this.clear();
        if (this.map.getZoom() >= this.minZoom && this.map.getZoom() <= this.maxZoom) {
            this.draw(this.map.getBounds());
        }
        return this;
    },
    /** *
     * 生成图幅格网
     * @param {number}minLon 最小经度
     * @param {number}maxLon 最大经度
     * @param {number}origin 原点
     * @param {number}destination 最大经度
     * @returns {Array}
     */
    createGrid: function (minLon, maxLon, origin, destination) {
        // 保存生成的网格
        var grid = [];
        var labels = [];
        var plusOri = function () {
            origin += 0.083333333333333;
        };
        while (origin <= destination) {
            var components = [];
            components.push([origin, minLon]);
            components.push([origin + 0.083333333333333, minLon]);
            components.push([origin + 0.083333333333333, maxLon]);
            components.push([origin, maxLon]);
            var meshId = this.Calculate25TMeshId({
                lng: (minLon + maxLon) / 2,
                lat: (origin + origin + 0.083333333333333) / 2
            });
            var bound = this.Calculate25TMeshBorder(meshId);

            this.createSubGrid(grid, bound, meshId, plusOri);
        }
        return grid;
    },
    createSubGrid: function (grid, bound, meshId, callback) {
        var differenceY = bound.maxLat - bound.minLat;
        if (this.divideY > 0) {
            differenceY = (bound.maxLat - bound.minLat) / this.divideY;
        }
        var differenceX = bound.maxLon - bound.minLon;
        if (this.divideX > 0) {
            differenceX = (bound.maxLon - bound.minLon) / this.divideX;
        }
        for (var i = 0; i < this.divideX; i++) {
            var boundXmin = bound.minLon + differenceX * i;
            var boundXmax = bound.minLon + differenceX * (i + 1);
            for (var j = 0; j < this.divideY; j++) {
                var boundYmin = bound.minLat + differenceY * j;
                var boundYmax = bound.minLat + differenceY * (j + 1);
                var b = L.latLngBounds([boundYmin, boundXmin], [boundYmax, boundXmax]);
                var polygon = L.rectangle(b, {
                    meshId: meshId,
                    gridId: meshId + '_' + j + '' + i
                });
                grid.push(polygon);
            }
        }
        callback();
    },
    /** *
     * 清空图层
     */
    clear: function () {
        this.canv.getContext('2d').clearRect(0, 0, this.canv.width, this.canv.height);
    },
    /** *
     * 重新调整图层位置
     * @private
     */
    _resetCanvasPosition: function () {
        var bounds = this.map.getBounds();
        var topLeft = this.map.latLngToLayerPoint(bounds.getNorthWest());
        L.DomUtil.setPosition(this._div, topLeft);
    },
    /*
     *  根据纬度计算该点位于理想图幅分割的行序号
     *
     *  @param{number}lat                 纬度      单位‘度’
     *  @param{number}remainder           余数      单位‘千秒’
     */
    CalculateIdealRowIndex: function (lat, remainder) {
        // 相对区域纬度 = 绝对纬度 - 0.0
        var regionLatitude = lat - 0.0;
        // 相对的以秒为单位的纬度
        var secondLatitude = regionLatitude * 3600;
        var longsecond;
        // 为避免浮点数的内存影响，将秒*10的三次方(由于0.00001度为0.036秒)
        if (secondLatitude * 1000 < 0) {
            longsecond = Math.ceil(secondLatitude * 1000);
        } else {
            longsecond = Math.floor(secondLatitude * 1000);
        }
        remainder = (longsecond % 300000);
        return {
            value: Math.floor(longsecond / 300000),
            reminder: remainder
        };
    },
    /*
     *  根据纬度计算该点位于实际图幅分割的行序号
     *
     *  @param{number}lat                 纬度      单位‘度’
     *  @param{number}remainder           余数      单位‘千秒’
     */
    CalculateRealRowIndex: function (lat, remainder) {
        // 理想行号
        var idealRow = this.CalculateIdealRowIndex(lat, remainder);
        switch (idealRow % 3) { // 三个一组的余数
            case 0: // 第一行
                // 余数距离上框小于0.012秒
                if (300000 - idealRow.remainder <= 12) {
                    idealRow.value++;
                }
                break;
            case 1: // 第二行
                break;
            case 2: // 第三行
                // 余数距离下框小于等于0.012秒
                if (idealRow.remainder < 12) {
                    idealRow.value--;
                }
                break;
            default:
                break;
        }
        return idealRow;
    },
    /*
     *  根据经度计算该点位于实际图幅分割的列序号
     *
     *  @param{number}lon                经度，单位“度”
     */
    CalculateRealColumnIndex: function (lon, remainder) {
        return this.CalculateIdealColumnIndex(lon, remainder);
    },
    /*
     * 根据经度计算该点位于理想图幅分割的列序号
     *
     *  @param{number}lon                经度，单位“度”
     *  @param{number}reminder           余数 单位“千秒”
     */
    CalculateIdealColumnIndex: function (lon, remainder) {
        // 相对区域经度 = 绝对经度 - 60.0
        var regionLongitude = lon - 60.0;
        // 相对的以秒为单位的经度
        var secondLongitude = regionLongitude * 3600;
        // 为避免浮点数的内存影响，将秒*10的三次方(由于0.00001度为0.036秒)
        var longsecond = Math.floor(secondLongitude * 1000);
        remainder = Math.floor(longsecond % 450000);
        return {
            value: Math.floor(longsecond / 450000),
            reminder: remainder
        };
    },
    MeshLocator_25T: function (lon, lat) {
        // 为了保证它总返回右上的图幅
        if ((this.IsAt25TMeshBorder(lon, lat) & 0x0F) == 0x01) {
            lat += 0.00001;
        }
        var remainder = 0;
        var rowResult = this.CalculateRealRowIndex(lat, remainder);
        var colResult = this.CalculateRealColumnIndex(lon, rowResult.remainder);
        // 第1、2位 : 纬度取整拉伸1.5倍
        var M1M2 = Math.floor(lat * 1.5);
        // 第3、4位 : 经度减去日本角点 60度
        var M3M4 = Math.floor(lon) - 60;
        // 第5位 :
        var M5 = rowResult.value % 8;
        // 第6位 : 每列450秒，每度包含8列
        var M6 = colResult.value % 8;
        // 连接以上数字,组成图幅号
        var sMeshId = '' + M1M2 + M3M4 + M5 + M6;
        while (sMeshId.length < 6) {
            sMeshId = '0' + sMeshId;
        }
        return sMeshId;
    },
    /*
     *  点所在的图幅号,如果点在图幅边界上,返回右上的图幅号
     *
     *  @param {L.Latlng}point   经纬度点
     */
    Calculate25TMeshId: function (point) {
        var mesh = this.MeshLocator_25T(point.lng, point.lat);
        return mesh;
    },
    /*
     *  快速计算点所在的图幅左下角点
     *
     *  @param{L.Latlng}point          经纬度点
     */
    Calculate25TMeshCorner: function (point) {
        return this.Calculate25TMeshCornerByMeshId(this.Calculate25TMeshId(point));
    },
    /** *
     * 计算图幅角点坐标
     * @param {String}mesh
     * @returns {*}
     * @constructor
     */
    Calculate25TMeshCornerByMeshId: function (mesh) {
        var cc = mesh.split('');
        var M1 = parseInt(cc[0], 0);
        var M2 = parseInt(cc[1], 0);
        var M3 = parseInt(cc[2], 0);
        var M4 = parseInt(cc[3], 0);
        var M5 = parseInt(cc[4], 0);
        var M6 = parseInt(cc[5], 0);
        var x = (M3 * 10 + M4) * 3600 + M6 * 450 + 60 * 3600;
        var y = (M1 * 10 + M2) * 2400 + M5 * 300;
        var point = L.latLng(y / 3600.0, x / 3600.0);
        return point;
    },
    /** *
     *  计算图幅border
     * @param {String}mesh
     * @returns {{minLon: (*|a.lng|L.LatLng.lng|L.LatLngBounds._southWest.lng|L.LatLngBounds._northEast.lng|o.LatLngBounds._northEast.lng), minLat: (*|a.lat|L.LatLng.lat|L.LatLngBounds._southWest.lat|L.LatLngBounds._northEast.lat|o.LatLngBounds._northEast.lat), maxLon: (*|a.lng|L.LatLng.lng|L.LatLngBounds._southWest.lng|L.LatLngBounds._northEast.lng|o.LatLngBounds._northEast.lng), maxLat: (*|a.lat|L.LatLng.lat|L.LatLngBounds._southWest.lat|L.LatLngBounds._northEast.lat|o.LatLngBounds._northEast.lat)}}
     * @constructor
     */
    Calculate25TMeshBorder: function (mesh) {
        var cc = mesh.split('');
        var M1 = parseInt(cc[0], 0);
        var M2 = parseInt(cc[1], 0);
        var M3 = parseInt(cc[2], 0);
        var M4 = parseInt(cc[3], 0);
        var M5 = parseInt(cc[4], 0);
        var M6 = parseInt(cc[5], 0);
        var xConner = (M3 * 10 + M4) * 3600 + M6 * 450 + 60 * 3600;
        var yConner = (M1 * 10 + M2) * 2400 + M5 * 300;
        var xUpper = xConner + 450.0;
        var yUpper = yConner + 300.0;
        var leftBottom = L.latLng(yConner / 3600.0, xConner / 3600.0);
        var rightTop = L.latLng(yUpper / 3600.0, xUpper / 3600.0);
        return {
            minLon: leftBottom.lng,
            minLat: leftBottom.lat,
            maxLon: rightTop.lng,
            maxLat: rightTop.lat
        };
    },
    /*
     *  点是否在图框上
     *
     *  @param{number}lon               经度
     *  @param{number}lat               纬度
     */
    IsAt25TMeshBorder: function (lon, lat) {
        var model = 0;
        var remainder = 0;
        var rowResult = this.CalculateIdealRowIndex(lat, remainder);
        switch (rowResult.value % 3) {
            case 0: // 第一行
                // 余数距离上框等于0.012秒
                if (300000 - rowResult.remainder == 12) {
                    model |= 0x01;
                } else if (rowResult.remainder == 0) model |= 0x01;
                break;
            case 1: // 第二行由于上下边框均不在其内，因此不在图框上
                break;
            case 2: // 第三行
                // 余数距离下框等于0.012秒
                if (rowResult.remainder == 12) {
                    model |= 0x01;
                }
                break;
            default:
                break;
        }
        var colResult = this.CalculateRealColumnIndex(lon, rowResult.remainder);
        if (colResult.remainder == 0) model |= 0x10;
        return model;
    }
});
fastmap.mapApi.gridLayer = function (options) {
    return new fastmap.mapApi.GridLayer(options);
};

/**
 * Created by xujie on 2016-11-26.
 * WholeCanvasLayer类代表整体的图层
 */
fastmap.mapApi.TileBoundsLayer = fastmap.mapApi.WholeLayer.extend({
    /** *
     *
     * @param options 初始化可选options
     */
    initialize: function (options) {
        fastmap.mapApi.WholeLayer.prototype.initialize.call(this, options);

        // 绑定函数作用域
        FM.Util.bind(this);

        this.options = options || {};
        this._tiles = {};

        this._transform = fastmap.mapApi.symbol.GeometryTransform.getInstance();
    },

    /** *
     * 绘制图层内容
     */
    _redraw: function (features) {
        this.clear();
        this._updateTiles();
        this._resetCanvasPosition();
        this._drawTiles(this._tiles);
    },

    /** *
     * 清空图层
     */
    clear: function () {
        this._ctx.clearRect(0, 0, this.canv.width, this.canv.height);
        this._tiles = {};
    },

    _createTileSymbol: function (tile) {
        var symbolData = {
            type: 'CompositeFillSymbol',
            symbols: [
                {
                    type: 'CenterMarkerFillSymbol',
                    marker: {
                        type: 'TextMarkerSymbol',
                        font: '微软雅黑',
                        size: 20,
                        color: 'red',
                        text: tile.x + '/' + tile.y + '/' + tile.z
                    }
                },
                {
                    type: 'SimpleFillSymbol',
                    color: 'transparent',
                    outLine: {
                        type: 'SimpleLineSymbol',
                        color: 'red',
                        width: 1
                    }
                }
            ]
        };
        var symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();
        var symbol = symbolFactory.createSymbol(symbolData);
        var geometryFactory = fastmap.mapApi.symbol.GeometryFactory.getInstance();
        symbol.geometry = geometryFactory.fromGeojson(tile.bounds);
        return symbol;
    },

    _drawTiles: function (tiles) {
        this._transform.setEnviroment(this.map, null, this._convertGeometry);
        var g = this._ctx.canvas.getContext('2d');
        var keys = Object.getOwnPropertyNames(this._tiles);
        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            var tile = this._tiles[key];
            var symbol = this._createTileSymbol(tile);
            var convertedGeometry = this._transform.convertGeometry(symbol.geometry);
            symbol.geometry = convertedGeometry;
            symbol.draw(g);
        }
    },

    _updateTiles: function () {
        var map = this.map;
        var bounds = map.getPixelBounds();
        var zoom = map.getZoom();
        var tileSize = this.options.tileSize;

        var tileBounds = L.bounds(
            bounds.min.divideBy(tileSize)._floor(),
            bounds.max.divideBy(tileSize)._floor());

        this._addTilesFromCenterOut(tileBounds);
    },

    _addTilesFromCenterOut: function (bounds) {
        var queue = [];
        var center = bounds.getCenter();
        var zoom = this.map.getZoom();

        for (var j = bounds.min.y; j <= bounds.max.y; j++) {
            for (var i = bounds.min.x; i <= bounds.max.x; i++) {
                var point = new L.Point(i, j);
                queue.push(point);
            }
        }

        // load tiles in order of their distance to center
        queue.sort(function (a, b) {
            return a.distanceTo(center) - b.distanceTo(center);
        });

        for (i = 0; i < queue.length; i++) {
            var x = queue[i].x;
            var y = queue[i].y;
            var tile = this._createTile(x, y, zoom);
            this._tiles[tile.name] = tile;
        }
    },

    _createTile: function (x, y, z) {
        var bounds = this._getTileBounds(x, y);
        var tile = {
            name: x + ':' + y,
            x: x,
            y: y,
            z: z,
            size: this.options.tileSize,
            bounds: bounds
        };
        return tile;
    },

    _getTileBounds: function (x, y) {
        var tileSize = this.options.tileSize;
        var tilePoint = new L.Point(x, y);
        var nwPoint = tilePoint.multiplyBy(tileSize);
        var sePoint = nwPoint.add([tileSize, tileSize]);
        var nw = this.map.unproject(nwPoint);
        var se = this.map.unproject(sePoint);

        var bounds = {
            type: 'Polygon',
            coordinates: [
                [
                    [nw.lng, nw.lat],
                    [se.lng, nw.lat],
                    [se.lng, se.lat],
                    [nw.lng, se.lat],
                    [nw.lng, nw.lat]
                ]
            ]
        };

        return bounds;
    },

    _convertGeometry: function (map, tile, geometry) {
        var point = map.latLngToContainerPoint([geometry.y, geometry.x]);
        geometry.x = point.x;
        geometry.y = point.y;
        return geometry;
    }
});

fastmap.mapApi.tileBoundsLayer = function (options) {
    return new fastmap.mapApi.TileBoundsLayer(options);
};

/**
 * Created by Chenx on 2017/7/10.
 * Class 1:25000图幅图层
 */
fastmap.mapApi.OverlayLayer = fastmap.mapApi.MeshLayer.extend({
    /** *
     * 绘制图幅
     * @param {Object}context canvas context
     * @param meshId 图幅id
     * @param options 可选参数
     */
    drawRect: function (context, meshId, options) {
        var meshList = this.options.meshList;

        if (!meshList || meshList.length === 0) {
            return;
        }

        if (meshList.indexOf(parseInt(meshId, 10)) >= 0) {
            return;
        }

        // 对不在图幅列表中的图幅进行遮盖
        context.globalAlpha = 0.2;
        context.fillStyle = 'gray'; // 颜色
        context.fillRect(options.min.x, options.min.y, options.getSize().x, options.getSize().y); // 填充 x y坐标 宽 高
    }
});
fastmap.mapApi.overlayLayer = function (options) {
    return new fastmap.mapApi.OverlayLayer(options);
};

/**
 * 创建ajax对象,可以通过options参数定制ajax对象
 * url:请求的url地址,必须
 * header:请求的头,键值对构成的json对象,默认值null
 * responseType:指定响应的类型,会影响最终放回的结果,默认值''
 * timeout:请求超时,默认值0
 * requestParameter:请求参数,会被拼接到url后面
 * parameter: 附加参数,会被传递给onSuccess或onFail,默认值null
 * debug:如果为true,输出调试信息,默认值false
 * onSuccess:请求成功回调函数,需要参数接受请求的结果,默认值null
 * onFail:请求失败回调函数,默认值null
 * onAbort:请求终止回调函数,默认值null
 * onError:请求失败回调函数,默认值null
 * onTimeout:请求失败回调函数,默认值null
 * @param options 不能为null或undefined
 * @returns {XMLHttpRequest}
 */
fastmap.mapApi.ajax.get = function (options) {
    if (!options) {
        throw new Error('参数options无效!');
    }
    var url = options.url;
    if (!url) {
        throw new Error('缺少url属性!');
    }

    var headers = options.headers || null;
    var responseType = options.responseType || '';
    var timeout = options.timeout || 0;
    var requestParameter = options.requestParameter || null;
    if (requestParameter) {
        url += '&parameter=' + encodeURIComponent(JSON.stringify(requestParameter));
    }

    var parameter = options.parameter || null;
    var debug = options.debug || false;

    var onSuccess = options.onSuccess || null;
    var onFail = options.onFail || null;
    var onAbort = options.onAbort || null;
    var onError = options.onError || null;
    var onTimeout = options.onTimeout || null;

    var xhr = new XMLHttpRequest();
    if (!xhr) {
        throw new Error('创建XMLHttpRequest对象失败!');
    }

    var startTime = null;
    var endTime = null;

    xhr.onloadstart = function (event) {
        if (debug) {
            startTime = new Date().getTime();
            FM.Util.log('开始请求:' + url + '    时间:' + startTime);
            FM.Util.log('附加参数:' + JSON.stringify(parameter));
            FM.Util.log(event);
        }
    };
    xhr.onabort = function (event) {
        endTime = new Date().getTime();
        var diff = endTime - startTime;
        var errmsg = '请求终止:' + url + '    时间:' + startTime + '    耗时:' + diff;

        if (debug) {
            FM.Util.log(errmsg);
            FM.Util.log('附加参数:' + JSON.stringify(parameter));
            FM.Util.log(event);
        }

        if (onAbort) {
            onAbort(errmsg, parameter);
        }
    };
    xhr.onerror = function (event) {
        endTime = new Date().getTime();
        var diff = endTime - startTime;
        var errmsg = '网络错误:' + url + '    时间:' + startTime + '    耗时:' + diff;

        if (debug) {
            FM.Util.log(errmsg);
            FM.Util.log('附加参数:' + JSON.stringify(parameter));
            FM.Util.log(event);
        }

        if (onError) {
            onError(errmsg, parameter);
        }
    };
    xhr.ontimeout = function (event) {
        endTime = new Date().getTime();
        var diff = endTime - startTime;
        var errmsg = '请求超时:' + url + '    时间:' + startTime + '    耗时:' + diff;

        if (debug) {
            FM.Util.log(errmsg);
            FM.Util.log('附加参数:' + JSON.stringify(parameter));
            FM.Util.log(event);
        }

        if (onTimeout) {
            onTimeout(errmsg, parameter);
        }
    };
    xhr.onload = function (event) {
        endTime = new Date().getTime();
        var diff = endTime - startTime;

        // 状态码为2xx或304时都算请求成功
        if ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304) {
            if (debug) {
                FM.Util.log('请求成功:' + url + '    时间:' + startTime + '    耗时:' + diff);
                FM.Util.log('附加参数:' + JSON.stringify(parameter));
                FM.Util.log(xhr.response);
            }
            if (onSuccess) {
                onSuccess(xhr.response, parameter);
            }
        } else {
            var errmsg = '请求失败:' + url + '    时间:' + startTime + '    耗时:' + diff + '    状态:' + xhr.status;
            if (debug) {
                FM.Util.log(errmsg);
                FM.Util.log('附加参数:' + JSON.stringify(parameter));
                FM.Util.log(xhr);
            }
            if (onFail) {
                onFail(errmsg, parameter);
            }
        }
    };
    xhr.open('GET', url);
    if (headers) {
        var keys = Object.getOwnPropertyNames(headers);
        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            var value = headers[key];
            xhr.setRequestHeader(key, value);
        }
    }
    xhr.responseType = responseType;
    xhr.timeout = timeout;
    xhr.send();
    return xhr;
};

/**
 * 创建ajax对象,可以通过options参数定制ajax对象
 * url:请求的url地址,必须
 * header:请求的头,键值对构成的json对象,默认值null
 * responseType:指定响应的类型,会影响最终放回的结果,默认值''
 * timeout:请求超时,默认值0
 * requestParameter:请求参数
 * parameter: 附加参数,会被传递给onSuccess或onFail,默认值null
 * debug:如果为true,输出调试信息,默认值false
 * onSuccess:请求成功回调函数,需要参数接受请求的结果,默认值null
 * onFail:请求失败回调函数,默认值null
 * onAbort:请求终止回调函数,默认值null
 * onError:请求失败回调函数,默认值null
 * onTimeout:请求失败回调函数,默认值null
 * @param options 不能为null或undefined
 * @returns {XMLHttpRequest}
 */
fastmap.mapApi.ajax.post = function (options) {
    if (!options) {
        throw new Error('参数options无效!');
    }
    var url = options.url;
    if (!url) {
        throw new Error('缺少url属性!');
    }

    var headers = options.headers || null;
    var responseType = options.responseType || '';
    var timeout = options.timeout || 0;
    var requestParameter = options.requestParameter || null;
    if (!requestParameter) {
        throw new Error('缺少requestParameter属性!');
    }
    var parameter = options.parameter || null;
    var debug = options.debug || false;

    var onSuccess = options.onSuccess || null;
    var onFail = options.onFail || null;
    var onAbort = options.onAbort || null;
    var onError = options.onError || null;
    var onTimeout = options.onTimeout || null;

    var xhr = new XMLHttpRequest();
    if (!xhr) {
        throw new Error('创建XMLHttpRequest对象失败!');
    }

    var startTime = null;
    var endTime = null;

    xhr.onloadstart = function (event) {
        if (debug) {
            startTime = new Date().getTime();
            FM.Util.log('开始请求:' + url + '    时间:' + startTime);
            FM.Util.log('附加参数:' + JSON.stringify(parameter));
            FM.Util.log(event);
        }
    };
    xhr.onabort = function (event) {
        endTime = new Date().getTime();
        var diff = endTime - startTime;
        var errmsg = '请求终止:' + url + '    时间:' + startTime + '    耗时:' + diff;

        if (debug) {
            FM.Util.log(errmsg);
            FM.Util.log('附加参数:' + JSON.stringify(parameter));
            FM.Util.log(event);
        }

        if (onAbort) {
            onAbort(errmsg, parameter);
        }
    };
    xhr.onerror = function (event) {
        endTime = new Date().getTime();
        var diff = endTime - startTime;
        var errmsg = '网络错误:' + url + '    时间:' + startTime + '    耗时:' + diff;

        if (debug) {
            FM.Util.log(errmsg);
            FM.Util.log('附加参数:' + JSON.stringify(parameter));
            FM.Util.log(event);
        }

        if (onError) {
            onError(errmsg, parameter);
        }
    };
    xhr.ontimeout = function (event) {
        endTime = new Date().getTime();
        var diff = endTime - startTime;
        var errmsg = '请求超时:' + url + '    时间:' + startTime + '    耗时:' + diff;

        if (debug) {
            FM.Util.log(errmsg);
            FM.Util.log('附加参数:' + JSON.stringify(parameter));
            FM.Util.log(event);
        }

        if (onTimeout) {
            onTimeout(errmsg, parameter);
        }
    };
    xhr.onload = function (event) {
        endTime = new Date().getTime();
        var diff = endTime - startTime;

        // 状态码为2xx或304时都算请求成功
        if ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304) {
            if (debug) {
                FM.Util.log('请求成功:' + url + '    时间:' + startTime + '    耗时:' + diff);
                FM.Util.log('附加参数:' + JSON.stringify(parameter));
                FM.Util.log(xhr.response);
            }
            if (onSuccess) {
                onSuccess(xhr.response, parameter);
            }
        } else {
            var errmsg = '请求失败:' + url + '    时间:' + startTime + '    耗时:' + diff + '    状态:' + xhr.status;
            if (debug) {
                FM.Util.log(errmsg);
                FM.Util.log('附加参数:' + JSON.stringify(parameter));
                FM.Util.log(xhr);
            }
            if (onFail) {
                onFail(errmsg, parameter);
            }
        }
    };
    xhr.open('POST', url);
    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    if (headers) {
        var keys = Object.getOwnPropertyNames(headers);
        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            var value = headers[key];
            xhr.setRequestHeader(key, value);
        }
    }
    xhr.responseType = responseType;
    xhr.timeout = timeout;
    var data = encodeURIComponent(JSON.stringify(requestParameter));
    xhr.send('parameter=' + data);
    return xhr;
};

/**
 * Bounds类
 * 用于表示包围框
 *
 * @namespace mapApi
 * @class Bounds
 */
fastmap.mapApi.Parallel = function () {
// 制作辅路算平行线的方法;
    var obj = {};
    obj.lineEquation = function (pt1, pt2) {
        if (pt1.x != pt2.x) {
            var a = (pt2.y - pt1.y) / (pt2.x - pt1.x);
            return {
                a: a,
                b: pt1.y - a * pt1.x
            };
        }
        if (pt1.y != pt2.y) {
            return { x: pt1.x };
        }
        return null;
    };

    obj.intersection = function (l1a, l1b, l2a, l2b) {
        var line1 = this.lineEquation(l1a, l1b);
        var line2 = this.lineEquation(l2a, l2b);

        if (line1 == null || line2 == null) {
            return null;
        }

        if (line1.hasOwnProperty('x')) {
            if (line2.hasOwnProperty('x')) {
                return null;
            }
            return L.point(line1.x, line2.a * line1.x + line2.b);
        }
        if (line2.hasOwnProperty('x')) {
            return L.point(line2.x, line1.a * line2.x + line1.b);
        }

        if (line1.a == line2.a) {
            return null;
        }

        var x = (line2.b - line1.b) / (line1.a - line2.a);
        var y = line1.a * x + line1.b;

        return L.point(x, y);
    };

    obj.translatePoint = function (pt, dist, radians) {
        return L.point(pt.x + dist * Math.cos(radians), pt.y + dist * Math.sin(radians));
    };

    obj.joinSegments = function (s1, s2, offset, joinStyle) {
        var jointPoints = [];
        jointPoints = [this.intersection(s1.offset[0], s1.offset[1], s2.offset[0], s2.offset[1])];
        return jointPoints.filter(function (v) {
            return v;
        });
    };

    obj.offsetPointLine = function (points, distance) {
        var l = points.length;
        if (l < 2) {
            throw new Error('Line should be defined by at least 2 points');
        }
        var a = points[0];
        var offsetSegments = [];
        var offsetAngle,
            segmentAngle,
            b;
        for (var i = 1; i < l; i++) {
            b = points[i];
            // angle in (-PI, PI]
            segmentAngle = Math.atan2(a.y - b.y, a.x - b.x);
            // angle in (-1.5 * PI, PI/2]
            offsetAngle = segmentAngle - Math.PI / 2;
            // store offset point and other information to avoid recomputing it later
            offsetSegments.push({
                angle: segmentAngle,
                offsetAngle: offsetAngle,
                distance: distance,
                original: [a, b],
                offset: [
                    this.translatePoint(a, distance, offsetAngle),
                    this.translatePoint(b, distance, offsetAngle)
                ]
            });
            a = b;
        }
        return offsetSegments;
    };

    obj.joinLineSegments = function (segments, offset, joinStyle) {
        var l = segments.length;
        var joinedPoints = [];
        var s1 = segments[0];
        var s2 = segments[0];
        joinedPoints.push(s1.offset[0]);

        for (var i = 1; i < l; i++) {
            s2 = segments[i];
            joinedPoints = joinedPoints.concat(this.joinSegments(s1, s2, offset, joinStyle));
            s1 = s2;
        }
        joinedPoints.push(s2.offset[1]);

        return joinedPoints;
    };
    return obj;
};


/**
 * Created by xujie3949 on 2016/12/8.
 */

fastmap.mapApi.scene.SceneLayer = L.Class.extend({
    options: {
        visible: true,
        editable: true
    },

    initialize: function (id, config) {
        FM.setOptions(this, config.options);

        this.id = id;
        this.name = config.name || '未命名';
        this.type = config.type;
        this.label = config.label || '未定义';
    },

    setOptions: function (options) {
        return FM.setOptions(this, options);
    },

    setLeafletLayer: function (leafletLayer) {
        this._leafletLayer = leafletLayer;
    },

    setLabel: function (label) {
        this.label = label || '未定义';
    },

    setVisible: function (flag) {
        this.options.visible = flag === undefined ? true : flag;
    },

    getOptions: function () {
        return this.options;
    },

    getLeafletLayer: function () {
        return this._leafletLayer;
    },

    getFeatureType: function () {
        return this.options.featureType || null;
    },

    getRender: function () {
        return this.options.render || null;
    },

    getSourceName: function () {
        return this.options.source || null;
    },

    visible: function () {
        return this.options.visible === undefined ? true : this.options.visible;
    },

    canDraw: function (zoom) {
        if (this.type !== 'vector') {
            // 非vector的图层是否显示直接交给leaflet图层控制
            return true;
        }
        if (!this.options) {
            // vector图层如果无Opitions，则不允许绘制
            return false;
        }
        var sourceName = this.options.source;
        var visible = this.options.visible;
        var featureType = this.options.featureType;
        if (!visible || !sourceName || !featureType) {
            return false;
        }

        var minZoom = this.options.minZoom;
        var maxZoom = this.options.maxZoom;
        if (zoom < minZoom || zoom > maxZoom) {
            return false;
        }

        return true;
    },

    useSameData: function (layer) {
        if (this.type !== layer.type) {
            return false;
        }
        if (this.options.source !== layer.options.source) {
            return false;
        }
        if (this.options.featureType !== layer.options.featureType) {
            return false;
        }

        return true;
    },

    clone: function () {
        var options = {
            name: this.name,
            type: this.type,
            label: this.label,
            options: this.options
        };
        return new fastmap.mapApi.scene.SceneLayer(this.id, options);
    },

    isEditable: function () {
        return this.options.editable;
    }
});

/**
 * Created by xujie3949 on 2016/12/8.
 */

fastmap.mapApi.scene.Scene = L.Class.extend({
    initialize: function (id, config) {
        this.id = id;
        this.name = config.name || '未命名';
        this.type = config.type;
        this.label = config.label;
        this.layers = [];
    },

    addLayer: function (sceneLayer) {
        this.layers.push(sceneLayer);
    },

    removeLayer: function (sceneLayer) {
        var index = this.layers.indexOf(sceneLayer);

        this.layers.splice(index, 1);
    },

    getLayerById: function (sceneLayerId) {
        var layer;
        for (var i = 0; i < this.layers.length; ++i) {
            layer = this.layers[i];
            if (layer.id === sceneLayerId) {
                return layer;
            }
        }

        return null;
    },

    contains: function (layerId) {
        var layer;
        for (var i = 0; i < this.layers.length; ++i) {
            layer = this.layers[i];
            if (layer.id === layerId) {
                return true;
            }
        }

        return false;
    }
});

/**
 * Created by xujie on 2017/01/11
 * Recreated by chenx on 2017-5-12
 * 场景管理
 */
FM.mapApi.scene.SceneController = L.Class.extend({
    initialize: function () {
        this._map = null;
        this._currentScene = null;

        this._scenes = [];
        this._layers = [];

        // 记录必须放置在最底层的图层
        this._backgrounds = [];
        // 记录必须放置在最顶层的图层
        this._overlays = [];
        // 记录临时添加到地图中显示的图层，切换场景后会清空
        this._temporaries = [];
        // 记录加载到当前场景的图层，包含_temporaries
        this._sceneLayers = [];
    },

    setMap: function (map) {
        this._map = map;
    },

    getLeafletMap: function () {
        return this._map.getLeafletMap();
    },

    getZoom: function () {
        return this._map.getZoom();
    },

    setDefaultZoom: function (config) {
        config = config || {};
        this.defaultZoom = {
            minZoom: config.minZoom || 1,
            maxZoom: config.maxZoom || 20,
            minEditZoom: config.minEditZoom || 17
        };
    },

    loadLayers: function (config, label) {
        var keys = Object.getOwnPropertyNames(config);
        var key,
            value,
            layer;
        for (var i = 0; i < keys.length; ++i) {
            key = keys[i];
            value = config[key];
            if (this.getLayerById(key)) {
                throw new Error('图层ID存在重复:' + key);
            }
            value.label = value.label || label || 'None';

            if (this.defaultZoom) {
                value.options = value.options || {};
                value.options.minZoom = value.options.minZoom || this.defaultZoom.minZoom;
                value.options.maxZoom = value.options.maxZoom || this.defaultZoom.maxZoom;
                if (value.type === 'vector') {
                    value.options.minEditZoom = value.options.minEditZoom || this.defaultZoom.minEditZoom;
                }
            }

            layer = new FM.mapApi.scene.SceneLayer(key, value);
            this._layers.push(layer);
        }
    },

    _createScene: function (sceneId, config) {
        var scene = new FM.mapApi.scene.Scene(sceneId, config);

        var orderedLayers = [];
        var item,
            sceneLayer,
            label,
            tempLayers;

        // 注意：场景中图层的配置顺序决定了图层的加载顺序
        var i,
            j;
        for (i = 0; i < config.layers.length; ++i) {
            item = config.layers[i];
            sceneLayer = this.getLayerById(item);
            if (sceneLayer) {
                scene.addLayer(sceneLayer);
            } else if (item.charAt(0) === '[' && item.charAt(item.length - 1) === ']') {
                label = item.slice(1, item.length - 1);
                tempLayers = this.getLayersByLabel(label);
                for (j = 0; j < tempLayers.length; j++) {
                    scene.addLayer(tempLayers[j]);
                }
            } else {
                throw new Error('场景配置的图层不存在:' + item);
            }
        }
        return scene;
    },

    loadScenes: function (config) {
        var keys = Object.getOwnPropertyNames(config.scenes);
        var key,
            value;
        var scene;
        for (var i = 0; i < keys.length; ++i) {
            key = keys[i];
            value = config.scenes[key];
            if (this.getSceneById(key)) {
                throw new Error('场景ID存在重复:' + key);
            }
            scene = this._createScene(key, value);
            this._scenes.push(scene);
        }

        if (config.defaultScene) {
            this.changeScene(config.defaultScene);
        }
    },

    loadBackground: function (list) {
        var layer;
        for (var i = 0; i < list.length; i++) {
            layer = this.getLayerById(list[i]);
            if (!layer) {
                throw new Error('Background配置的图层ID不存在:' + list[i]);
            }
            this._addToBackground(layer);
        }

        this.refreshBackground();
    },

    loadOverlay: function (list) {
        var layer;
        for (var i = 0; i < list.length; i++) {
            layer = this.getLayerById(list[i]);
            if (!layer) {
                throw new Error('Overlay配置的图层ID不存在:' + list[i]);
            }
            this._addToOverlay(layer);
        }

        this.refreshOverlay();
    },

    _addToBackground: function (sceneLayer) {
        var layer = sceneLayer.clone();
        this._map.addLayer(layer);
        this._backgrounds.push(layer);

        return layer;
    },

    addToBackground: function (sceneLayer) {
        this._addToBackground(sceneLayer);

        this.refreshBackground();
    },

    removeFromBackground: function (sceneLayerId) {
        var layer;
        for (var i = 0; i < this._backgrounds.length; i++) {
            layer = this._backgrounds[i];
            if (layer.id === sceneLayerId) {
                this._map.removeLayer(layer);
                this._backgrounds.splice(i, 1);
                break;
            }
        }
        this._map.refresh();
    },

    _resetBackground: function () {
        var leafletLayer;
        for (var i = this._backgrounds.length - 1; i >= 0; i--) {
            leafletLayer = this._backgrounds[i].getLeafletLayer();
            leafletLayer.bringToBack();
        }
    },

    refreshBackground: function () {
        this._resetBackground();
        this._map.refresh();
    },

    _addToOverlay: function (sceneLayer) {
        var layer = sceneLayer.clone();
        this._map.addLayer(layer);
        this._overlays.push(layer);

        return layer;
    },

    addToOverlay: function (sceneLayer) {
        this._addToOverlay(sceneLayer);

        this.refreshOverlay();
    },

    removeFromOverlay: function (sceneLayerId) {
        var layer;
        for (var i = 0; i < this._overlays.length; i++) {
            layer = this._overlays[i];
            if (layer.id === sceneLayerId) {
                this._map.removeLayer(layer);
                this._overlays.splice(i, 1);
                break;
            }
        }
        this._map.refresh();
    },

    _resetOverlay: function () {
        var leafletLayer;
        for (var i = 0; i < this._overlays.length; i++) {
            leafletLayer = this._overlays[i].getLeafletLayer();
            leafletLayer.bringToFront();
        }
    },

    refreshOverlay: function () {
        this._resetOverlay();
        this._map.refresh();
    },

    _addToScene: function (sceneLayer) {
        var layer = sceneLayer.clone();
        this._map.addLayer(layer);
        this._sceneLayers.push(layer);

        return layer;
    },

    addToScene: function (sceneLayers) {
        var layers;
        if (FM.Util.isObject(sceneLayers)) {
            layers = [sceneLayers];
        } else if (FM.Util.isArray(sceneLayers)) {
            layers = sceneLayers;
        }
        if (!layers || layers.length === 0) {
            return;
        }

        for (var i = 0; i < layers.length; i++) {
            this._addToScene(layers[i]);
        }

        this.refreshOverlay();
    },

    removeFromScene: function (sceneLayerIds) {
        var ids,
            layer;
        if (FM.Util.isArray(sceneLayerIds)) {
            ids = sceneLayerIds;
        } else if (sceneLayerIds) {
            ids = [sceneLayerIds];
        }
        if (!ids || ids.length === 0) {
            return;
        }

        for (var i = this._sceneLayers.length - 1; i >= 0; i--) {
            layer = this._sceneLayers[i];
            if (ids.indexOf(layer.id) >= 0) {
                this._map.removeLayer(layer);
                this._sceneLayers.splice(i, 1);
            }
        }
        this._map.refresh();
    },

    _clearScene: function () {
        for (var i = 0; i < this._sceneLayers.length; i++) {
            this._map.removeLayer(this._sceneLayers[i]);
        }
        this._temporaries.length = 0;
        this._sceneLayers.length = 0;
    },

    addToTemporary: function (layers) {
        var addLayer;
        for (var i = 0; i < layers.length; i++) {
            this._temporaries.push(this._addToScene(layers[i]));
        }

        this.refreshOverlay();
    },

    removeFromTemporary: function (temporaryLayerIds) {
        var ids,
            layer;
        if (FM.Util.isArray(temporaryLayerIds)) {
            ids = temporaryLayerIds;
        } else if (temporaryLayerIds) {
            ids = [temporaryLayerIds];
        }
        if (!ids || ids.length === 0) {
            return;
        }

        for (var i = this._temporaries.length - 1; i >= 0; i--) {
            layer = this._temporaries[i];
            if (ids.indexOf(layer.id) >= 0) {
                this._temporaries.splice(i, 1);
            }
        }

        this.removeFromScene(temporaryLayerIds);
    },

    clearTemporary: function () {
        var ids = [];
        for (var i = 0; i < this._temporaries.length; i++) {
            ids.push(this._temporaries[i].id);
        }

        this.removeFromScene(ids);

        this._temporaries.length = 0;
    },

    getScenes: function () {
        return this._scenes;
    },

    getCurrentScene: function () {
        return this._currentScene;
    },

    getSceneById: function (sceneId) {
        for (var i = 0; i < this._scenes.length; i++) {
            if (this._scenes[i].id === sceneId) {
                return this._scenes[i];
            }
        }
        return null;
    },

    getLayers: function () {
        return this._layers;
    },

    getLayerById: function (layerId) {
        for (var i = 0; i < this._layers.length; i++) {
            if (this._layers[i].id === layerId) {
                return this._layers[i];
            }
        }
        return null;
    },

    getLayersByLabel: function (label) {
        var layers = [];
        for (var i = 0; i < this._layers.length; i++) {
            if (this._layers[i].label === label) {
                layers.push(this._layers[i]);
            }
        }
        return layers;
    },

    getLayersBySourceName: function (sourceName) {
        var layers = [];
        for (var i = 0; i < this._layers.length; i++) {
            if (this._layers[i].getSourceName() === sourceName) {
                layers.push(this._layers[i]);
            }
        }
        return layers;
    },

    getLayersByFeatureType: function (featureType, label) {
        var layers = [];
        var layer;
        var type;
        for (var i = 0; i < this._layers.length; i++) {
            layer = this._layers[i];
            type = layer.getFeatureType();
            if (!type || type !== featureType) {
                continue;
            }
            if (label && (!layer.label || layer.label !== label)) {
                continue;
            }

            layers.push(layer);
        }

        return layers;
    },

    getBackgroundLayers: function () {
        return this._backgrounds;
    },

    getOverlayLayers: function () {
        return this._overlays;
    },

    getTemporaryLayers: function () {
        return this._temporaries;
    },

    getSceneLayers: function () {
        return this._sceneLayers;
    },

    getLoadedLayers: function () {
        var layers = [];
        Array.prototype.push.apply(layers, this._backgrounds);
        Array.prototype.push.apply(layers, this._sceneLayers);
        Array.prototype.push.apply(layers, this._overlays);

        return layers;
    },

    getLoadedLayersByFeatureType: function (featureType) {
        var layers = [];
        var i;
        for (i = 0; i < this._backgrounds.length; i++) {
            if (this._backgrounds[i].getFeatureType() === featureType) {
                layers.push(this._backgrounds[i]);
            }
        }

        for (i = 0; i < this._sceneLayers.length; i++) {
            if (this._sceneLayers[i].getFeatureType() === featureType) {
                layers.push(this._sceneLayers[i]);
            }
        }

        for (i = 0; i < this._overlays.length; i++) {
            if (this._overlays[i].getFeatureType() === featureType) {
                layers.push(this._overlays[i]);
            }
        }

        return layers;
    },

    getLoadedFeatureTypes: function () {
        var types = [];
        var i;
        var type;
        for (i = 0; i < this._backgrounds.length; i++) {
            type = this._backgrounds[i].getFeatureType();
            if (type) {
                types.push(type);
            }
        }

        for (i = 0; i < this._sceneLayers.length; i++) {
            type = this._sceneLayers[i].getFeatureType();
            if (type) {
                types.push(type);
            }
        }

        for (i = 0; i < this._overlays.length; i++) {
            type = this._overlays[i].getFeatureType();
            if (type) {
                types.push(type);
            }
        }

        return FM.Util.unique(types);
    },

    getEditableFeatureTypes: function () {
        var types = [];
        var type;
        var i;
        var editable = true;

        for (i = 0; i < this._backgrounds.length; i++) {
            type = this._backgrounds[i].getFeatureType();
            editable = this._backgrounds[i].isEditable();

            if (type && editable) {
                types.push(type);
            }
        }

        for (i = 0; i < this._sceneLayers.length; i++) {
            type = this._sceneLayers[i].getFeatureType();
            editable = this._sceneLayers[i].isEditable();

            if (type && editable) {
                types.push(type);
            }
        }

        for (i = 0; i < this._overlays.length; i++) {
            type = this._overlays[i].getFeatureType();
            editable = this._overlays[i].isEditable();

            if (type && editable) {
                types.push(type);
            }
        }

        return FM.Util.unique(types);
    },

    changeScene: function (sceneId) {
        var i;
        if (this._currentScene && this._currentScene.id === sceneId) {
            return null;
        }

        var oldScene = this._currentScene;

        this._clearScene();

        var scene = this.getSceneById(sceneId);
        for (i = 0; i < scene.layers.length; i++) {
            this._addToScene(scene.layers[i]);
        }

        this.refreshOverlay();

        this._currentScene = scene;

        this._map._leafletMap.fire('SceneChanged', {
            oldScene: oldScene,
            newScene: scene
        });

        return scene;
    },

    _resetScene: function () {
        var i;
        for (i = 0; i < this._sceneLayers.length; i++) {
            this._map.removeLayer(this._sceneLayers[i]);
        }

        for (i = 0; i < this._sceneLayers.length; i++) {
            this._map.addLayer(this._sceneLayers[i]);
        }
    },

    refreshScene: function () {
        this._resetScene();

        this._resetBackground();

        this._resetOverlay();

        this._map.refresh();
    },

    isLayerLoaded: function (layerId) {
        var i;
        for (i = 0; i < this._backgrounds.length; i++) {
            if (this._backgrounds[i].visible() && this._backgrounds[i].id === layerId) {
                return true;
            }
        }

        for (i = 0; i < this._sceneLayers.length; i++) {
            if (this._sceneLayers[i].visible() && this._sceneLayers[i].id === layerId) {
                return true;
            }
        }

        for (i = 0; i < this._overlays.length; i++) {
            if (this._overlays[i].visible() && this._overlays[i].id === layerId) {
                return true;
            }
        }

        return false;
    },

    refreshMap: function () {
        this._map.refresh();
    },

    redrawLayerByGeoLiveTypes: function (featureTypes) {
        var layers = [];
        var temp = this.getLoadedLayers();
        var type;
        for (var i = 0; i < temp.length; i++) {
            type = temp[i].getFeatureType();
            if (type && featureTypes.indexOf(type) >= 0) {
                layers.push(temp[i]);
            }
        }

        if (layers.length > 0) {
            this._map.redraw(layers);
        }
    },

    destroy: function () {
        FM.mapApi.scene.SceneController.instance = null;
    },

    statics: {
        instance: null,

        getInstance: function () {
            if (!FM.mapApi.scene.SceneController.instance) {
                FM.mapApi.scene.SceneController.instance =
                    new FM.mapApi.scene.SceneController();
            }
            return FM.mapApi.scene.SceneController.instance;
        }
    }
});

/**
 * Created by xujie3949 on 2016/12/8.
 */

fastmap.mapApi.snap.SnapActor = L.Class.extend({
    initialize: function () {
        this.type = '';
        // commented by chenx on 2017-8-9
        // 为了解决按照最近距离捕捉的算法，图幅线捕捉永远距离最近的问题（坐标转换精度导致）
        // 对于优先级在0及以上的捕捉器，采用最近距离捕捉
        // 对于优先级小于0的捕捉器，采用有无捕捉，即优先级高的捕捉器捕捉到要素后就停止捕捉
        this.priority = 0;
        this.point = null;
        this.isSnapped = false;
        this.map = null;

        this.symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();
        this.geometryFactory = fastmap.mapApi.symbol.GeometryFactory.getInstance();
        this.geometryAlgorithm = fastmap.mapApi.geometry.GeometryAlgorithm.getInstance();
        this.sourceController = fastmap.mapApi.source.SourceController.getInstance();
        this.sceneController = fastmap.mapApi.scene.SceneController.getInstance();
        this.geometryTransform = fastmap.mapApi.GeometryTransform.getInstance();
        this.featureSelector = fastmap.mapApi.FeatureSelector.getInstance();
        this.feedbackController = fastmap.mapApi.FeedbackController.getInstance();
        this.feedback = new fastmap.mapApi.Feedback();
        this.feedback.priority = 999999;

        this.startup();
    },

    snap: function (point, box) {
        this.isSnapped = false;
        this.point = null;
        return this.getSnapResult();
    },

    draw: function () {
        this.feedback.clear();

        if (!this.isSnapped) {
            this.feedbackController.refresh();
            return;
        }

        var symbol = this.symbolFactory.getSymbol('snap_pt_cross');
        this.feedback.add(this.point, symbol);

        this.feedbackController.refresh();
    },

    clear: function () {
        this.feedback.clear();
        this.feedbackController.refresh();
    },

    shutdown: function () {
        this.feedbackController.del(this.feedback);
        this.feedbackController.refresh();
    },

    startup: function () {
        this.feedbackController.add(this.feedback);
        this.feedbackController.refresh();
    },

    getSnapResult: function () {
        if (!this.isSnapped) {
            return null;
        }

        return {
            type: this.type,
            point: this.point
        };
    },

    getPriority: function () {
        return this.priority;
    },

    setMap: function (map) {
        this.map = map;
    },

    getMap: function (map) {
        return this.map;
    },

    distance: function (geometry1, geometry2) {
        var self = this;
        this.geometryTransform.setEnviroment(this.map, null, this.latlngToMercator);
        var pGeometry1 = this.geometryTransform.convertGeometry(geometry1);
        var pGeometry2 = this.geometryTransform.convertGeometry(geometry2);
        return this.geometryAlgorithm.distance(pGeometry1, pGeometry2);
    },

    nearestPoints: function (geometry1, geometry2) {
        var self = this;
        this.geometryTransform.setEnviroment(this.map, null, this.latlngToMercator);
        var pGeometry1 = this.geometryTransform.convertGeometry(geometry1);
        var pGeometry2 = this.geometryTransform.convertGeometry(geometry2);
        var res = this.geometryAlgorithm.nearestPoints(pGeometry1, pGeometry2);
        this.geometryTransform.setEnviroment(this.map, null, this.mercatorToLatlng);
        res.point1 = this.geometryTransform.convertGeometry(res.point1);
        res.point2 = this.geometryTransform.convertGeometry(res.point2);
        return res;
    },

    nearestLocations: function (geometry1, geometry2) {
        var self = this;
        this.geometryTransform.setEnviroment(this.map, null, this.latlngToMercator);
        var pGeometry1 = this.geometryTransform.convertGeometry(geometry1);
        var pGeometry2 = this.geometryTransform.convertGeometry(geometry2);
        var res = this.geometryAlgorithm.nearestLocations(pGeometry1, pGeometry2);
        this.geometryTransform.setEnviroment(this.map, null, this.mercatorToLatlng);
        res.point = this.geometryTransform.convertGeometry(res.point);
        res.previousPoint = this.geometryTransform.convertGeometry(res.previousPoint);
        res.nextPoint = this.geometryTransform.convertGeometry(res.nextPoint);
        return res;
    },

    latlngToMercator: function (map, tile, coordinates) {
        var x = coordinates[0];
        var y = coordinates[1];
        var point = map.project([y, x]);
        return [point.x, point.y];
    },

    mercatorToLatlng: function (map, tile, coordinates) {
        var x = coordinates[0];
        var y = coordinates[1];
        var latlng = map.unproject([x, y]);
        return [latlng.lng, latlng.lat];
    },

    /**
     * 判断两个几何是否相交
     * @param  {[type]} geometry1 [description]
     * @param  {[type]} geometry2 [description]
     * @return {Boolean}          [description]
     */
    intersects: function (geometry1, geometry2) {
        var self = this;
        this.geometryTransform.setEnviroment(this.map, null, this.latlngToMercator);
        var pGeometry1 = this.geometryTransform.convertGeometry(geometry1);
        var pGeometry2 = this.geometryTransform.convertGeometry(geometry2);
        return this.geometryAlgorithm.intersects(pGeometry1, pGeometry2);
    }
});

/**
 * Created by xujie3949 on 2016/12/8.
 */

fastmap.mapApi.snap.FeatureSnapActor = fastmap.mapApi.snap.SnapActor.extend({
    initialize: function () {
        fastmap.mapApi.snap.SnapActor.prototype.initialize.apply(this, arguments);

        this.type = 'FeatureSnapActor';
        this.feature = null;
        this.layerId = '';
        this.snapExceptions = [];
        this.snapFunction = null;
    },

    snap: function (point, box) {
        fastmap.mapApi.snap.SnapActor.prototype.snap.apply(this, arguments);
        this.feature = null;

        if (!this.layerId) {
            return null;
        }

        var features = this.featureSelector.selectByGeometry(box, [this.layerId]);

        if (features.length === 0) {
            return null;
        }

        var minDis = Number.MAX_VALUE;
        for (var i = 0; i < features.length; ++i) {
            var feature = features[i];
            if (this.isSnapException(feature.properties.id)) {
                continue;
            }

            if (this.snapFunction && !this.snapFunction(feature)) {
                continue;
            }

            var res = this.nearestPoints(point, feature.geometry);
            if (res.distance < minDis) {
                minDis = res.distance;
                this.point = res.point2;
                this.feature = feature;
                this.isSnapped = true;
            }
        }

        return this.getSnapResult();
    },

    getSnapResult: function () {
        if (!this.isSnapped) {
            return null;
        }

        var result = fastmap.mapApi.snap.SnapActor.prototype.getSnapResult.apply(this, arguments);
        result.feature = this.feature;
        return result;
    },

    addSnapException: function (id) {
        for (var i = 0; i < this.snapExceptions.length; ++i) {
            if (id === this.snapExceptions[i]) {
                return;
            }
        }

        this.snapExceptions.push(id);
    },

    delSnapException: function (id) {
        for (var i = 0; i < this.snapExceptions.length; ++i) {
            if (id === this.snapExceptions[i]) {
                this.snapExceptions.splice(i, 1);
                return;
            }
        }
    },

    clearSnapException: function () {
        this.snapExceptions = [];
    },

    isSnapException: function (id) {
        for (var i = 0; i < this.snapExceptions.length; ++i) {
            if (id === this.snapExceptions[i]) {
                return true;
            }
        }
        return false;
    },

    setSnapFunction: function (func) {
        this.snapFunction = func;
    }
});

/**
 * Created by xujie3949 on 2016/12/8.
 */

fastmap.mapApi.snap.FullScreenFeatureSnapActor = fastmap.mapApi.snap.SnapActor.extend({
    initialize: function () {
        fastmap.mapApi.snap.SnapActor.prototype.initialize.apply(this, arguments);

        this.type = 'FullScreenFeatureSnapActor';
        this.feature = null;
        this.layerId = '';
        this.snapExceptions = [];
        this.snapFunction = null;
    },

    snap: function (point, box) {
        fastmap.mapApi.snap.SnapActor.prototype.snap.apply(this, arguments);
        this.feature = null;

        if (!this.layerId) {
            return null;
        }

        var features = this.featureSelector.selectByGeoLiveType(this.layerId);

        if (features.length === 0) {
            return null;
        }

        var minDis = Number.MAX_VALUE;
        for (var i = 0; i < features.length; ++i) {
            var feature = features[i];
            if (this.isSnapException(feature.properties.id)) {
                continue;
            }

            if (this.snapFunction && !this.snapFunction(feature)) {
                continue;
            }

            var res = this.nearestPoints(point, feature.geometry);
            if (res.distance < minDis) {
                minDis = res.distance;
                this.point = res.point2;
                this.feature = feature;
                this.isSnapped = true;
            }
        }

        return this.getSnapResult();
    },

    getSnapResult: function () {
        if (!this.isSnapped) {
            return null;
        }

        var result = fastmap.mapApi.snap.SnapActor.prototype.getSnapResult.apply(this, arguments);
        result.feature = this.feature;
        return result;
    },

    addSnapException: function (id) {
        for (var i = 0; i < this.snapExceptions.length; ++i) {
            if (id === this.snapExceptions[i]) {
                return;
            }
        }

        this.snapExceptions.push(id);
    },

    delSnapException: function (id) {
        for (var i = 0; i < this.snapExceptions.length; ++i) {
            if (id === this.snapExceptions[i]) {
                this.snapExceptions.splice(i, 1);
                return;
            }
        }
    },

    clearSnapException: function () {
        this.snapExceptions = [];
    },

    isSnapException: function (id) {
        for (var i = 0; i < this.snapExceptions.length; ++i) {
            if (id === this.snapExceptions[i]) {
                return true;
            }
        }
        return false;
    },

    setSnapFunction: function (func) {
        this.snapFunction = func;
    }
});

/**
 * Created by xujie3949 on 2016/12/8.
 */

fastmap.mapApi.snap.GivenPointSnapActor = fastmap.mapApi.snap.SnapActor.extend({
    initialize: function () {
        fastmap.mapApi.snap.SnapActor.prototype.initialize.apply(this, arguments);

        this.type = 'GivenPointSnapActor';
        this.value = null;
        this.pairs = [];
    },

    snap: function (point, box) {
        fastmap.mapApi.snap.SnapActor.prototype.snap.apply(this, arguments);
        this.value = null;

        if (!this.pairs) {
            return null;
        }

        var minDis = Number.MAX_VALUE;
        for (var i = 0; i < this.pairs.length; ++i) {
            var pair = this.pairs[i];
            var tmpPoint = pair.key;
            var tmpValue = pair.value;
            var dis = this.distance(point, tmpPoint);
            if (dis < minDis) {
                minDis = dis;
                this.point = tmpPoint;
                this.value = tmpValue;
                this.isSnapped = true;
            }
        }

        return this.getSnapResult();
    },

    getSnapResult: function () {
        if (!this.isSnapped) {
            return null;
        }

        var result = fastmap.mapApi.snap.SnapActor.prototype.getSnapResult.apply(this, arguments);
        result.value = this.value;
        return result;
    },

    draw: function () {
        fastmap.mapApi.snap.SnapActor.prototype.draw.apply(this, arguments);

        if (!this.isSnapped) {
            return;
        }

        if (this.pairs) {
            for (var i = 0; i < this.pairs.length; ++i) {
                var pair = this.pairs[i];
                var symbol = this.symbolFactory.getSymbol('snap_pt_given_point');
                this.feedback.add(pair.key, symbol);
            }
        }

        this.feedbackController.refresh();
    },

    addPair: function (point, value) {
        var pair = {
            key: point,
            value: value
        };
        this.pairs.push(pair);
    },

    clearPairs: function () {
        this.pairs = [];
    }
});

/**
 * Created by xujie3949 on 2016/12/8.
 */

fastmap.mapApi.snap.GivenFeatureSnapActor = fastmap.mapApi.snap.SnapActor.extend({
    initialize: function () {
        fastmap.mapApi.snap.SnapActor.prototype.initialize.apply(this, arguments);

        this.type = 'GivenFeatureSnapActor';
        this.feature = null;
        this.features = [];
    },

    snap: function (point, box) {
        fastmap.mapApi.snap.SnapActor.prototype.snap.apply(this, arguments);
        this.feature = null;

        if (!this.features) {
            return null;
        }

        if (this.features.length === 0) {
            return null;
        }

        var minDis = Number.MAX_VALUE;
        for (var i = 0; i < this.features.length; ++i) {
            var feature = this.features[i];
            // add by chenx on 2017-5-2，处理不在地图可视范围内的情况
            if (feature.unloaded) {
                feature = this.featureSelector.selectByFeatureId(feature.id, feature.geoLiveType);
                if (feature) {
                    this.features.splice(i, 1, feature);
                } else {
                    continue;
                }
            }
            var res = this.nearestPoints(point, feature.geometry);
            if (res.distance < minDis) {
                minDis = res.distance;
                this.point = res.point2;
                this.feature = feature;
                this.isSnapped = true;
            }
        }

        return this.getSnapResult();
    },

    setFeatures: function (features) {
        var items = features;
        for (var i = 0; i < items.length; ++i) {
            var item = items[i];

            var feature = this.featureSelector.selectByFeatureId(item.id, item.geoLiveType);
            if (!feature) { // add by chenx on 2017-5-2，处理不在地图可视范围内的情况
                this.features.push({
                    id: item.id,
                    geoLiveType: item.geoLiveType,
                    unloaded: true
                });
            } else {
                this.features.push(feature);
            }
        }
    },

    getSnapResult: function () {
        if (!this.isSnapped) {
            return null;
        }

        var result = fastmap.mapApi.snap.SnapActor.prototype.getSnapResult.apply(this, arguments);
        result.feature = this.feature;
        return result;
    }
});

/**
 * Created by xujie3949 on 2016/12/8.
 */

fastmap.mapApi.snap.GivenObjectSnapActor = fastmap.mapApi.snap.SnapActor.extend({
    initialize: function () {
        fastmap.mapApi.snap.SnapActor.prototype.initialize.apply(this, arguments);

        this.type = 'GivenObjectSnapActor';
        this.feature = null;
        this.features = [];
    },

    snap: function (point, box) {
        fastmap.mapApi.snap.SnapActor.prototype.snap.apply(this, arguments);
        this.feature = null;

        if (this.features.length === 0) {
            return null;
        }

        var minDis = Number.MAX_VALUE;
        for (var i = 0; i < this.features.length; ++i) {
            var feature = this.features[i];
            var res = this.nearestPoints(point, feature.geometry);
            if (res.distance < minDis) {
                minDis = res.distance;
                this.point = res.point2;
                this.feature = feature;
                this.isSnapped = true;
            }
        }

        return this.getSnapResult();
    },

    setObjects: function (features) {
        this.features = [];
        Array.prototype.push.apply(this.features, features);
    },

    getSnapResult: function () {
        if (!this.isSnapped) {
            return null;
        }

        var result = fastmap.mapApi.snap.SnapActor.prototype.getSnapResult.apply(this, arguments);
        result.feature = this.feature;
        return result;
    }
});

/**
 * Created by xujie3949 on 2016/12/8.
 */

fastmap.mapApi.snap.NearestLocationSnapActor = fastmap.mapApi.snap.SnapActor.extend({
    initialize: function () {
        fastmap.mapApi.snap.SnapActor.prototype.initialize.apply(this, arguments);

        this.type = 'NearestLocationSnapActor';
        this.loc = null;
        this.geometry = null;
    },

    snap: function (point, box) {
        fastmap.mapApi.snap.SnapActor.prototype.snap.apply(this, arguments);
        this.value = null;

        if (!this.geometry) {
            return null;
        }

        this.loc = this.nearestLocations(point, this.geometry);
        this.point = this.loc.point;
        this.isSnapped = true;

        return this.getSnapResult();
    },

    getSnapResult: function () {
        if (!this.isSnapped) {
            return null;
        }

        var result = fastmap.mapApi.snap.SnapActor.prototype.getSnapResult.apply(this, arguments);
        result.nearestLoactions = this.loc;
        return result;
    }
});

/**
 * Created by xujie3949 on 2016/12/8.
 */

fastmap.mapApi.snap.NearestVertexSnapActor = fastmap.mapApi.snap.SnapActor.extend({
    initialize: function () {
        fastmap.mapApi.snap.SnapActor.prototype.initialize.apply(this, arguments);

        this.type = 'NearestVertexSnapActor';
        this.index = null;
        this.geometry = null;
        this.canSnapStart = true;
        this.canSnapEnd = true;
    },

    snap: function (point, box) {
        fastmap.mapApi.snap.SnapActor.prototype.snap.apply(this, arguments);
        this.value = null;

        if (!this.geometry) {
            return null;
        }

        var minDis = Number.MAX_VALUE;
        for (var i = 0; i < this.geometry.coordinates.length; i++) {
            if (!this.canSnapStart && i === 0) {
                continue;
            }
            if (!this.canSnapEnd && i === this.geometry.coordinates.length - 1) {
                continue;
            }
            var coordinates = this.geometry.coordinates[i];
            var vertex = this.coordinatesToPoint(coordinates);
            var dis = this.distance(point, vertex);
            if (dis < minDis) {
                minDis = dis;
                this.point = vertex;
                this.index = i;
                this.isSnapped = true;
            }
        }

        return this.getSnapResult();
    },

    getSnapResult: function () {
        if (!this.isSnapped) {
            return null;
        }

        var result = fastmap.mapApi.snap.SnapActor.prototype.getSnapResult.apply(this, arguments);
        result.index = this.index;
        return result;
    },

    draw: function () {
        fastmap.mapApi.snap.SnapActor.prototype.draw.apply(this, arguments);

        if (!this.isSnapped) {
            return;
        }

        if (this.geometry) {
            for (var i = 0; i < this.geometry.coordinates.length; ++i) {
                if (!this.canSnapStart && i === 0) {
                    continue;
                }
                if (!this.canSnapEnd && i === this.geometry.coordinates.length - 1) {
                    continue;
                }
                var coordinates = this.geometry.coordinates[i];
                var vertex = this.coordinatesToPoint(coordinates);
                var symbol = this.symbolFactory.getSymbol('snap_pt_vertex');
                this.feedback.add(vertex, symbol);
            }
        }

        this.feedbackController.refresh();
    },

    coordinatesToPoint: function (coordinates) {
        var point = {
            type: 'Point',
            coordinates: coordinates
        };
        return point;
    }
});

/**
 * Created by xujie3949 on 2016/12/8.
 */

fastmap.mapApi.snap.MeshBorderSnapActor = fastmap.mapApi.snap.SnapActor.extend({
    initialize: function () {
        fastmap.mapApi.snap.SnapActor.prototype.initialize.apply(this, arguments);

        this.meshAlgm = fastmap.mapApi.MeshAlgorithm.getInstance();
        this.type = 'MeshBorderSnapActor';
    },

    snap: function (point, box) {
        fastmap.mapApi.snap.SnapActor.prototype.snap.apply(this, arguments);

        var borderLines = this._getMeshBorderLines(point);

        var minDist = Number.MAX_VALUE;
        for (var i = 0; i < borderLines.length; i++) {
            if (this.intersects(box, borderLines[i])) {
                var rest = this.nearestPoints(point, borderLines[i]);
                if (rest.distance < minDist) {
                    minDist = rest.distance;
                    this.point = rest.point2;
                    this.isSnapped = true;
                }
            }
        }

        return this.getSnapResult();
    },

    _getMeshBorderLines: function (point) {
        var latLon = {
            lng: point.coordinates[0],
            lat: point.coordinates[1]
        };
        var border = this.meshAlgm.Calculate25TMeshBorder(this.meshAlgm.Calculate25TMeshId(latLon));

        var lines = [];
        lines.push({
            type: 'LineString',
            coordinates: [
                [border.minLon, border.minLat],
                [border.minLon, border.maxLat]
            ]
        });
        lines.push({
            type: 'LineString',
            coordinates: [
                [border.minLon, border.maxLat],
                [border.maxLon, border.maxLat]
            ]
        });
        lines.push({
            type: 'LineString',
            coordinates: [
                [border.maxLon, border.maxLat],
                [border.maxLon, border.minLat]
            ]
        });
        lines.push({
            type: 'LineString',
            coordinates: [
                [border.maxLon, border.minLat],
                [border.minLon, border.minLat]
            ]
        });

        return lines;
    }
});

/**
 * Created by xujie3949 on 2016/12/8.
 */

fastmap.mapApi.snap.SnapController = L.Class.extend({
    initialize: function (options) {
        this.feedbackController = fastmap.mapApi.FeedbackController.getInstance();
        this.symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();
        this.geometryFactory = fastmap.mapApi.symbol.GeometryFactory.getInstance();
        this.geometryTransform = fastmap.mapApi.symbol.GeometryTransform.getInstance();
        this.geometryAlgorithm = fastmap.mapApi.geometry.GeometryAlgorithm.getInstance();

        this.map = null;
        this.snapActors = [];
        this.activeSnapActor = null;
        this.isRunning = false;
        this.drawSnapCross = true;
        this.tolerance = 20;
    },

    setMap: function (map) {
        this.map = map;
    },

    add: function (snapActor) {
        for (var i = 0; i < this.snapActors.length; ++i) {
            if (snapActor === this.snapActors[i]) {
                return;
            }
        }

        snapActor.setMap(this.map);
        this.snapActors.push(snapActor);

        this.snapActors = this.snapActors.sort(function (a, b) {
            return b.priority - a.priority;
        });
    },

    del: function (snapActor) {
        for (var i = 0; i < this.snapActors.length; ++i) {
            if (snapActor === this.snapActors[i]) {
                snapActor.shutdown();
                this.snapActors.splice(i, 1);
                return;
            }
        }
    },

    clear: function () {
        for (var i = 0; i < this.snapActors.length; ++i) {
            var snapActor = this.snapActors[i];
            snapActor.shutdown();
        }

        this.snapActors = [];
    },

    startup: function () {
        for (var i = 0; i < this.snapActors.length; ++i) {
            var snapActor = this.snapActors[i];
            snapActor.startup();
        }
        this.isRunning = true;
    },

    shutdown: function () {
        for (var i = 0; i < this.snapActors.length; ++i) {
            var snapActor = this.snapActors[i];
            snapActor.shutdown();
        }
        this.isRunning = false;
    },

    isSnapping: function () {
        return this.isRunning;
    },

    snap: function (point) {
        if (!this.isRunning) {
            return null;
        }

        if (this.snapActors.length === 0) {
            return null;
        }

        if (this.activeSnapActor) {
            this.activeSnapActor.clear();
            this.activeSnapActor = null;
        }

        var box = this.getBox(point, this.tolerance);
        var snapResult = null;
        var minDis = Number.MAX_VALUE;

        for (var i = 0; i < this.snapActors.length; ++i) {
            var snapActor = this.snapActors[i];
            // add by chenx on 2017-8-9
            // 请参考SnapActor中的priority的注释
            if (this.activeSnapActor && snapActor.priority < 0) {
                break;
            }
            var tmpSnapResult = snapActor.snap(point, box);
            if (!tmpSnapResult) {
                continue;
            }

            var dis = this.geometryAlgorithm.distance(tmpSnapResult.point, point);
            if (dis < minDis) {
                this.activeSnapActor = snapActor;
                snapResult = tmpSnapResult;
                minDis = dis;
            }
        }

        this.draw();

        return snapResult;
    },

    getBox: function (point, tolerance) {
        var x = point.coordinates[0];
        var y = point.coordinates[1];
        var pixelPoint = this.map.project([y, x]);
        var left = pixelPoint.x - tolerance;
        var right = pixelPoint.x + tolerance;
        var top = pixelPoint.y - tolerance;
        var bottom = pixelPoint.y + tolerance;

        var geojson = {
            type: 'Polygon',
            coordinates: []
        };

        var coordinates = [];
        var leftTop = this.map.unproject([left, top]);
        var rightTop = this.map.unproject([right, top]);
        var rightBottom = this.map.unproject([right, bottom]);
        var leftBottom = this.map.unproject([left, bottom]);

        coordinates.push([leftTop.lng, leftTop.lat]);
        coordinates.push([rightTop.lng, rightTop.lat]);
        coordinates.push([rightBottom.lng, rightBottom.lat]);
        coordinates.push([leftBottom.lng, leftBottom.lat]);
        coordinates.push([leftTop.lng, leftTop.lat]);

        geojson.coordinates = [coordinates];

        return geojson;
    },

    getActiveSnapActor: function () {
        return this.activeSnapActor;
    },

    setDrawSnapCross: function (value) {
        this.drawSnapCross = value;
    },

    getDrawSnapCross: function (value) {
        return this.drawSnapCross;
    },

    draw: function () {
        if (!this.isRunning) {
            return;
        }

        if (!this.drawSnapCross) {
            return;
        }

        if (!this.activeSnapActor) {
            return;
        }

        this.activeSnapActor.draw();
    },

    destroy: function () {
        fastmap.mapApi.snap.SnapController.instance = null;
    },

    statics: {
        instance: null,

        getInstance: function () {
            if (!fastmap.mapApi.snap.SnapController.instance) {
                fastmap.mapApi.snap.SnapController.instance =
                    new fastmap.mapApi.snap.SnapController();
            }
            return fastmap.mapApi.snap.SnapController.instance;
        }
    }
});

/**
 * Created by xujie on 2016/5/13 0013.
 */

FM.mapApi.source.Source = L.Class.extend({
    initialize: function (name, config) {
        this.name = name;
        this.parsor = config.parsor || null;
        this._sourceUrl = config.sourceUrl || null;
        this._subdomains = config.subdomains || [];
        this._requestParameter = FM.Util.clone(config.requestParameter);

        this._data = {};
    },

    createParameter: function (tile) {
        var parameter = FM.Util.clone(this._requestParameter);
        parameter.x = tile.x;
        parameter.y = tile.y;
        parameter.z = tile.z;
        return parameter;
    },

    setParameter: function (key, value) {
        this._requestParameter[key] = value;
    },

    getParameter: function (key) {
        return this._requestParameter[key];
    },

    setFeatureTypes: function (types) {
        this.setParameter('types', types);
    },

    add: function (feature, tileName) {
        if (!feature) {
            throw new Error('feature参数缺失');
        }
        if (!tileName) {
            throw new Error('tileName参数缺失');
        }
        if (!feature.properties) {
            throw new Error('feature缺少properties属性');
        }

        var geoLiveType = feature.properties.geoLiveType;
        if (!geoLiveType) {
            throw new Error('feature.properties缺少geoLiveType属性');
        }

        if (!this._data.hasOwnProperty(tileName)) {
            this._data[tileName] = {};
        }

        if (!this._data[tileName].hasOwnProperty(geoLiveType)) {
            this._data[tileName][geoLiveType] = {
                features: [],
                index: {}
            };
        }

        var id = feature.properties.id;
        if (!id) {
            throw new Error('feature.properties缺少id属性');
        }

        // var length = this._data[tileName][geoLiveType].features.push(feature);

        // 插入索引
        // if (!this._data[tileName][geoLiveType].index.hasOwnProperty(id)) {
        //     this._data[tileName][geoLiveType].index[id] = [];
        // }
        // this._data[tileName][geoLiveType].index[id].push(length - 1);

        if (!this._data[tileName][geoLiveType].index.hasOwnProperty(id)) {
            var length = this._data[tileName][geoLiveType].features.push(feature);
            this._data[tileName][geoLiveType].index[id] = [];
            this._data[tileName][geoLiveType].index[id].push(length - 1);
        } else {
            this._data[tileName][geoLiveType].features[this._data[tileName][geoLiveType].index[id][0]] = feature;
        }
    },

    del: function (feature, tileName) {
        if (!feature) {
            throw new Error('feature参数缺失');
        }
        if (!tileName) {
            throw new Error('tileName参数缺失');
        }
        if (!feature.properties) {
            throw new Error('feature缺少properties属性');
        }

        var geoLiveType = feature.properties.geoLiveType;
        if (!geoLiveType) {
            throw new Error('feature.properties缺少geoLiveType属性');
        }

        if (!this._data.hasOwnProperty(tileName)) {
            return;
        }

        if (!this._data[tileName].hasOwnProperty(geoLiveType)) {
            return;
        }

        var id = feature.properties.id;
        if (!id) {
            throw new Error('feature.properties缺少id属性');
        }

        if (!this._data[tileName][geoLiveType].index.hasOwnProperty(id)) {
            return;
        }

        var posArray = this._data[tileName][geoLiveType].index[id];
        var features = this._data[tileName][geoLiveType].features;
        for (var i = 0; i < posArray.length; ++i) {
            var pos = posArray[i];
            features.splice(pos, 1);
        }
        delete this._data[tileName][geoLiveType].index[id];
    },

    delByTile: function (tileName) {
        if (this._data.hasOwnProperty(tileName)) {
            delete this._data[tileName];
        }
    },

    delByType: function (geoLiveType, tileName) {
        if (!this._data.hasOwnProperty(tileName)) {
            return;
        }

        if (!this._data[tileName].hasOwnProperty(geoLiveType)) {
            return;
        }

        delete this._data[tileName][geoLiveType];
    },

    clear: function () {
        this._data = {};
    },

    queryTilesById: function (geoLiveType, id) {
        if (!geoLiveType || !id) {
            return [];
        }

        var tileNames = [];
        var keys = Object.getOwnPropertyNames(this._data);
        for (var i = 0; i < keys.length; ++i) {
            var tileName = keys[i];
            if (!this._data[tileName].hasOwnProperty(geoLiveType)) {
                continue;
            }
            if (!this._data[tileName][geoLiveType].index.hasOwnProperty(id)) {
                continue;
            }
            tileNames.push(tileName);
        }

        return tileNames;
    },

    queryFeatureById: function (geoLiveType, id, tileName) {
        if (!this._data.hasOwnProperty(tileName)) {
            return null;
        }

        if (!this._data[tileName].hasOwnProperty(geoLiveType)) {
            return null;
        }

        if (!this._data[tileName][geoLiveType].index.hasOwnProperty(id)) {
            return null;
        }

        var features = this._data[tileName][geoLiveType].features;
        var posArray = this._data[tileName][geoLiveType].index[id];
        var feature = features[posArray[0]];

        return feature;
    },

    queryFeaturesByType: function (geoLiveType, tileName) {
        if (!this._data.hasOwnProperty(tileName)) {
            return [];
        }

        if (!this._data[tileName].hasOwnProperty(geoLiveType)) {
            return [];
        }

        var features = this._data[tileName][geoLiveType].features;
        return features;
    },

    queryTiles: function () {
        return Object.getOwnPropertyNames(this._data);
    },

    createUrl: function (tile, tileIndex) {
        return this._template(this._sourceUrl, {
            s: this._getSubdomain(tileIndex),
            z: tile.z,
            x: tile.x,
            y: tile.y
        });
    },

    _getSubdomain: function (tileIndex) {
        if (this._subdomains.length === 0) {
            return null;
        }
        var index = tileIndex % this._subdomains.length;
        return this._subdomains[index];
    },

    _template: function (str, data) {
        return str.replace(/\{ *([\w_]+) *\}/g, function (matchStr, key) {
            var value = data[key];
            if (!value) {
                throw new Error('没有提供可用的值:' + matchStr);
            }
            return value;
        });
    }
});

/**
 * Created by zhongxiaoming on 2017/4/12.
 */
fastmap.mapApi.source.ClassicalSource = fastmap.mapApi.source.Source.extend({
    createParameter: function (tile) {
        var parameter = FM.Util.clone(this._requestParameter);
        parameter.x = tile.x;
        parameter.y = tile.y;
        parameter.z = tile.z;
        return parameter;
    }
});

/**
 * Created by zhongxiaoming on 2017/4/12.
 */
fastmap.mapApi.source.InfoSource = fastmap.mapApi.source.Source.extend({
    createParameter: function (tile) {
        var parameter = FM.Util.clone(this._requestParameter);
        parameter.x = tile.x;
        parameter.y = tile.y;
        parameter.z = tile.z;
        return parameter;
    }
});

fastmap.mapApi.source.DeletionLinkSource = fastmap.mapApi.source.Source.extend({
    createParameter: function (tile) {
        var parameter = FM.Util.clone(this._requestParameter);
        parameter.x = tile.x;
        parameter.y = tile.y;
        parameter.z = tile.z;
        return parameter;
    }
});


/**
 * Created by xujie on 2016/5/13 0013.
 */

fastmap.mapApi.source.SourceController = L.Class.extend({
    initialize: function () {
        this._sources = {};
        this.tileRequestController = fastmap.mapApi.TileRequestController.getInstance();
    },

    add: function (source) {
        if (this._sources.hasOwnProperty(source.name)) {
            throw new Error('已经存在数据源:' + source.name);
        }

        this._sources[source.name] = source;
    },

    del: function (sourceName) {
        if (this._sources.hasOwnProperty(sourceName)) {
            delete this._sources[sourceName];
        }
    },

    clear: function () {
        var keys = Object.getOwnPropertyNames(this._sources);
        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            this._sources[key].clear();
        }
    },

    getSource: function (sourceName) {
        if (!this._sources.hasOwnProperty(sourceName)) {
            return null;
        }

        return this._sources[sourceName];
    },

    getAllSources: function () {
        var sources = [];
        var keys = Object.getOwnPropertyNames(this._sources);
        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            sources.push(this._sources[key]);
        }
        return sources;
    },

    requestTileData: function (tile, tileIndex, urlObject) {
        var self = this;
        var promises = this._createPromises(tile, tileIndex, urlObject);
        return Promise.all(promises)
            .then(function (res) {
                self._tilePromiseSuccess(tile, res);
                return tile;
            });
    },

    loadConfig: function (config) {
        var keys = Object.getOwnPropertyNames(config);
        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            var value = config[key];
            if (this._sources[key]) {
                throw new Error('数据源名称存在重复:' + key);
            }
            this._sources[key] = this._loadSource(key, value);
        }
    },

    _loadSource: function (key, config) {
        var source;
        switch (config.type) {
            case 'classical':
                source = new fastmap.mapApi.source.ClassicalSource(key, config);
                break;
            case 'infocustomized':
                source = new fastmap.mapApi.source.InfoSource(key, config);
                break;
            case 'deletioncustomized':
                source = new fastmap.mapApi.source.DeletionLinkSource(key, config);
                break;
            case 'fccustomized':
                source = new fastmap.mapApi.source.InfoSource(key, config);
                break;
            default:
                source = null;
                break;
        }
        return source;
    },

    _createPromises: function (tile, tileIndex, urlObject) {
        this._uniqueFeatureType(urlObject);

        var promises = [];
        var keys = Object.getOwnPropertyNames(urlObject);
        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            var value = urlObject[key];
            if (!value.length) {
                continue;
            }
            var source = this.getSource(key);
            source.setFeatureTypes(value);
            var url = source.createUrl(tile, tileIndex);
            var parameter = source.createParameter(tile);
            var promise = this._createAjaxPromise(tile, url, parameter, key);
            promises.push(promise);
        }

        return promises;
    },

    _uniqueFeatureType: function (urlObject) {
        var keys = Object.getOwnPropertyNames(urlObject);
        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            var value = urlObject[key];
            urlObject[key] = FM.Util.unique(value);
        }
    },

    _createAjaxPromise: function (tile, url, requestParameter, additionParameter) {
        var self = this;
        var promise = new Promise(function (resolve, reject) {
            var options = {
                url: url,
                requestParameter: requestParameter,
                parameter: additionParameter,
                timeout: 100000,
                responseType: 'json',
                // debug: true,
                onSuccess: function (json, parameter) {
                    if (json.errcode == 0) { // 操作成功
                        resolve({
                            data: json.data,
                            parameter: parameter
                        });
                    } else {
                        reject({
                            errmsg: json.errmsg,
                            parameter: parameter
                        });
                    }
                },
                onFail: function (errmsg, parameter) {
                    reject({
                        errmsg: errmsg,
                        parameter: parameter
                    });
                },
                onError: function (errmsg, parameter) {
                    reject({
                        errmsg: errmsg,
                        parameter: parameter
                    });
                },
                onTimeout: function (errmsg, parameter) {
                    reject({
                        errmsg: errmsg,
                        parameter: parameter
                    });
                }
            };
            var request = fastmap.mapApi.ajax.get(options);
            self.tileRequestController.add(tile.fullName, request);
        });

        return promise;
    },

    _tilePromiseSuccess: function (tile, res) {
        var allFeatures = {};
        for (var i = 0; i < res.length; ++i) {
            var item = res[i];
            var data = item.data;
            var parameter = item.parameter;
            var source = this.getSource(parameter);
            var features = source.parsor.transform(data, tile, source.parsor);
            this._addFeaturesToDataSource(source, features, tile);
        }
    },

    _addFeaturesToDataSource: function (source, features, tile) {
        for (var i = 0; i < features.length; ++i) {
            var feature = features[i];
            source.add(feature, tile.fullName);
        }
    },

    /**
     * 销毁单例对象
     */
    destroy: function () {
        fastmap.mapApi.source.SourceController.instance = null;
    },

    statics: {
        instance: null,

        getInstance: function () {
            if (!fastmap.mapApi.source.SourceController.instance) {
                fastmap.mapApi.source.SourceController.instance =
                    new fastmap.mapApi.source.SourceController();
            }
            return fastmap.mapApi.source.SourceController.instance;
        }
    }
});

/**
 * Created by liwanchong on 2016/12/7.
 * 要素选择器
 */
fastmap.mapApi.FeatureSelector = L.Class.extend({
    options: {},

    initialize: function () {
        this.map = null;
        this.sourceController = fastmap.mapApi.source.SourceController.getInstance();
        this.sceneController = fastmap.mapApi.scene.SceneController.getInstance();
        this.transform = new fastmap.mapApi.MecatorTranform();
        this.geometryAlgorithm = fastmap.mapApi.geometry.GeometryAlgorithm.getInstance();
        this.geojsonTransform = fastmap.mapApi.GeometryTransform.getInstance();
    },

    /**
     * 设置map属性
     * @param map
     */
    setMap: function (map) {
        this.map = map;
    },

    setOptions: function (options) {
        FM.setOptions(this, options);
    },

    removeOption: function (key) {
        if (this.options) {
            delete this.options[key];
        }
    },

    clearOptions: function () {
        this.options = {};
    },

    /**
     * 根据geoemtry和geoLiveType选择feature
     * 如果geoLiveTypes为undefined或null,则查找所有类型要素
     * 如果未找到匹配feature返回[]
     * @param geometry 支持所有geojson几何类型
     * @param geoLiveTypes geoLiveType数组
     * @returns {*} 所有被选中的feature数组
     */
    selectByGeometry: function (geometry, geoLiveTypes) {
        var targetGeoLiveTypes = null;
        if (!geoLiveTypes) {
            targetGeoLiveTypes = this.getFeatureTypes();
        } else {
            targetGeoLiveTypes = FM.Util.unique(geoLiveTypes);
        }

        if (targetGeoLiveTypes.length === 0) {
            return [];
        }

        // 用于选择的几何转换成像素坐标
        this.geojsonTransform.setEnviroment(this.map, null, this.convertToPixelPoint);
        var pixelSelectGeometry = this.geojsonTransform.convertGeometry(geometry);

        // 计算几何所跨越的tiles
        var tiles = this.getTilesFromGeometry(pixelSelectGeometry);

        // 根据类型和tiles查询要素
        var self = this;
        var features = this.getFeaturesFromGeoLiveTypes(targetGeoLiveTypes, tiles);
        if (features.length > 0) {
            features = this.uniqueFeatureArray(features);

            // 在像素坐标下做第二次精确的筛选
            this.geojsonTransform.setEnviroment(this.map, null, this.convertToPixelPoint);
            features = features.filter(function (feature) {
                var pixelFeatureGeometry = this.geojsonTransform.convertGeometry(feature.geometry);
                return this.isHitGeometry(pixelSelectGeometry, pixelFeatureGeometry);
            }, this);

            if (this.options.filter) {
                features = features.filter(this.options.filter);
            }
        }

        return features;
    },

    /**
     * 选择指定类型的所有要素
     * 如果geoLiveType为undefined或null,则返回[]
     * 如果未找到匹配要素类型返回n[]
     * 注意此接口效率较低,切勿在循环中调用
     * @param geoLiveType geoLiveType
     * @returns {*} 被选中的要素
     */
    selectByGeoLiveType: function (geoLiveType) {
        if (!geoLiveType) {
            return [];
        }

        var features = this.getFeaturesFromGeoLiveTypes([geoLiveType], null);

        if (this.options.filter) {
            features = features.filter(this.options.filter);
        }

        return features;
    },

    /**
     * 根据要素类型和要素id选择要素
     * 如果geoLiveType为undefined或null,则返回null
     * 如果未找到匹配feature返回null
     * @param id id
     * @param geoLiveType geoLiveType
     * @returns {*} 被选中的要素
     */
    selectByFeatureId: function (id, geoLiveType) {
        if (!id || !geoLiveType) {
            return null;
        }

        var tileIds = this.getTileIdsFromFeatureId([geoLiveType], id);
        var tiles = tileIds.map(function (tileId) {
            return this.getTileInfoFromTileId(tileId);
        }, this);
        var features = this.getFeaturesFromGeoLiveTypes([geoLiveType], tiles);
        features = features.filter(function (feature) {
            return feature.properties.id === id;
        }, this);

        if (this.options.filter) {
            features = features.filter(this.options.filter);
        }

        if (features.length === 0) {
            return null;
        }

        return features[0];
    },

    /**
     * 根据func和geoLiveType选择feature
     * 如果geoLiveType为undefined或null,则返回[]
     * 如果未找到匹配feature返回[]
     * 注意此接口效率较低,切勿在循环中调用
     * @param func 自定义函数,接受feature参数,返回bool值
     * @param geoLiveType geoLiveType
     * @returns {*} 所有被选中的feature数组
     */
    selectByFunction: function (func, geoLiveType) {
        if (!geoLiveType) {
            return [];
        }

        var features = this.getFeaturesFromGeoLiveTypes([geoLiveType], null);
        features = features.filter(function (feature) {
            return func(feature);
        }, this);

        if (this.options.filter) {
            features = features.filter(this.options.filter);
        }

        return features;
    },

    /**
     * 选择指定瓦片中指定类型的所有要素
     * 如果geoLiveType为undefined或null,则返回[]
     * 如果未找到匹配要素类型返回n[]
     * 注意此接口效率较低,切勿在循环中调用
     * @param tile tile
     * @param geoLiveType geoLiveType
     * @returns {*} 被选中的要素
     */
    selectByTile: function (tile, geoLiveType) {
        if (!geoLiveType || !tile) {
            return [];
        }

        var sources = this.getSourcesByFeatureType(geoLiveType);

        var features = [];
        for (var i = 0; i < sources.length; i++) {
            Array.prototype.push.apply(features, this.getFeaturesFromTile(sources[i], geoLiveType, tile));
        }

        if (this.options.filter) {
            features = features.filter(this.options.filter);
        }

        return features;
    },

    getTilesFromGeometry: function (geometry) {
        var bbox = this.geometryAlgorithm.bbox(geometry);
        var tiles = this.getTilesFromBBox(bbox);
        tiles = tiles.filter(function (tile) {
            var tileBound = this.getTileBoundsByTile(tile);
            return this.geometryAlgorithm.intersectsAndContains(tileBound, geometry);
        }, this);
        return tiles;
    },

    getTilesFromBBox: function (bbox) {
        var zoom = this.map.getZoom();
        var tiles = [];
        var tileSize = 256;
        var min = L.point(bbox.minX, bbox.minY).divideBy(tileSize)._floor();
        var max = L.point(bbox.maxX, bbox.maxY).divideBy(tileSize)._floor();

        for (var j = min.y; j <= max.y; j++) {
            for (var i = min.x; i <= max.x; i++) {
                var tile = this.createTile(i, j, zoom);
                tiles.push(tile);
            }
        }
        return tiles;
    },

    getTileBoundsByTile: function (tile) {
        var bounds = {
            type: 'Polygon',
            coordinates: []
        };

        var min = L.point(tile.x, tile.y).multiplyBy(tile.tileSize);
        var max = min.add([tile.tileSize, tile.tileSize]);

        var coordinates = [];
        coordinates.push([min.x, min.y]);
        coordinates.push([max.x, min.y]);
        coordinates.push([max.x, max.y]);
        coordinates.push([min.x, max.y]);
        coordinates.push([min.x, min.y]);

        bounds.coordinates = [coordinates];

        return bounds;
    },

    getTileIdsFromGeometry: function (geometry, zoom) {
        var type = geometry.type;
        switch (type) {
            case 'Point':
                return [this.getTileIdFromPoint(geometry.coordinates, zoom)];
            case 'MultiPoint':
            case 'LineString':
                return this.getTileIdsFromLineString(geometry.coordinates, zoom);
            case 'MultiLineString':
            case 'Polygon':
                return this.getTileIdsFromPolygon(geometry.coordinates, zoom);
            case 'MultiPolygon':
                return this.getTileIdsFromMultiPolygon(geometry.coordinates, zoom);
            case 'GeometryCollection':
                return this.getTileIdsFromGeometryCollection(geometry.geometries, zoom);
            default:
                return [];
        }
    },

    getTileIdFromPoint: function (coordinates, zoom) {
        var tileArr = this.transform.lonlat2Tile(coordinates[0], coordinates[1], zoom);
        return tileArr[0] + ':' + tileArr[1];
    },

    getTileIdsFromLineString: function (coordinates, zoom) {
        var tiles = [];
        for (var i = 0; i < coordinates.length; ++i) {
            var tile = this.getTileIdFromPoint(coordinates[i], zoom);
            tiles.push(tile);
        }
        return tiles;
    },

    getTileIdsFromPolygon: function (coordinates, zoom) {
        var tiles = [];
        for (var i = 0; i < coordinates.length; ++i) {
            var lineStringTiles = this.getTileIdsFromLineString(coordinates[i], zoom);
            tiles = tiles.concat(lineStringTiles);
        }
        return tiles;
    },

    getTileIdsFromMultiPolygon: function (coordinates, zoom) {
        var tiles = [];
        for (var i = 0; i < coordinates.length; ++i) {
            var polygonTiles = this.getTileIdsFromPolygon(coordinates[i], zoom);
            tiles = tiles.concat(polygonTiles);
        }
        return tiles;
    },

    getTileIdsFromGeometryCollection: function (geometries, zoom) {
        var tiles = [];
        for (var i = 0; i < geometries.length; ++i) {
            var multiGeometries = this.getTileIdsFromGeometry(geometries[i], zoom);
            tiles = tiles.concat(multiGeometries);
        }
        return tiles;
    },

    getTileIdsFromFeatureId: function (geoLiveTypes, id) {
        var tileIds = [];
        var featureType,
            sources;
        var i,
            j;
        for (i = 0; i < geoLiveTypes.length; ++i) {
            featureType = geoLiveTypes[i];
            sources = this.getSourcesByFeatureType(featureType);
            for (j = 0; j < sources.length; ++j) {
                Array.prototype.push.apply(tileIds, sources[j].queryTilesById(featureType, id));
            }
        }

        return tileIds;
    },

    getFeaturesFromGeoLiveTypes: function (geoLiveTypes, tiles) {
        var features = [];
        var featureType,
            sources;
        var i,
            j;
        for (i = 0; i < geoLiveTypes.length; ++i) {
            featureType = geoLiveTypes[i];
            sources = this.getSourcesByFeatureType(featureType);
            for (j = 0; j < sources.length; ++j) {
                Array.prototype.push.apply(features, this.getFeaturesFromTiles(sources[j], featureType, tiles));
            }
        }

        features = this.uniqueFeatureArray(features);
        return features;
    },

    getFeaturesFromTiles: function (source, geoLiveType, tiles) {
        var tileIds = null;
        if (!tiles) {
            tileIds = source.queryTiles();
        } else {
            tileIds = tiles.map(function (tile) {
                return tile.fullName;
            }, this);
        }

        var features = [];
        for (var i = 0; i < tileIds.length; ++i) {
            var tileId = tileIds[i];
            features = features.concat(this.getFeaturesFromTile(source, geoLiveType, tileId));
        }
        return features;
    },

    getFeaturesFromTile: function (source, geoLiveType, tileId) {
        var resFeatures = [];
        var features = source.queryFeaturesByType(geoLiveType, tileId);
        var tileInfo = this.getTileInfoFromTileId(tileId);
        this.geojsonTransform.setEnviroment(this.map, tileInfo, this.convertToLngLat);
        for (var i = 0; i < features.length; ++i) {
            var feature = features[i];
            if (!this.geometryAlgorithm.isValidGeometry(feature.geometry)) {
                continue;
            }
            // 这里需要转换坐标,为了不影响原来的数据,先克隆
            var cloneFeature = FM.Util.clone(feature);
            cloneFeature.geometry = this.geojsonTransform.convertGeometry(cloneFeature.geometry);
            resFeatures.push(cloneFeature);
        }
        return resFeatures;
    },

    getTileInfoFromTileId: function (tileId) {
        var array = tileId.split(':');

        var tile = this.createTile(array[0], array[1], array[2]);

        return tile;
    },

    createTile: function (x, y, z) {
        var tile = {
            name: x + ':' + y,
            fullName: x + ':' + y + ':' + z,
            x: x,
            y: y,
            z: z,
            tileSize: 256
        };
        return tile;
    },

    convertToLngLat: function (map, tileInfo, coordinates) {
        var x = tileInfo.x * tileInfo.tileSize + coordinates[0];
        var y = tileInfo.y * tileInfo.tileSize + coordinates[1];
        var lnglat = map.unproject([x, y]);
        return [lnglat.lng, lnglat.lat];
    },

    convertToPixelPoint: function (map, tileInfo, coordinates) {
        var x = coordinates[0];
        var y = coordinates[1];
        var point = map.project([y, x]);
        return [point.x, point.y];
    },

    isHitGeometry: function (selectGeometry, geometry) {
        var type = selectGeometry.type;
        switch (type) {
            case 'Point':
            case 'MultiPoint':
                return this.geometryAlgorithm.isWithinDistance(selectGeometry, geometry, 5);
            case 'LineString':
            case 'MultiLineString':
                return this.geometryAlgorithm.intersects(selectGeometry, geometry);

            case 'Polygon':
            case 'MultiPolygon':
                return this.geometryAlgorithm.intersectsAndContains(selectGeometry, geometry);

            case 'GeometryCollection':
                return selectGeometry.geometries.some(function (item) {
                    return this.isHitGeometry(selectGeometry, item);
                }, this);
            default:
                throw new Error('不支持的几何类型:' + type);
        }
    },

    uniqueFeatureArray: function (arr) {
        var res = [];
        var obj = {};
        for (var i = 0; i < arr.length; i++) {
            var feature = arr[i];
            var key = feature.properties.geoLiveType + ':' + feature.properties.id;
            if (!obj[key]) {
                res.push(feature);
                obj[key] = true;
            }
        }
        return res;
    },

    getFeatureTypes: function () {
        return this.sceneController.getLoadedFeatureTypes();
    },

    getSourcesByFeatureType: function (featureType) {
        var sources = [];
        var layers = this.sceneController.getLoadedLayersByFeatureType(featureType);
        for (var i = 0; i < layers.length; i++) {
            sources.push(this.sourceController.getSource(layers[i].getSourceName()));
        }

        return FM.Util.unique(sources);
    },

    /**
     * 销毁单例对象
     */
    destroy: function () {
        fastmap.mapApi.FeatureSelector.instance = null;
    },

    statics: {
        instance: null,

        getInstance: function () {
            if (!fastmap.mapApi.FeatureSelector.instance) {
                fastmap.mapApi.FeatureSelector.instance =
                    new fastmap.mapApi.FeatureSelector();
            }
            return fastmap.mapApi.FeatureSelector.instance;
        }
    }
});

/**
 * Created by xujie on 2016/5/11 0011.
 */
fastmap.mapApi.symbol.Point = L.Class.extend({

    initialize: function (x, y) {
        this.type = 'Point';

        this.x = x || 0;
        this.y = y || 0;
    },

    /**
     * 克隆对象
     * @method clone
     * @return fastmap.mapApi.symbol.Point 克隆的对象
     */
    clone: function () {
        var clonePt = new fastmap.mapApi.symbol.Point();
        clonePt.x = this.x;
        clonePt.y = this.y;

        return clonePt;
    },

    /**
     * 计算当前点与目标点之间的距离
     * @method distance
     * @param p
     * @return Number 当前点与目标点之间的距离
     */
    distance: function (p) {
        return Math.sqrt((this.x - p.x) * (this.x - p.x) + (this.y - p.y) * (this.y - p.y));
    },

    /**
     * 计算p到当前点的向量
     * @method minus
     * @param p
     * @return fastmap.mapApi.symbol.Vector 计算p到当前点的向量
     */
    minus: function (p) {
        var x = this.x - p.x;
        var y = this.y - p.y;
        return new fastmap.mapApi.symbol.Vector(x, y);
    },

    /**
     * 叉乘矩阵变换坐标
     * 主要用于点平移，旋转，缩放等操作
     * @method crossMatrix
     * @param m
     * @return fastmap.mapApi.symbol.Point 变换之后的坐标
     */
    crossMatrix: function (m) {
        var tmpVec = [this.x, this.y, 1];
        var newVec = new fastmap.mapApi.symbol.Point(0, 0);
        newVec.x = (tmpVec[0] * m.data[0][0]) +
                   (tmpVec[1] * m.data[1][0]) +
                   (tmpVec[2] * m.data[2][0]);
        newVec.y = (tmpVec[0] * m.data[0][1]) +
                   (tmpVec[1] * m.data[1][1]) +
                   (tmpVec[2] * m.data[2][1]);

        return newVec;
    },

    /**
     * 判断两个点坐标是否相等
     * @method equal
     * @param p
     * @return {boolean}
     */
    equal: function (p) {
        if (this.x !== p.x) {
            return false;
        }

        if (this.y !== p.y) {
            return false;
        }

        return true;
    },

    /**
     * 定义点和向量的加法
     * 返回结果为点
     * 代表的几何意义是将点按照向量平移
     * @method plusVector
     * @param v
     * @return fastmap.mapApi.symbol.Point
     */
    plusVector: function (v) {
        var point = new fastmap.mapApi.symbol.Point();
        point.x = this.x + v.x;
        point.y = this.y + v.y;

        return point;
    },

    /**
     * 获取bound
     * @returns bound
     */
    getBound: function () {
        return new fastmap.mapApi.symbol.Bound(
            this.x,
            this.y,
            this.x,
            this.y
        );
    }
});

/**
 * Created by xujie on 2016/5/13 0013.
 */
fastmap.mapApi.symbol.Matrix = L.Class.extend({

    initialize: function () {
        this.data = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
    },

    cross: function (other) {
        var m = new fastmap.mapApi.symbol.Matrix();

        m.data[0][0] = (this.data[0][0] * other.data[0][0]) +
                       (this.data[0][1] * other.data[1][0]) +
                       (this.data[0][2] * other.data[2][0]);
        m.data[0][1] = (this.data[0][0] * other.data[0][1]) +
                       (this.data[0][1] * other.data[1][1]) +
                       (this.data[0][2] * other.data[2][1]);
        m.data[0][2] = (this.data[0][0] * other.data[0][2]) +
                       (this.data[0][1] * other.data[1][2]) +
                       (this.data[0][2] * other.data[2][2]);

        m.data[1][0] = (this.data[1][0] * other.data[0][0]) +
                       (this.data[1][1] * other.data[1][0]) +
                       (this.data[1][2] * other.data[2][0]);
        m.data[1][1] = (this.data[1][0] * other.data[0][1]) +
                       (this.data[1][1] * other.data[1][1]) +
                       (this.data[1][2] * other.data[2][1]);
        m.data[1][2] = (this.data[1][0] * other.data[0][2]) +
                       (this.data[1][1] * other.data[1][2]) +
                       (this.data[1][2] * other.data[2][2]);

        m.data[2][0] = (this.data[2][0] * other.data[0][0]) +
                       (this.data[2][1] * other.data[1][0]) +
                       (this.data[2][2] * other.data[2][0]);
        m.data[2][1] = (this.data[2][0] * other.data[0][1]) +
                       (this.data[2][1] * other.data[1][1]) +
                       (this.data[2][2] * other.data[2][1]);
        m.data[2][2] = (this.data[2][0] * other.data[0][2]) +
                       (this.data[2][1] * other.data[1][2]) +
                       (this.data[2][2] * other.data[2][2]);

        return m;
    },

    makeTranslate: function (x, y) {
        var m = new fastmap.mapApi.symbol.Matrix();

        m.data[0][0] = 1;
        m.data[0][1] = 0;
        m.data[0][2] = 0;

        m.data[1][0] = 0;
        m.data[1][1] = 1;
        m.data[1][2] = 0;

        m.data[2][0] = x;
        m.data[2][1] = y;
        m.data[2][2] = 1;

        return m;
    },

    makeRotate: function (a) {
        var arca = (Math.PI / 180) * a;
        var m = new fastmap.mapApi.symbol.Matrix();

        m.data[0][0] = Math.cos(arca);
        m.data[0][1] = Math.sin(arca);
        m.data[0][2] = 0;

        m.data[1][0] = -Math.sin(arca);
        m.data[1][1] = Math.cos(arca);
        m.data[1][2] = 0;

        m.data[2][0] = 0;
        m.data[2][1] = 0;
        m.data[2][2] = 1;

        return m;
    },

    makeScale: function (sx, sy) {
        var m = new fastmap.mapApi.symbol.Matrix();

        m.data[0][0] = sx;
        m.data[0][1] = 0;
        m.data[0][2] = 0;

        m.data[1][0] = 0;
        m.data[1][1] = sy;
        m.data[1][2] = 0;

        m.data[2][0] = 0;
        m.data[2][1] = 0;
        m.data[2][2] = 1;

        return m;
    },

    makeRotateToVector: function (v) {
        var vY = new fastmap.mapApi.symbol.Vector(0, -1);
        var angle = vY.angleTo(v);
        var signal = vY.cross(v);

        if (signal < 0) {
            angle = -angle;
        }

        return this.makeRotate(angle);
    }
});

/**
 * Created by xujie on 2016/5/11 0011.
 */
fastmap.mapApi.symbol.Vector = L.Class.extend({

    initialize: function (x, y) {
        if (x === undefined) {
            this.x = 0;
        } else {
            this.x = x;
        }

        if (y === undefined) {
            this.y = 0;
        } else {
            this.y = y;
        }
    },

    /**
     * 向量减法
     * 返回结果为向量
     * @method minus
     * @param v
     * @return fastmap.mapApi.symbol.Vector
     */
    minus: function (v) {
        var x = this.x - v.x;
        var y = this.y - v.y;
        return new fastmap.mapApi.symbol.Vector(x, y);
    },

    /**
     * 向量加法
     * 返回结果为向量
     * @method plus
     * @param v
     * @return fastmap.mapApi.symbol.Vector
     */
    plus: function (v) {
        var x = this.x + v.x;
        var y = this.y + v.y;
        return new fastmap.mapApi.symbol.Vector(x, y);
    },

    /**
     * 向量和数字的乘法
     * 返回结果为向量
     * @method multiNumber
     * @param n
     * @return fastmap.mapApi.symbol.Vector
     */
    multiNumber: function (n) {
        var x = this.x * n;
        var y = this.y * n;
        return new fastmap.mapApi.symbol.Vector(x, y);
    },

    /**
     * 向量和数字的除法
     * 返回结果为向量
     * @method dividNumber
     * @param n
     * @return fastmap.mapApi.symbol.Vector
     */
    dividNumber: function (n) {
        var x = this.x / n;
        var y = this.y / n;
        return new fastmap.mapApi.symbol.Vector(x, y);
    },

    /**
     * 向量和向量的叉乘
     * 返回结果为叉乘结果的模长
     * 符号表示方向，符号为正表示与Z同向，否则反向
     * @method cross
     * @param v
     * @return Number
     */
    cross: function (v) {
        return this.x * v.y - this.y * v.x;
    },

    /**
     * 向量和向量的点积
     * 返回结果为数字
     * @method dot
     * @param v
     * @return Number
     */
    dot: function (v) {
        return this.x * v.x + this.y * v.y;
    },

    /**
     * 向量模长的平方
     * 返回结果为数字
     * @method length2
     * @return Number
     */
    length2: function () {
        return this.x * this.x + this.y * this.y;
    },

    /**
     * 向量模长
     * 返回结果为数字
     * @method length
     * @return Number
     */
    length: function () {
        return Math.sqrt(this.length2());
    },

    /**
     * 单位化向量
     * @method normalize
     */
    normalize: function () {
        var length = this.length();
        this.x = this.x / length;
        this.y = this.y / length;
    },

    /**
     * 向量和矩阵的叉乘
     * 返回结果为向量
     * 主要用于对向量进行平移，旋转，缩放等操作
     * @method crossMatrix
     * @param m
     * @return fastmap.mapApi.symbol.Vector
     */
    crossMatrix: function (m) {
        var tmpVec = [this.x, this.y, 1];
        var newVec = new fastmap.mapApi.symbol.Vector(0, 0);
        newVec.x = tmpVec[0] * m.data[0][0] + tmpVec[1] * m.data[1][0] + tmpVec[2] * m.data[2][0];
        newVec.y = tmpVec[0] * m.data[0][1] + tmpVec[1] * m.data[1][1] + tmpVec[2] * m.data[2][1];

        return newVec;
    },

    /**
     * 求向量之间的夹角
     * 返回结果为角度，单位度
     * @method angleTo
     * @param v
     * @return Number
     */
    angleTo: function (v) {
        var cos = this.dot(v) / (this.length() * v.length());
        var arcA = Math.acos(cos);

        return arcA * 180 / Math.PI;
    }
});

/**
 * Created by xujie on 2016/5/13 0013.
 */

fastmap.mapApi.symbol.LineSegment = L.Class.extend({

    initialize: function (start, end) {
        this.type = 'LineSegment';

        this.start = start ? start.clone() : new fastmap.mapApi.symbol.Point();
        this.end = end ? end.clone() : new fastmap.mapApi.symbol.Point();
    },

    /**
     * 克隆对象
     * @method clone
     * @return fastmap.mapApi.symbol.LineSegment 克隆的对象
     */
    clone: function () {
        var cloneLineSegment = new fastmap.mapApi.symbol.LineSegment(this.start, this.end);
        return cloneLineSegment;
    },

    /**
     * 计算线段长度
     * @method length
     * @return Number 线段长度
     */
    length: function () {
        return this.start.distance(this.end);
    },

    /**
     * 计算线段指定长度处的点
     * 当指定长度小于等于0时，返回start.clone
     * 当指定长度大于或等于两点之间总长度时，返回end.clone
     * @method getPointByLength
     * @param length 要切分的长度
     * @return Point 坐标点
     */
    getPointByLength: function (length) {
        var lineLength,
            vector,
            point;
        if (length <= 0) {
            return this.start.clone();
        }

        lineLength = this.length();

        if (length >= lineLength) {
            return this.end.clone();
        }

        vector = this.end.minus(this.start);
        vector.normalize();

        vector = vector.multiNumber(length);

        point = this.start.plusVector(vector);

        return point;
    }

});

/**
 * Created by xujie on 2016/5/13 0013.
 */

fastmap.mapApi.symbol.LineString = L.Class.extend({

    initialize: function () {
        this.type = 'LineString';

        this.coordinates = [];
    },

    /**
     * 克隆对象
     * @method clone
     * @return fastmap.mapApi.symbol.LineString 克隆的对象
     */
    clone: function () {
        var cloneLineString = new fastmap.mapApi.symbol.LineString();
        for (var i = 0; i < this.coordinates.length; ++i) {
            var point = this.coordinates[i].clone();
            cloneLineString.coordinates.push(point);
        }

        return cloneLineString;
    },

    /**
     * 计算线长度
     * @method length
     * @return Number 线长度
     */
    length: function () {
        if (this.coordinates.length < 2) {
            return 0;
        }

        var length = 0;

        for (var i = 1; i < this.coordinates.length; ++i) {
            var prePoint = this.coordinates[i - 1];
            var point = this.coordinates[i];
            length += point.distance(prePoint);
        }

        return length;
    },

    /**
     * 计算线几何在指定长度处的点（不一定是形状点），以及前后点索引
     * 当指定长度小于等于0时，返回['start']
     * 当指定长度大于或等于两点之间总长度时，返回['end']
     * 当指定长度处的点刚好是形状点时，返回['vertex',i-1，i+1， [xi, yi]]
     * 当指定长度处的点不是形状点时，返回['betweenVertex',i-1，i， [xn, yn]]
     * @method splitGeometry
     * @param length 要切分的长度
     * @return Array 点坐标
     */
    getPointByLength: function (length) {
        var result = [];

        if (length <= 0) {
            result.push('start');
            return result;
        }

        var geometryLength = this.length();
        if (length >= geometryLength) {
            result.push('end');
            return result;
        }

        var tmpLength = 0;

        for (var i = 1; i < this.coordinates.length; ++i) {
            var prePoint = this.coordinates[i - 1];

            var curPoint = this.coordinates[i];
            var segmentLength = curPoint.distance(prePoint);
            if (tmpLength + segmentLength < length) {
                tmpLength += segmentLength;
            } else if (tmpLength + segmentLength === length) {
                result.push('vertex');
                result.push(i - 1);
                result.push(i + 1);
                result.push(curPoint.clone());
                break;
            } else {
                var remainLength = length - tmpLength;
                var line = new fastmap.mapApi.symbol.LineSegment(prePoint, curPoint);
                var point = line.getPointByLength(remainLength);
                result.push('betweenVertex');
                result.push(i - 1);
                result.push(i);
                result.push(point);

                break;
            }
        }

        return result;
    },

    /**
     * 在指定长度处将线几何切分成两段
     *
     * 当指定长度大于几何长度时，返回[LineString,null]
     * 当指定长度小于等于0时，返回[null,LineString]
     * @method splitByLength
     * @param length 要切分的长度
     * @return Array [subLineString1,subLineString2]
     */
    splitByLength: function (length) {
        var result = this.getPointByLength(length);

        var subLineString1;
        var subLineString2;
        switch (result[0]) {
            case 'start':
                subLineString1 = null;
                subLineString2 = this.clone();
                break;
            case 'end':
                subLineString1 = this.clone();
                subLineString2 = null;
                break;
            case 'vertex':
            case 'betweenVertex':
                subLineString1 = this.slice(0, result[1] + 1);// 获取从0到result[1]部分
                subLineString1.coordinates.push(result[3]);
                subLineString2 = this.slice(result[2]);// 获取从result[1]到结束部分
                subLineString2.coordinates.unshift(result[3]);// 在subGeometry2起始出插入result[2]
                break;
            default :
                throw new Error('运行时未知错误');
        }

        return [subLineString1, subLineString2];
    },

    /**
     * 拷贝LineString指定位置，坐标深拷贝，[start，end）
     * 如果end是undefined，则拷贝[start,length - 1]
     * @method slice
     * @param start
     * @param end
     * @return fastmap.mapApi.symbol.LineString
     */
    slice: function (start, end) {
        if (end === undefined || end > this.coordinates.length) {
            end = this.coordinates.length;
        }

        if (start < 0) {
            start = 0;
        }

        var newLineString = new fastmap.mapApi.symbol.LineString();
        for (var i = start; i < end; ++i) {
            newLineString.coordinates.push(this.coordinates[i].clone());
        }

        return newLineString;
    },

    /**
     * 判断两个LineString坐标是否相等
     * @method equal
     * @param lineString
     * @return {boolean}
     */
    equal: function (lineString) {
        if (this.coordinates.length !== lineString.coordinates.length) {
            return false;
        }

        for (var i = 0; i < this.coordinates.length; ++i) {
            if (!this.coordinates[i].equal(lineString.coordinates[i])) {
                return false;
            }
        }

        return true;
    },

    /**
     * 翻转linestring坐标，返回新对象
     * @returns {fastmap.mapApi.symbol.LineString}
     */
    reverse: function () {
        var newLineString = this.clone();
        newLineString.coordinates.reverse();
        return newLineString;
    },

    /**
     * 判断LineString是否闭合
     * @returns {boolean}
     */
    isClosed: function () {
        var length = this.coordinates.length;
        return this.coordinates[0].equal(this.coordinates[length - 1]);
    },

    /**
     * 获取bound
     * @returns bound
     */
    getBound: function () {
        var bound = new fastmap.mapApi.symbol.Bound();
        for (var i = 0; i < this.coordinates.length; ++i) {
            var point = this.coordinates[i];
            var pointBound = point.getBound();
            bound = bound.extend(pointBound);
        }

        return bound;
    }
});

/**
 * Created by xujie on 2016/5/13 0013.
 */

fastmap.mapApi.symbol.Polygon = L.Class.extend({

    initialize: function () {
        this.type = 'Polygon';

        this.coordinates = [];
    },

    /**
     * 克隆对象
     * @method clone
     * @return fastmap.mapApi.symbol.LineString 克隆的对象
     */
    clone: function () {
        var clonePolygon = new fastmap.mapApi.symbol.Polygon();
        for (var i = 0; i < this.coordinates.length; ++i) {
            var lineString = this.coordinates[i].clone();
            clonePolygon.coordinates.push(lineString);
        }

        return clonePolygon;
    },

    /**
     * 计算线长度
     * @method length
     * @return Number 线长度
     */
    length: function () {
        if (this.coordinates.length === 0) {
            return 0;
        }

        var length = 0;

        for (var i = 0; i < this.coordinates.length; ++i) {
            var lineString = this.coordinates[i];
            length += lineString.length();
        }

        return length;
    },

    /**
     * 判断两个Polygon坐标是否相等
     * @method equal
     * @param polygon
     * @return {boolean}
     */
    equal: function (polygon) {
        if (this.coordinates.length !== polygon.coordinates.length) {
            return false;
        }

        for (var i = 0; i < this.coordinates.length; ++i) {
            if (!this.coordinates[i].equal(polygon.coordinates[i])) {
                return false;
            }
        }

        return true;
    },

    /**
     * 获取bound
     * @returns bound
     */
    getBound: function () {
        var bound = new fastmap.mapApi.symbol.Bound();
        for (var i = 0; i < this.coordinates.length; ++i) {
            var lineString = this.coordinates[i];
            var lineStringBound = lineString.getBound();
            bound = bound.extend(lineStringBound);
        }

        return bound;
    }
});

/**
 * Created by xujie on 2016/5/13 0013.
 */

fastmap.mapApi.symbol.Bound = L.Class.extend({
    initialize: function (left, top, right, buttom) {
        this.left = left || 0;
        this.top = top || 0;
        this.right = right || 0;
        this.buttom = buttom || 0;
    },

    extend: function (bound) {
        var left = this.left < bound.left ? this.left : bound.left;
        var top = this.top < bound.top ? this.top : bound.top;
        var right = this.right > bound.right ? this.right : bound.right;
        var buttom = this.buttom > bound.buttom ? this.buttom : bound.buttom;
        var newBound = new fastmap.mapApi.symbol.Bound(left, top, right, buttom);
        return newBound;
    },

    getSize: function () {
        return {
            width: this.right - this.left,
            height: this.buttom - this.top
        };
    },

    getCenter: function () {
        var size = this.getSize();
        var halfWidth = size.width / 2;
        var halfHeight = size.height / 2;
        var cX = this.left + halfWidth;
        var cY = this.top + halfHeight;
        var center = new fastmap.mapApi.symbol.Point(cX, cY);
        return center;
    },

    /**
     * 将bound转换成LineString
     * LineString为顺时针闭合环
     * @param bound
     */
    toLineString: function () {
        var coordinates = [];
        coordinates.push([this.left, this.top]);
        coordinates.push([this.right, this.top]);
        coordinates.push([this.right, this.buttom]);
        coordinates.push([this.left, this.buttom]);
        coordinates.push([this.left, this.top]);

        var gf = fastmap.mapApi.symbol.GeometryFactory.getInstance();
        var lineString = gf.createLineString(coordinates);
        return lineString;
    }
});

/**
 * Created by xujie on 2016/5/12 0012.
 */

/**
 * Created by xujie on 2016/5/11 0011.
 */
fastmap.mapApi.symbol.Template = L.Class.extend({

    initialize: function (pattern, lineString, startOffset) {
        if (pattern !== undefined) {
            this.pattern = pattern;
        } else {
            this.pattern = [];
        }

        if (lineString !== undefined) {
            this.lineString = lineString;
        } else {
            this.lineString = null;
        }

        if (startOffset !== undefined) {
            this.startOffset = startOffset;
        } else {
            this.startOffset = 0;
        }
    },

    /**
     * 将传入的线几何坐标按照模式切分成若干小段
     * 如果pattern元素为0，则返回[LineString]
     * 如果线几何坐标元素小于2，返回[]
     * @method getSegments
     * @return Array [lineString,lineString,...]
     */
    getSegments: function () {
        var segments = [];

        if (this.lineString.coordinates.length < 2) {
            return segments;
        }

        if (this.pattern.length === 0) {
            segments.push(this.lineString.clone());
            return segments;
        }

        // 处理pattern，确保包含偶数个元素
        var newPattern = this.processPattern(this.pattern);

        // 计算pattern的总长度
        var patternLength = this.getPatternLength(newPattern);

        // 切除掉起始偏移长度
        var lineString = this.cutStartOffset(this.startOffset, this.lineString);

        if (!lineString) {
            return [];
        }

        // 将线几何按照模式总长度打段
        segments = this.breakGeometry(patternLength, lineString);

        return segments;
    },

    /**
     * 将segment按照pattern每个元素依次打段
     * 返回下标为偶数的子段，不改变segment
     * segment长度必须小于等于pattern总长度
     * 超出部分将被忽略
     * pattern值为0的元素将被忽略
     * @method getMarks
     * @param segment 要打断的几何
     * @return Array 所有下标为偶数的子段
     */
    getMarks: function (segment) {
        var pattern = this.processPattern(this.pattern);

        var marks = [];
        if (pattern.length === 0) {
            marks.push(segment);
            return marks;
        }

        var sourceSegment = segment;
        for (var i = 0; i < pattern.length; ++i) {
            var subSegments = sourceSegment.splitByLength(pattern[i]);
            if (i % 2 === 0 && subSegments[0] !== null) {
                marks.push(subSegments[0]);// 取下标为偶数的subSegment作为mark
            }

            // 当segment长度小于等于pattern长度时，subSegments[1]为[]
            if (subSegments[1] === null) {
                break;
            }

            sourceSegment = subSegments[1];
        }

        return marks;
    },

    /**
     * 将几何按照startOffset切除.
     * 此方法不会改变原始几何
     * 当startOffset为0时,返回原始几何的拷贝
     * 当原始几何长度小于startOffset时返回null
     * @param startOffset
     * @param lineString
     * @returns 切分后的结果
     */
    cutStartOffset: function (startOffset, lineString) {
        // 计算geometry长度
        var geometryLength = lineString.length();

        var segments = [];

        // geometry长度前置检查
        if (startOffset === 0) {
            var newGeometry = lineString.clone();// 拷贝geometry
            return newGeometry;
        }

        if (geometryLength <= startOffset) {
            return null;
        }

        // 切分几何
        var subLineStrings = lineString.splitByLength(startOffset);
        return subLineStrings[1];
    },

    /**
     * 将线几何按照pattern长度依次打段成若干段，不改变原几何
     * 当线长度小于或者等于length时，
     * segments包含一条几何，与原几何相等，但不是同一对象
     * @method breakGeometry
     * @param length 模式的总长度
     * @param lineString 要切分的几何
     * @returns segments 切分产生的结果
     */
    breakGeometry: function (length, lineString) {
        // 计算geometry长度
        var geometryLength = lineString.length();

        var segments = [];

        // geometry长度前置检查
        if (geometryLength <= length) {
            var newGeometry = lineString.clone();// 拷贝geometry
            return [newGeometry];
        }

        // 循环切分几何
        var i = 1;
        var tmpLineString = lineString;
        while (geometryLength > length * i) {
            var subLineStrings = tmpLineString.splitByLength(length);
            segments.push(subLineStrings[0]);
            tmpLineString = subLineStrings[1];
            ++i;
        }

        // 将最后剩下的一段加入结果集
        segments.push(tmpLineString);

        return segments;
    },

    /**
     * 计算模式长度
     * @method getPatternLength
     * @param patternArray
     * @return number pattern总长度
     */
    getPatternLength: function (patternArray) {
        var length = 0;

        for (var i = 0; i < patternArray.length; ++i) {
            length += patternArray[i];
        }

        return length;
    },

    /**
     * 对模式进行处理，如果模式元素是奇数个，
     * 则将模式重复一遍以保证模式元素总是偶数个
     * @method processPattern
     * @param patternArray
     */
    processPattern: function (patternArray) {
        if (patternArray.length % 2 !== 0) {
            return patternArray.concat(patternArray);
        }

        return patternArray;
    }
});


/**
 * Created by xujie on 2016/5/13 0013.
 */

fastmap.mapApi.symbol.Transformation = L.Class.extend({
    initialize: function () {
        this.matrix = new fastmap.mapApi.symbol.Matrix();
        this.finalMatrix = this.matrix;
        this.stack = [];
    },

    /**
     * 清空变换矩阵数组
     */
    resetTransform: function () {
        this.finalMatrix = this.matrix;
    },

    /**
     * 将几何按照变换矩阵进行坐标变换
     * @param geometry
     * @returns {*}
     */
    transform: function (geometry) {
        var type = geometry.type;
        switch (type) {
            case 'Point':
                geometry = geometry.crossMatrix(this.finalMatrix);
                return geometry;
            case 'LineString':
                geometry.coordinates = geometry.coordinates.map(function (point) {
                    return this.transform(point);
                }, this);
                return geometry;
            case 'Polygon':
                geometry.coordinates = geometry.coordinates.map(function (lineString) {
                    return lineString.coordinates.map(function (point) {
                        return this.transform(point);
                    }, this);
                }, this);
                return geometry;
            default:
                throw new Error('不支持的类型:' + type);
        }
    },

    /**
     * 进行平移变换
     * @param x x轴方向平移距离
     * @param y y轴方向平移距离
     */
    translate: function (x, y) {
        this.finalMatrix = this.matrix.makeTranslate(x, y).cross(this.finalMatrix);
    },

    /**
     * 进行旋转变换
     * @param a 旋转角度，单位度
     */
    rotate: function (a) {
        this.finalMatrix = this.matrix.makeRotate(a).cross(this.finalMatrix);
    },

    /**
     * 进行缩放变换
     * @param x x轴方向缩放比例
     * @param y y轴方向缩放比例
     */
    scale: function (x, y) {
        this.finalMatrix = this.matrix.makeScale(x, y).cross(this.finalMatrix);
    },

    /**
     * 将当前的变换矩阵压入栈
     */
    save: function () {
        this.stack.push(this.finalMatrix);
    },

    /**
     * 弹出栈顶的变换矩阵
     */
    restore: function () {
        if (this.stack.length > 0) {
            this.finalMatrix = this.stack.pop();
            return;
        }

        this.finalMatrix = this.matrix;
    },

    destroy: function () {
        fastmap.mapApi.symbol.Transformation.instance = null;
    },

    statics: {
        instance: null,

        getInstance: function () {
            if (!fastmap.mapApi.symbol.Transformation.instance) {
                fastmap.mapApi.symbol.Transformation.instance =
                    new fastmap.mapApi.symbol.Transformation();
            }
            return fastmap.mapApi.symbol.Transformation.instance;
        }
    }
});

/**
 * Created by xujie on 2016/5/13 0013.
 */

fastmap.mapApi.symbol.Symbol = L.Class.extend({
    initialize: function (options) {
        this.type = '';
        this.name = '';
        this.geometry = null;
    },

    /**
     * 在设备上下文中绘制符号
     * @param ctx 设备上下文
     */
    draw: function (ctx) {
        return;
    },

    /**
     * 从json中读取符号属性
     * @param json
     */
    fromJson: function (json) {
        this.setValue('type', json.type);
        this.setValue('name', json.name);
    },

    /**
     * 将符号属性导出为json对象
     * @returns {} 符号属性的json表达
     */
    toJson: function () {
        return {
            type: this.type,
            name: this.name
        };
    },

    /**
     * 绘制LineString对象,只负责绘制坐标
     * 因为使用频繁，所以封装到基类
     * @param ctx 设备上下文
     * @param geometry LineString对象
     */
    drawLineString: function (ctx, geometry) {
        if (geometry.coordinates.length > 0) {
            ctx.moveTo(geometry.coordinates[0].x, geometry.coordinates[0].y);
            for (var i = 1; i < geometry.coordinates.length; ++i) {
                ctx.lineTo(geometry.coordinates[i].x, geometry.coordinates[i].y);
            }
        }
    },

    /**
     * 如果符号对象拥有对应名称的属性
     * 则将值赋值给符号对象
     * 注意：这是个内部函数，不是公共接口
     * @param property
     * @param json
     */
    setValue: function (property, value) {
        if (!this.hasOwnProperty(property)) {
            return;
        }

        // 允许0值
        if (value === undefined || value === null) {
            return;
        }

        this[property] = value;
    }
});

/**
 * Created by xujie on 2016/5/13 0013.
 */

fastmap.mapApi.symbol.MarkerSymbol = fastmap.mapApi.symbol.Symbol.extend({
    initialize: function (options) {
        // 执行父类初始化
        fastmap.mapApi.symbol.Symbol.prototype.initialize.apply(this, arguments);

        this.color = 'black';
        this.opacity = 1;
        this.offsetX = 0;
        this.offsetY = 0;
        this.angle = 0;
        this.outLine = null;

        // 默认重置变换矩阵
        this.resetTransform = true;

        this.transformation = fastmap.mapApi.symbol.Transformation.getInstance();
    },

    fromJson: function (json) {
        fastmap.mapApi.symbol.Symbol.prototype.fromJson.apply(this, arguments);

        this.setValue('color', json.color);
        this.setValue('opacity', json.opacity);
        this.setValue('offsetX', json.offsetX);
        this.setValue('offsetY', json.offsetY);
        this.setValue('angle', json.angle);
        this.setValue('outLine', json.outLine);
    },

    toJson: function () {
        var json = fastmap.mapApi.symbol.Symbol.prototype.toJson.apply(this, arguments);

        json.color = this.color;
        json.opacity = this.opacity;
        json.offsetX = this.offsetX;
        json.offsetY = this.offsetY;
        json.angle = this.angle;
        json.outLine = this.outLine;
        return json;
    },

    /**
     * 覆盖父类方法，绘制符号
     * @param ctx
     */
    draw: function (ctx) {
        if (!this.geometry) {
            return;
        }

        // 保存当前状态，方便绘制完成后恢复状态
        this.save(ctx);

        this.setTransformation(ctx);

        this.drawSymbol(ctx);

        // 绘制完成后恢复到上次保存的状态，避免影响以后的绘制
        this.restore(ctx);
    },

    /**
     * 设置变换矩阵
     */
    setTransformation: function (ctx) {
        if (this.resetTransform) {
            this.transformation.resetTransform();
            ctx.resetTransform();
        }

        this.transformation.translate(this.geometry.x, this.geometry.y);
        this.transformation.translate(this.offsetX, this.offsetY);
        this.transformation.rotate(this.angle);

        ctx.translate(this.geometry.x, this.geometry.y);
        ctx.translate(this.offsetX, this.offsetY);
        ctx.rotate(this.angle * Math.PI / 180);
    },

    /**
     * 保存绘制环境状态
     */
    save: function (ctx) {
        this.transformation.save();
        ctx.save();
    },

    /**
     * 恢复绘制环境状态
     */
    restore: function (ctx) {
        this.transformation.restore();
        ctx.restore();
    },

    /**
     * 绘制符号,先绘制符号内容，再绘制符号轮廓
     * @param ctx
     */
    drawSymbol: function (ctx) {
        // 绘制符号内容
        this.drawContent(ctx);

        // 绘制符号轮廓线
        if (this.outLine) {
            this.drawOutLine(ctx);
        }
    },

    /**
     * 绘制符号内容
     * @param ctx
     */
    drawContent: function (ctx) {
        return;
    },

    /**
     * 绘制符号轮廓
     * @param ctx
     */
    drawOutLine: function (ctx) {
        // 设置绘制环境
        ctx.strokeStyle = this.outLine.color;
        ctx.lineWidth = this.outLine.width;

        // 获取绘制内容
        var geometry = this.getOutLineGeometry();

        ctx.beginPath();

        // 绘制
        this.drawLineString(ctx, geometry);
        ctx.closePath();

        ctx.stroke();
    },

    /**
     * 创建符号内容几何
     * @returns {null}
     */
    getContentGeometry: function () {
        return null;
    },

    /**
     * 返回符号轮廓
     * @returns {*}
     */
    getOutLineGeometry: function () {
        var gf = fastmap.mapApi.symbol.GeometryFactory.getInstance();

        // 构造符号外包框
        var bound = this.getOriginBound();
        var lineString = bound.toLineString();

        return lineString;
    },

    /**
     * 返回符号在局部坐标系下的bound
     * x方向为宽度，y方向为高度
     * @returns bound
     */
    getOriginBound: function () {
        return null;
    },

    /**
     * 返回符号旋转，平移后的外包框
     * @returns {*}
     */
    getBound: function () {
        var gf = fastmap.mapApi.symbol.GeometryFactory.getInstance();

        // 构造符号外包框
        var originBound = this.getOriginBound();
        var lineString = originBound.toLineString();

        // 转换外包框坐标
        var geomtry = this.transformation.transform(lineString);

        // 获取转换后外包框
        var bound = geomtry.getBound();

        return bound;
    }
});

/**
 * Created by xujie on 2016/5/13 0013.
 */

fastmap.mapApi.symbol.CircleMarkerSymbol = fastmap.mapApi.symbol.MarkerSymbol.extend({
    initialize: function (options) {
        // 执行父类初始化
        fastmap.mapApi.symbol.MarkerSymbol.prototype.initialize.apply(this, arguments);

        this.type = 'CircleMarkerSymbol';

        this.radius = 10;

        this.fromJson(options);
    },

    fromJson: function (json) {
        fastmap.mapApi.symbol.MarkerSymbol.prototype.fromJson.apply(this, arguments);

        this.setValue('radius', json.radius);
    },

    toJson: function () {
        var json = fastmap.mapApi.symbol.MarkerSymbol.prototype.toJson.apply(this, arguments);

        json.radius = this.radius;

        return json;
    },

    drawContent: function (ctx) {
        // 设置绘制环境
        ctx.fillStyle = this.color;
        ctx.globalAlpha = this.opacity;

        // 绘制
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, 2 * Math.PI, false);
        ctx.fill();
    },

    drawOutLine: function (ctx) {
        // 设置绘制环境
        ctx.lineWidth = this.outLine.width;
        ctx.strokeStyle = this.outLine.color;

        // 绘制
        ctx.stroke();
    },

    /**
     * 返回符号在局部坐标系下的bound
     * x方向为宽度，y方向为高度
     * @returns bound
     */
    getOriginBound: function () {
        var gf = fastmap.mapApi.symbol.GeometryFactory.getInstance();
        var bound = gf.createBound(null, this.width, this.height);
        return bound;
    }
});

/**
 * Created by xujie on 2016/5/13 0013.
 */

fastmap.mapApi.symbol.SquareMarkerSymbol = fastmap.mapApi.symbol.MarkerSymbol.extend({
    initialize: function (options) {
        // 执行父类初始化
        fastmap.mapApi.symbol.MarkerSymbol.prototype.initialize.apply(this, arguments);

        this.type = 'SquareMarkerSymbol';

        this.size = 10;

        this.fromJson(options);
    },

    fromJson: function (json) {
        fastmap.mapApi.symbol.MarkerSymbol.prototype.fromJson.apply(this, arguments);

        this.setValue('size', json.size);
    },

    toJson: function () {
        var json = fastmap.mapApi.symbol.MarkerSymbol.prototype.toJson.apply(this, arguments);

        json.size = this.size;

        return json;
    },

    drawContent: function (ctx) {
        // 设置绘制环境
        ctx.fillStyle = this.color;
        ctx.globalAlpha = this.opacity;

        // 获取绘制内容
        var geometry = this.getContentGeometry();

        ctx.beginPath();
        // 绘制
        this.drawLineString(ctx, geometry);
        ctx.closePath();

        ctx.fill();
    },

    drawOutLine: function (ctx) {
        // 设置绘制环境
        ctx.lineWidth = this.outLine.width;
        ctx.strokeStyle = this.outLine.color;

        // 绘制
        ctx.stroke();
    },

    getContentGeometry: function () {
        return this.getOriginBound().toLineString();
    },

    /**
     * 返回符号在局部坐标系下的bound
     * x方向为宽度，y方向为高度
     * @returns bound
     */
    getOriginBound: function () {
        var gf = fastmap.mapApi.symbol.GeometryFactory.getInstance();
        var bound = gf.createBound(null, this.size, this.size);
        return bound;
    }
});

/**
 * Created by xujie on 2016/5/13 0013.
 */

fastmap.mapApi.symbol.RectangleMarkerSymbol = fastmap.mapApi.symbol.MarkerSymbol.extend({
    initialize: function (options) {
        // 执行父类初始化
        fastmap.mapApi.symbol.MarkerSymbol.prototype.initialize.apply(this, arguments);

        this.type = 'RectangleMarkerSymbol';

        this.width = 10;
        this.height = 10;

        this.fromJson(options);
    },

    fromJson: function (json) {
        fastmap.mapApi.symbol.MarkerSymbol.prototype.fromJson.apply(this, arguments);

        this.setValue('width', json.width);
        this.setValue('height', json.height);
    },

    toJson: function () {
        var json = fastmap.mapApi.symbol.MarkerSymbol.prototype.toJson.apply(this, arguments);

        json.width = this.width;
        json.height = this.height;

        return json;
    },

    drawContent: function (ctx) {
        // 设置绘制环境
        ctx.fillStyle = this.color;
        ctx.globalAlpha = this.opacity;

        // 获取绘制内容
        var geometry = this.getContentGeometry();

        ctx.beginPath();
        // 绘制
        this.drawLineString(ctx, geometry);
        ctx.closePath();

        ctx.fill();
    },

    drawOutLine: function (ctx) {
        // 设置绘制环境
        ctx.lineWidth = this.outLine.width;
        ctx.strokeStyle = this.outLine.color;

        // 绘制
        ctx.stroke();
    },

    getContentGeometry: function () {
        return this.getOriginBound().toLineString();
    },

    /**
     * 返回符号在局部坐标系下的bound
     * x方向为宽度，y方向为高度
     * @returns bound
     */
    getOriginBound: function () {
        var gf = fastmap.mapApi.symbol.GeometryFactory.getInstance();
        var bound = gf.createBound(null, this.width, this.height);
        return bound;
    }
});

/**
 * Created by xujie on 2016/5/13 0013.
 */

fastmap.mapApi.symbol.CrossMarkerSymbol = fastmap.mapApi.symbol.MarkerSymbol.extend({
    initialize: function (options) {
        // 执行父类初始化
        fastmap.mapApi.symbol.MarkerSymbol.prototype.initialize.apply(this, arguments);

        this.type = 'CrossMarkerSymbol';

        this.size = 10;
        this.width = 1;

        this.fromJson(options);
    },

    fromJson: function (json) {
        fastmap.mapApi.symbol.MarkerSymbol.prototype.fromJson.apply(this, arguments);

        this.setValue('size', json.size);
        this.setValue('width', json.width);
    },

    toJson: function () {
        var json = fastmap.mapApi.symbol.MarkerSymbol.prototype.toJson.apply(this, arguments);

        json.size = this.size;
        json.width = this.width;

        return json;
    },

    drawContent: function (ctx) {
        // 设置绘制环境
        ctx.strokeStyle = this.color;
        ctx.lineWidth = this.width;
        ctx.globalAlpha = this.opacity;

        // 获取绘制内容
        var geometry = this.getContentGeometry();

        // 绘制
        ctx.beginPath();
        ctx.moveTo(geometry.coordinates[0].x, geometry.coordinates[0].y);
        ctx.lineTo(geometry.coordinates[1].x, geometry.coordinates[1].y);
        ctx.moveTo(geometry.coordinates[2].x, geometry.coordinates[2].y);
        ctx.lineTo(geometry.coordinates[3].x, geometry.coordinates[3].y);
        ctx.stroke();
    },

    getContentGeometry: function () {
        // 构造十字叉几何
        var coordinates = [];
        coordinates.push([-this.size / 2, 0]);
        coordinates.push([this.size / 2, 0]);
        coordinates.push([0, -this.size / 2]);
        coordinates.push([0, this.size / 2]);

        var gf = fastmap.mapApi.symbol.GeometryFactory.getInstance();
        var geometry = gf.createLineString(coordinates);
        return geometry;
    },

    /**
     * 返回符号在局部坐标系下的bound
     * x方向为宽度，y方向为高度
     * @returns bound
     */
    getOriginBound: function () {
        var gf = fastmap.mapApi.symbol.GeometryFactory.getInstance();
        var bound = gf.createBound(null, this.size, this.size);
        return bound;
    }
});

/**
 * Created by xujie on 2016/5/13 0013.
 */

fastmap.mapApi.symbol.TiltedCrossMarkerSymbol = fastmap.mapApi.symbol.MarkerSymbol.extend({
    initialize: function (options) {
        // 执行父类初始化
        fastmap.mapApi.symbol.MarkerSymbol.prototype.initialize.apply(this, arguments);

        this.type = 'TiltedCrossMarkerSymbol';

        this.size = 10;
        this.width = 1;

        this.fromJson(options);
    },

    fromJson: function (json) {
        fastmap.mapApi.symbol.MarkerSymbol.prototype.fromJson.apply(this, arguments);

        this.setValue('size', json.size);
        this.setValue('width', json.width);
    },

    toJson: function () {
        var json = fastmap.mapApi.symbol.MarkerSymbol.prototype.toJson.apply(this, arguments);

        json.size = this.size;
        json.width = this.width;

        return json;
    },

    drawContent: function (ctx) {
        // 设置绘制环境
        ctx.strokeStyle = this.color;
        ctx.lineWidth = this.width;
        ctx.globalAlpha = this.opacity;

        // 获取绘制内容
        var geometry = this.getContentGeometry();

        // 绘制
        ctx.beginPath();
        ctx.moveTo(geometry.coordinates[0].x, geometry.coordinates[0].y);
        ctx.lineTo(geometry.coordinates[1].x, geometry.coordinates[1].y);
        ctx.moveTo(geometry.coordinates[2].x, geometry.coordinates[2].y);
        ctx.lineTo(geometry.coordinates[3].x, geometry.coordinates[3].y);
        ctx.stroke();
    },

    getContentGeometry: function () {
        // 构造斜十字叉几何
        var coordinates = [];
        coordinates.push([-this.size / 2, -this.size / 2]);
        coordinates.push([this.size / 2, this.size / 2]);
        coordinates.push([-this.size / 2, this.size / 2]);
        coordinates.push([this.size / 2, -this.size / 2]);

        var gf = fastmap.mapApi.symbol.GeometryFactory.getInstance();
        var geometry = gf.createLineString(coordinates);
        return geometry;
    },

    /**
     * 返回符号在局部坐标系下的bound
     * x方向为宽度，y方向为高度
     * @returns bound
     */
    getOriginBound: function () {
        var gf = fastmap.mapApi.symbol.GeometryFactory.getInstance();
        var bound = gf.createBound(null, this.size, this.size);
        return bound;
    }
});

/**
 * Created by xujie on 2016/5/13 0013.
 */

fastmap.mapApi.symbol.TriangleMarkerSymbol = fastmap.mapApi.symbol.MarkerSymbol.extend({
    initialize: function (options) {
        // 执行父类初始化
        fastmap.mapApi.symbol.MarkerSymbol.prototype.initialize.apply(this, arguments);

        this.type = 'TriangleMarkerSymbol';

        this.width = 10;
        this.height = 20;
        // 箭头尾部凹陷的长度
        this.sunken = 0;

        this.fromJson(options);
    },

    fromJson: function (json) {
        fastmap.mapApi.symbol.MarkerSymbol.prototype.fromJson.apply(this, arguments);

        this.setValue('width', json.width);
        this.setValue('height', json.height);
        this.setValue('sunken', json.sunken);
    },

    toJson: function () {
        var json = fastmap.mapApi.symbol.MarkerSymbol.prototype.toJson.apply(this, arguments);

        json.width = this.width;
        json.height = this.height;
        json.sunken = this.sunken;

        return json;
    },

    drawContent: function (ctx) {
        // 设置绘制环境
        ctx.fillStyle = this.color;
        ctx.globalAlpha = this.opacity;

        // 获取绘制内容
        var geometry = this.getContentGeometry();

        ctx.beginPath();

        // 绘制
        this.drawLineString(ctx, geometry);
        ctx.closePath();

        ctx.fill();
    },

    drawOutLine: function (ctx) {
        // 设置绘制环境
        ctx.lineWidth = this.outLine.width;
        ctx.strokeStyle = this.outLine.color;

        // 绘制
        ctx.stroke();
    },

    getContentGeometry: function () {
        // 构造箭头形状
        var fPoint = new fastmap.mapApi.symbol.Point(0, -this.height / 2);
        var vY = new fastmap.mapApi.symbol.Vector(0, 1);
        var matrix = new fastmap.mapApi.symbol.Matrix();

        // 将y轴正方向单位向量分别向左右旋转一个角度得到左右两边的单位向量vL，vR
        var angle = Math.atan(this.width / 2 / this.height) * 180 / Math.PI;
        var vL = vY.crossMatrix(matrix.makeRotate(-angle));
        var vR = vY.crossMatrix(matrix.makeRotate(angle));

        // vL，vR分别乘以模长度
        var triangleLength = Math.sqrt(this.width / 2 * this.width / 2 + this.height * this.height);
        vL = vL.multiNumber(triangleLength);
        vR = vR.multiNumber(triangleLength);

        // 起点加上vL，vR得到左右两个点
        var lPoint = fPoint.plusVector(vL);
        var rPoint = fPoint.plusVector(vR);

        // 处理尾部凹陷，凹陷长度必须在0到length之间
        // 如果超出这个范围则当成无尾部凹陷处理
        var remainder = this.height - this.sunken;
        if (this.sunken < 0 || this.sunken > this.height) {
            remainder = this.height;
        }

        // 起点加上尾部向量得到尾部点
        var vC = vY.multiNumber(remainder);
        var cPoint = fPoint.plusVector(vC);

        // 用顶点，左右点，尾部点构造几何
        var geometry = new fastmap.mapApi.symbol.LineString();
        geometry.coordinates.push(fPoint);
        geometry.coordinates.push(lPoint);
        geometry.coordinates.push(cPoint);
        geometry.coordinates.push(rPoint);
        geometry.coordinates.push(fPoint);

        return geometry;
    },

    /**
     * 返回符号在局部坐标系下的bound
     * x方向为宽度，y方向为高度
     * @returns bound
     */
    getOriginBound: function () {
        var gf = fastmap.mapApi.symbol.GeometryFactory.getInstance();
        var bound = gf.createBound(null, this.width, this.height);
        return bound;
    }
});

/**
 * Created by xujie on 2016/11/26.
 */
fastmap.mapApi.symbol.ImageLoader = L.Class.extend({

    initialize: function (urls) {
        this.urls = urls;
        this.resourceFactory = fastmap.mapApi.symbol.ResourceFactory.getInstance();
    },

    load: function (success, error) {
        var self = this;
        var promise = new Promise(function (resolve, reject) {
            if (self.urls.length === 0) {
                resolve();
                return;
            }

            var promises = self.getPromises();

            if (promises.length === 0) {
                resolve();
                return;
            }

            Promise.all(promises)
                .then(function (res) {
                    self.addToResourceFactory(res, self.resourceFactory);
                    resolve();
                })
                .catch(function (e) {
                    FM.Util.log(e);
                    reject(e);
                });
        });

        return promise;
    },

    getPromises: function () {
        var promises = [];
        for (var i = 0; i < this.urls.length; ++i) {
            var url = this.urls[i];
            if (this.resourceFactory.containResource(url)) {
                continue;
            }
            promises.push(this.loadImage(url));
        }
        return promises;
    },

    loadImage: function (url) {
        var promise = new Promise(function (resolve, reject) {
            var image = new Image();
            image.onload = function () {
                var res = {
                    url: url,
                    image: image
                };
                resolve(res);
            };
            image.onerror = function () {
                var res = {
                    url: url,
                    image: null
                };
                resolve(res);
            };
            image.src = url;
        });

        return promise;
    },

    addToResourceFactory: function (resources, factory) {
        for (var i = 0; i < resources.length; ++i) {
            var resource = resources[i];
            var key = resource.url;
            var value = resource.image;
            if (!key || !value) {
                return;
            }

            factory.add(key, value);
        }
    }
});

/**
 * Created by xujie on 2016/5/13 0013.
 */

fastmap.mapApi.symbol.ImageMarkerSymbol = fastmap.mapApi.symbol.MarkerSymbol.extend({
    initialize: function (options) {
        // 执行父类初始化
        fastmap.mapApi.symbol.MarkerSymbol.prototype.initialize.apply(this, arguments);

        this.type = 'ImageMarkerSymbol';

        this.url = '';
        this.width = 10;
        this.height = 10;

        this.fromJson(options);
    },

    fromJson: function (json) {
        fastmap.mapApi.symbol.MarkerSymbol.prototype.fromJson.apply(this, arguments);

        this.setValue('url', json.url);
        this.setValue('width', json.width);
        this.setValue('height', json.height);
    },

    toJson: function () {
        var json = fastmap.mapApi.symbol.MarkerSymbol.prototype.toJson.apply(this, arguments);

        json.url = this.url;
        json.width = this.width;
        json.height = this.height;

        return json;
    },

    draw: function (ctx) {
        if (!this.url) {
            return;
        }

        fastmap.mapApi.symbol.MarkerSymbol.prototype.draw.apply(this, arguments);
    },

    drawContent: function (ctx) {
        var resourceFactory = fastmap.mapApi.symbol.ResourceFactory.getInstance();
        var image = resourceFactory.getResource(this.url);
        if (!image) {
            return;
        }

        // 设置绘制环境
        ctx.globalAlpha = this.opacity;

        // 绘制
        ctx.drawImage(image, -this.width / 2, -this.height / 2, this.width, this.height);
    },

    /**
     * 返回符号在局部坐标系下的bound
     * x方向为宽度，y方向为高度
     * @returns bound
     */
    getOriginBound: function () {
        var gf = fastmap.mapApi.symbol.GeometryFactory.getInstance();
        var bound = gf.createBound(null, this.width, this.height);
        return bound;
    }
});

/**
 * Created by xujie on 2016/5/13 0013.
 */

fastmap.mapApi.symbol.MultiImageMarkerSymbol = fastmap.mapApi.symbol.MarkerSymbol.extend({
    initialize: function (options) {
        // 执行父类初始化
        fastmap.mapApi.symbol.MarkerSymbol.prototype.initialize.apply(this, arguments);

        this.type = 'MultiImageMarkerSymbol';

        this.width = 10;
        this.height = 10;
        this.hGap = 0;
        this.vGap = 0;
        this.urls = [];

        this.fromJson(options);
    },

    fromJson: function (json) {
        fastmap.mapApi.symbol.MarkerSymbol.prototype.fromJson.apply(this, arguments);

        this.setValue('width', json.width);
        this.setValue('height', json.height);
        this.setValue('hGap', json.hGap);
        this.setValue('vGap', json.vGap);
        this.setValue('urls', json.urls);
    },

    toJson: function () {
        var json = fastmap.mapApi.symbol.MarkerSymbol.prototype.toJson.apply(this, arguments);

        json.width = this.width;
        json.height = this.height;
        json.hGap = this.hGap;
        json.vGap = this.vGap;
        json.urls = this.urls;

        return json;
    },

    draw: function (ctx) {
        if (!this.urls) {
            return;
        }

        if (this.urls.length === 0) {
            return;
        }

        fastmap.mapApi.symbol.MarkerSymbol.prototype.draw.apply(this, arguments);
    },

    drawContent: function (ctx) {
        var geometries = this.getGeometries();

        var json = {
            type: 'ImageMarkerSymbol',
            width: this.width,
            height: this.height
        };
        var symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();
        var symbol = symbolFactory.createSymbol(json);
        symbol.resetTransform = false;

        for (var i = 0; i < this.urls.length; ++i) {
            for (var j = 0; j < this.urls[i].length; ++j) {
                var geometry = geometries[i][j];
                var url = this.urls[i][j];
                if (!url) {
                    continue;
                }
                this.drawImage(url, geometry, ctx, symbol);
            }
        }

        symbol.resetTransform = true;
    },

    getGeometries: function () {
        var info = this.getRowAndColumn();
        var actualHGap = this.hGap ? this.hGap : this.width;
        var actualVGap = this.vGap ? this.vGap : this.height;
        var totalWidth = this.width + actualHGap * (info.col - 1);
        var totalHeight = this.height + actualVGap * (info.row - 1);
        var startX = -totalWidth / 2;
        var startY = -totalHeight / 2;
        var geometries = [];
        for (var i = 0; i < info.row; ++i) {
            var y = startY + actualVGap * i + this.height / 2;
            var row = [];
            for (var j = 0; j < info.col; ++j) {
                var x = startX + actualHGap * j + this.width / 2;
                var geometry = new fastmap.mapApi.symbol.Point(x, y);
                row.push(geometry);
            }
            geometries.push(row);
        }

        return geometries;
    },

    getRowAndColumn: function () {
        var row = this.urls.length;
        var col = 0;
        for (var i = 0; i < this.urls.length; ++i) {
            var temCol = this.urls[i].length;
            if (col < temCol) {
                col = temCol;
            }
        }

        return {
            row: row,
            col: col
        };
    },

    drawImage: function (url, geometry, ctx, symbol) {
        symbol.url = url;
        symbol.geometry = geometry;
        symbol.draw(ctx);
    },

    /**
     * 返回符号在局部坐标系下的bound
     * x方向为宽度，y方向为高度
     * @returns bound
     */
    getOriginBound: function () {
        var info = this.getRowAndColumn();
        var actualHGap = this.hGap ? this.hGap : this.width;
        var actualVGap = this.vGap ? this.vGap : this.height;
        var totalWidth = this.width + actualHGap * (info.col - 1);
        var totalHeight = this.height + actualVGap * (info.row - 1);
        var gf = fastmap.mapApi.symbol.GeometryFactory.getInstance();
        var bound = gf.createBound(null, totalWidth, totalHeight);
        return bound;
    }
});

/**
 * Created by xujie on 2016/5/13 0013.
 */

fastmap.mapApi.symbol.TextMarkerSymbol = fastmap.mapApi.symbol.MarkerSymbol.extend({
    initialize: function (options) {
        // 执行父类初始化
        fastmap.mapApi.symbol.MarkerSymbol.prototype.initialize.apply(this, arguments);

        this.type = 'TextMarkerSymbol';

        this.text = '';
        this.font = '微软雅黑';
        this.size = 10;
        this.align = 'center';
        this.baseline = 'middle';
        this.direction = 'ltr';

        this.fromJson(options);
    },

    fromJson: function (json) {
        fastmap.mapApi.symbol.MarkerSymbol.prototype.fromJson.apply(this, arguments);

        this.setValue('text', json.text);
        this.setValue('font', json.font);
        this.setValue('size', json.size);
        this.setValue('align', json.align);
        this.setValue('baseline', json.baseline);
        this.setValue('direction', json.direction);
    },

    toJson: function () {
        var json = fastmap.mapApi.symbol.MarkerSymbol.prototype.toJson.apply(this, arguments);

        json.text = this.text;
        json.font = this.font;
        json.size = this.size;
        json.align = this.align;
        json.baseline = this.baseline;
        json.direction = this.direction;

        return json;
    },

    draw: function (ctx) {
        if (this.text === null || this.text === undefined || this.text.length === 0) {
            return;
        }

        fastmap.mapApi.symbol.MarkerSymbol.prototype.draw.apply(this, arguments);
    },

    drawContent: function (ctx) {
        // 设置绘制环境
        ctx.font = this.size + 'px ' + this.font;
        ctx.textAlign = this.align;
        ctx.textBaseline = this.baseline;
        ctx.direction = this.direction;
        ctx.fillStyle = this.color;
        ctx.globalAlpha = this.opacity;

        // 绘制
        ctx.fillText(this.text, 0, 0);
    },

    /**
     * measureText的兼容版本
     * 如果measureText返回的只有width属性，把字符近似看做一个正方形
     * @returns {*|TextMetrics}
     */
    measureText: function () {
        var canvas = document.createElement('canvas');
        var ctx = canvas.getContext('2d');
        ctx.save();

        ctx.font = this.size + 'px ' + this.font;
        ctx.textAlign = this.align;
        ctx.textBaseline = this.baseline;
        ctx.direction = this.direction;

        var m = ctx.measureText(this.text);
        var width = m.width / 2;
        var height = this.size / 2;
        var newM = {
            width: m.width,
            actualBoundingBoxLeft: m.actualBoundingBoxLeft !== undefined ?
                m.actualBoundingBoxLeft : width,
            actualBoundingBoxRight: m.actualBoundingBoxRight !== undefined ?
                m.actualBoundingBoxRight : width,
            actualBoundingBoxAscent: m.actualBoundingBoxAscent !== undefined ?
                m.actualBoundingBoxAscent : height,
            actualBoundingBoxDescent: m.actualBoundingBoxDescent !== undefined ?
                m.actualBoundingBoxDescent : height
        };

        ctx.restore();

        return newM;
    },

    /**
     * 返回符号在局部坐标系下的bound
     * x方向为宽度，y方向为高度
     * @returns bound
     */
    getOriginBound: function () {
        var m = this.measureText();
        var width = m.actualBoundingBoxLeft + m.actualBoundingBoxRight;
        var height = m.actualBoundingBoxAscent + m.actualBoundingBoxDescent;
        var gf = fastmap.mapApi.symbol.GeometryFactory.getInstance();
        var bound = gf.createBound(null, width, height);
        return bound;
    }
});

/**
 * Created by xujie on 2016/5/13 0013.
 */

fastmap.mapApi.symbol.CompositeMarkerSymbol = fastmap.mapApi.symbol.MarkerSymbol.extend({
    initialize: function (options) {
        // 执行父类初始化
        fastmap.mapApi.symbol.MarkerSymbol.prototype.initialize.apply(this, arguments);

        this.type = 'CompositeMarkerSymbol';

        this.symbols = [];

        this.fromJson(options);
    },

    fromJson: function (json) {
        fastmap.mapApi.symbol.MarkerSymbol.prototype.fromJson.apply(this, arguments);

        if (!json.symbols) {
            return;
        }

        var symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();
        for (var i = 0; i < json.symbols.length; ++i) {
            this.symbols.push(symbolFactory.createSymbol(json.symbols[i]));
        }
    },

    toJson: function () {
        var json = fastmap.mapApi.symbol.MarkerSymbol.prototype.toJson.apply(this, arguments);

        json.symbols = [];
        for (var i = 0; i < this.symbols.length; ++i) {
            json.symbols.push(this.symbols[i].toJson());
        }

        return json;
    },

    draw: function (ctx) {
        if (!this.symbols.length) {
            return;
        }

        if (this.symbols.length === 0) {
            return;
        }

        fastmap.mapApi.symbol.MarkerSymbol.prototype.draw.apply(this, arguments);
    },

    drawContent: function (ctx) {
        for (var i = 0; i < this.symbols.length; ++i) {
            var symbol = this.symbols[i];
            symbol.resetTransform = false;
            symbol.geometry = new fastmap.mapApi.symbol.Point(0, 0);
            symbol.draw(ctx);
            symbol.resetTransform = true;
        }
    },

    /**
     * 返回符号在局部坐标系下的bound
     * x方向为宽度，y方向为高度
     * @returns bound
     */
    getOriginBound: function () {
        this.transformation.save();
        var bound = new fastmap.mapApi.symbol.Bound();
        for (var i = 0; i < this.symbols.length; ++i) {
            this.transformation.resetTransform();
            var symbol = this.symbols[i];
            var symbolBound = symbol.getOriginBound();
            this.transformation.translate(symbol.offsetX, symbol.offsetY);
            this.transformation.rotate(symbol.angle);
            var lineString = symbolBound.toLineString();
            lineString = this.transformation.transform(lineString);
            bound = bound.extend(lineString.getBound());
        }
        this.transformation.restore();
        return bound;
    }
});

/**
 * Created by xujie on 2016/5/13 0013.
 */

fastmap.mapApi.symbol.LineSymbol = fastmap.mapApi.symbol.Symbol.extend({
    initialize: function (options) {
        // 执行父类初始化
        fastmap.mapApi.symbol.Symbol.prototype.initialize.apply(this, arguments);
    },

    fromJson: function (json) {
        fastmap.mapApi.symbol.Symbol.prototype.fromJson.apply(this, arguments);
    },

    toJson: function () {
        var json = fastmap.mapApi.symbol.Symbol.prototype.toJson.apply(this, arguments);

        return json;
    }
});

/**
 * Created by xujie on 2016/5/13 0013.
 */

fastmap.mapApi.symbol.SimpleLineSymbol = fastmap.mapApi.symbol.LineSymbol.extend({
    initialize: function (options) {
        // 执行父类初始化
        fastmap.mapApi.symbol.LineSymbol.prototype.initialize.apply(this, arguments);

        this.type = 'SimpleLineSymbol';

        this.width = 1;
        this.color = 'black';
        this.style = 'solid';
        this.opacity = 1;
        this.cap = 'butt';
        this.shadowColor = null;
        this.shadowBlur = 0;
        this.shadowOffsetX = 0;
        this.shadowOffsetY = 0;

        this.fromJson(options);
    },

    fromJson: function (json) {
        fastmap.mapApi.symbol.LineSymbol.prototype.fromJson.apply(this, arguments);

        this.setValue('width', json.width);
        this.setValue('color', json.color);
        this.setValue('style', json.style);
        this.setValue('opacity', json.opacity);
        this.setValue('cap', json.cap);
        this.setValue('shadowColor', json.shadowColor || null);
        this.setValue('shadowBlur', json.shadowBlur || 0);
        this.setValue('shadowOffsetX', json.shadowOffsetX || 0);
        this.setValue('shadowOffsetY', json.shadowOffsetY || 0);
    },

    toJson: function () {
        var json = fastmap.mapApi.symbol.LineSymbol.prototype.toJson.apply(this, arguments);

        json.width = this.width;
        json.color = this.color;
        json.style = this.style;
        json.opacity = this.opacity;
        json.cap = this.cap;

        return json;
    },

    draw: function (ctx) {
        if (!this.geometry || !this.geometry.coordinates) {
            return;
        }

        if (this.geometry.coordinates.length < 2) {
            return;
        }

        if (!this.style) {
            return;
        }

        // 保存当前状态，方便绘制完成后恢复状态
        ctx.save();

        var dashPattern = this.styleToPattern(this.style);
        ctx.setLineDash(dashPattern);// 设置虚线样式
        ctx.strokeStyle = this.color;
        ctx.lineWidth = this.width;
        ctx.globalAlpha = this.opacity;
        ctx.lineCap = this.cap;
        if (this.shadowColor) {
            ctx.shadowColor = this.shadowColor;
            ctx.shadowBlur = this.shadowBlur;
            ctx.shadowOffsetX = this.shadowOffsetX;
            ctx.shadowOffsetY = this.shadowOffsetY;
        }

        ctx.beginPath();
        this.drawLineString(ctx, this.geometry);
        if (this.geometry.isClosed()) {
            ctx.closePath();
        }
        ctx.stroke();

        // 绘制完成后恢复到上次保存的状态，避免影响以后的绘制
        ctx.restore();
    },

    styleToPattern: function (style) {
        var dashPattern = [];
        switch (style) {
            case 'solid':
                dashPattern = [];
                break;
            case 'dash':
                dashPattern = [10, 5];
                break;
            case 'dot':
                dashPattern = [2, 2];
                break;
            case 'dashDot':
                dashPattern = [10, 2, 2, 2];
                break;
            case 'dashDotDot':
                dashPattern = [10, 2, 2, 2, 2, 2];
                break;
            default:
                dashPattern = [];
                break;
        }

        return dashPattern;
    }
});

/**
 * Created by xujie on 2016/5/13 0013.
 */

fastmap.mapApi.symbol.CartoLineSymbol = fastmap.mapApi.symbol.LineSymbol.extend({
    initialize: function (options) {
        // 执行父类初始化
        fastmap.mapApi.symbol.LineSymbol.prototype.initialize.apply(this, arguments);

        this.type = 'CartoLineSymbol';
        this.width = 1;
        this.color = 'black';
        this.opacity = 1;
        this.cap = 'butt';
        this.pattern = [];
        this.startOffset = 0;

        this.fromJson(options);
    },

    fromJson: function (json) {
        fastmap.mapApi.symbol.LineSymbol.prototype.fromJson.apply(this, arguments);

        this.setValue('width', json.width);
        this.setValue('color', json.color);
        this.setValue('opacity', json.opacity);
        this.setValue('cap', json.cap);
        this.setValue('pattern', json.pattern);
        this.setValue('startOffset', json.startOffset);
    },

    toJson: function () {
        var json = fastmap.mapApi.symbol.LineSymbol.prototype.toJson.apply(this, arguments);

        json.width = this.width;
        json.color = this.color;
        json.opacity = this.opacity;
        json.cap = this.cap;
        json.pattern = this.pattern;
        json.startOffset = this.startOffset;

        return json;
    },

    draw: function (ctx) {
        if (!this.geometry || !this.geometry.coordinates) {
            return;
        }

        if (this.geometry.coordinates.length < 2) {
            return;
        }

        if (!this.pattern) {
            return;
        }

        // 保存当前状态，方便绘制完成后恢复状态
        ctx.save();

        ctx.strokeStyle = this.color;
        ctx.lineWidth = this.width;
        ctx.globalAlpha = this.opacity;
        ctx.lineCap = this.cap;

        var template = new fastmap.mapApi.symbol.Template();
        template.startOffset = this.startOffset;
        template.pattern = this.pattern;
        template.lineString = this.geometry;
        var segments = template.getSegments();

        ctx.beginPath();
        for (var i = 0; i < segments.length; ++i) {
            this.drawSegment(ctx, segments[i], template);
        }
        if (this.geometry.isClosed()) {
            ctx.closePath();
        }
        ctx.stroke();

        // 绘制完成后恢复到上次保存的状态，避免影响以后的绘制
        ctx.restore();
    },

    drawSegment: function (ctx, segment, template) {
        var marks = template.getMarks(segment);
        for (var i = 0; i < marks.length; ++i) {
            this.drawLineString(ctx, marks[i]);
        }
    }
});

/**
 * Created by xujie on 2016/5/13 0013.
 */

fastmap.mapApi.symbol.MarkerLineSymbol = fastmap.mapApi.symbol.LineSymbol.extend({
    initialize: function (options) {
        // 执行父类初始化
        fastmap.mapApi.symbol.LineSymbol.prototype.initialize.apply(this, arguments);

        this.type = 'MarkerLineSymbol';

        this.pattern = [];
        this.startOffset = 0;
        this.direction = 's2e';
        this.marker = null;

        this.fromJson(options);
    },

    fromJson: function (json) {
        fastmap.mapApi.symbol.LineSymbol.prototype.fromJson.apply(this, arguments);

        this.setValue('pattern', json.pattern);
        this.setValue('startOffset', json.startOffset);
        this.setValue('direction', json.direction);
        var symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();
        if (json.marker) {
            this.marker = symbolFactory.createSymbol(json.marker);
        }
    },

    toJson: function () {
        var json = fastmap.mapApi.symbol.LineSymbol.prototype.toJson.apply(this, arguments);

        json.pattern = this.pattern;
        json.startOffset = this.startOffset;
        json.direction = this.direction;
        if (this.marker) {
            json.marker = this.marker.toJson();
        }

        return json;
    },

    draw: function (ctx) {
        if (!this.geometry || !this.geometry.coordinates) {
            return;
        }

        if (this.geometry.coordinates.length < 2) {
            return;
        }

        if (!this.marker) {
            return;
        }

        if (!this.pattern) {
            return;
        }

        var template = new fastmap.mapApi.symbol.Template();
        template.startOffset = this.startOffset;
        template.pattern = this.pattern;
        if (this.direction === 's2e') {
            template.lineString = this.geometry;
        } else {
            template.lineString = this.geometry.reverse();
        }
        var segments = template.getSegments();

        for (var i = 0; i < segments.length; ++i) {
            this.drawSegment(ctx, segments[i], template);
        }
    },

    drawSegment: function (ctx, segment, template) {
        // 在每段mark的第一个坐标处绘制marker，方向取当前形状边方向
        var marks = template.getMarks(segment);
        for (var i = 0; i < marks.length; ++i) {
            var mark = marks[i];
            var vY = new fastmap.mapApi.symbol.Vector(0, -1);
            var vN = mark.coordinates[1].minus(mark.coordinates[0]);

            var angle = vY.angleTo(vN);
            var signal = vY.cross(vN);

            if (signal < 0) {
                angle = -angle;
            }

            this.drawMarker(ctx, angle, mark);
        }
    },

    drawMarker: function (ctx, angle, mark) {
        this.marker.angle = angle;
        this.marker.geometry = mark.coordinates[0];
        this.marker.draw(ctx);
    }
});

/**
 * Created by xujie on 2016/5/11 0011.
 */
fastmap.mapApi.symbol.HashLineSymbol = fastmap.mapApi.symbol.LineSymbol.extend({

    initialize: function (options) {
        // 执行父类初始化
        fastmap.mapApi.symbol.LineSymbol.prototype.initialize.apply(this, arguments);

        this.type = 'HashLineSymbol';

        this.hashHeight = 10;
        this.hashOffset = 0;
        this.hashAngle = -90;
        this.hashLine = null;
        this.pattern = [2, 5];
        this.startOffset = 0;

        this.fromJson(options);
    },

    fromJson: function (json) {
        fastmap.mapApi.symbol.LineSymbol.prototype.fromJson.apply(this, arguments);

        this.setValue('hashHeight', json.hashHeight);
        this.setValue('hashOffset', json.hashOffset);
        this.setValue('hashAngle', json.hashAngle);
        this.setValue('pattern', json.pattern);
        this.setValue('startOffset', json.startOffset);
        var symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();
        if (json.hashLine) {
            this.hashLine = symbolFactory.createSymbol(json.hashLine);
        }
    },

    toJson: function () {
        var json = fastmap.mapApi.symbol.LineSymbol.prototype.toJson.apply(this, arguments);

        json.hashHeight = this.hashHeight;
        json.hashOffset = this.hashOffset;
        json.hashAngle = this.hashAngle;
        json.pattern = this.pattern;
        json.startOffset = this.startOffset;
        if (this.hashLine) {
            json.hashLine = this.hashLine.toJson();
        }

        return json;
    },

    draw: function (ctx) {
        if (!this.geometry || !this.geometry.coordinates) {
            return;
        }

        if (this.geometry.coordinates.length < 2) {
            return;
        }

        if (!this.hashLine) {
            return;
        }

        if (!this.pattern) {
            return;
        }

        var template = new fastmap.mapApi.symbol.Template();
        template.startOffset = this.startOffset;
        template.pattern = this.pattern;
        template.lineString = this.geometry;

        var segments = template.getSegments();

        for (var i = 0; i < segments.length; ++i) {
            this.drawSegment(ctx, segments[i], template);
        }
    },

    drawSegment: function (ctx, segment, template) {
        var marks = template.getMarks(segment);
        for (var i = 0; i < marks.length; ++i) {
            var mark = marks[i];

            // 以mark的前两个点构造向量
            var vector = mark.coordinates[1].minus(mark.coordinates[0]);
            vector.normalize();

            // 将向量顺时针旋转指定角度
            var matrix = new fastmap.mapApi.symbol.Matrix();
            matrix = matrix.makeRotate(this.hashAngle);
            vector = vector.crossMatrix(matrix);

            // hash的偏移向量
            var hashOffsetVector = vector.multiNumber(this.hashOffset);

            // 单位向量乘以hash长度
            vector = vector.multiNumber(this.hashHeight);

            var startPoint = mark.coordinates[0].plusVector(hashOffsetVector);
            var endPoint = startPoint.plusVector(vector);

            // 用计算出的起点和终点构造hash几何
            var hashGeo = new fastmap.mapApi.symbol.LineString();
            hashGeo.coordinates.push(startPoint);
            hashGeo.coordinates.push(endPoint);

            // 设置hashSymbol的geometry并调用draw方法
            this.hashLine.geometry = hashGeo;
            this.hashLine.draw(ctx);
        }
    }
});

/**
 * Created by xujie on 2016/5/13 0013.
 */

fastmap.mapApi.symbol.TextLineSymbol = fastmap.mapApi.symbol.LineSymbol.extend({
    initialize: function (options) {
        // 执行父类初始化
        fastmap.mapApi.symbol.LineSymbol.prototype.initialize.apply(this, arguments);

        this.type = 'TextLineSymbol';

        this.text = '';
        this.spaceCount = 0;
        this.offset = 0;
        this.gap = 200;
        this.alwaysisVerticalToLine = false;
        this.marker = null;

        this.fromJson(options);
    },

    fromJson: function (json) {
        fastmap.mapApi.symbol.LineSymbol.prototype.fromJson.apply(this, arguments);

        this.setValue('text', json.text);
        this.setValue('gap', json.gap);
        this.setValue('offset', json.offset);
        this.setValue('spaceCount', json.spaceCount);
        this.setValue('alwaysisVerticalToLine', json.alwaysisVerticalToLine);
        var symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();
        if (json.marker) {
            this.marker = symbolFactory.createSymbol(json.marker);
        }
    },

    toJson: function () {
        var json = fastmap.mapApi.symbol.LineSymbol.prototype.toJson.apply(this, arguments);

        json.text = this.text;
        json.gap = this.gap;
        json.offset = this.offset;
        json.spaceCount = this.spaceCount;
        json.alwaysisVerticalToLine = this.alwaysisVerticalToLine;
        if (this.marker) {
            json.marker = this.marker.toJson();
        }

        return json;
    },

    draw: function (ctx) {
        if (!this.geometry || !this.geometry.coordinates) {
            return;
        }

        if (this.geometry.coordinates.length < 2) {
            return;
        }

        if (!this.text) {
            return;
        }

        if (!this.marker) {
            return;
        }

        var text = this.text;
        if (this.spaceCount) {
            text = this.addSpaceToText(this.text);
        }

        // 粗略估算文本长度
        var size = this.getTextSize(text);
        var textLength = size.width > size.height ? size.width : size.height;

        // 计算link长度
        var length = this.geometry.length();

        if (length < textLength * 2) {
            return;
        }

        // 自动估算最合适的绘制次数
        var drawCount = this.getDrawCount(length, textLength, this.gap);

        // 去除所有文本长度后gap应该占用的长度
        var remainderLength = length - textLength * drawCount;

        // 每段由gap+文本组成
        var segLength = remainderLength / (drawCount + 1) + textLength;

        // 按照gap循环绘制文本
        var i = 1;
        while (i <= drawCount) {
            // 计算文本绘制的开始坐标
            var position = segLength * i - textLength;

            // 根据文本中间点坐标所在形状边的斜率决定是否反转文字内容
            var info = this.getTextDirection(this.geometry, position + textLength / 2);
            var drawText = text;
            if (info.isReverse) {
                drawText = text.split('').reverse().join('');
            }

            this.drawTextAtPosition(ctx, this.geometry, position, drawText, info.isVerticalToLine);
            ++i;
        }
    },

    addSpaceToText: function (text) {
        var spaces = this.getSpaces(this.spaceCount);
        var textWithSpace = '';
        for (var i = 0; i < text.length; ++i) {
            textWithSpace = textWithSpace + text[i] + spaces;
        }
        textWithSpace = textWithSpace.substr(0, textWithSpace.length - spaces.length);
        return textWithSpace;
    },

    getSpaces: function (count) {
        var spaces = '';
        for (var i = 0; i < count; ++i) {
            spaces += ' ';
        }
        return spaces;
    },

    /**
     * 根据link总长度，字符总长度，间距智能决定绘制次数
     * 如果link总长度小于文本总长度，返回0
     * @param length link总长度
     * @param textLength 文本总长度
     * @param gap 间距
     * @returns {number} 绘制次数
     */
    getDrawCount: function (length, textLength, gap) {
        // 不重叠情况下最多可以绘制文本的次数
        var count = Math.floor(length / textLength);
        var bestCount = 0;
        var dMin = Number.MAX_VALUE;
        while (count > 0) {
            var remainderLength = length - textLength * count;
            var segLength = remainderLength / (count + 1);
            var d = Math.abs(segLength - gap);
            if (d < dMin) {
                bestCount = count;
                dMin = d;
            }

            --count;
        }

        return bestCount;
    },

    drawTextAtPosition: function (ctx, geometry, position, text, isVerticalToLine) {
        var curPos = position;
        var lastLength = 0;
        var vY = new fastmap.mapApi.symbol.Vector(0, 1);
        for (var i = 0; i < text.length; ++i) {
            var size = this.getTextSize(text[i]);
            if (isVerticalToLine) {
                curPos += size.width / 2 + lastLength / 2;
                lastLength = size.width;
            } else {
                curPos += size.height / 2 + lastLength / 2;
                lastLength = size.height;
            }

            var res = geometry.getPointByLength(curPos);
            var sPoint = null;
            var ePoint = null;
            var curPoint = null;
            if (res[0] === 'vertex') {
                sPoint = geometry.coordinates[res[1]];
                ePoint = res[3];
                curPoint = ePoint;
            } else if (res[0] === 'betweenVertex') {
                sPoint = geometry.coordinates[res[1]];
                ePoint = geometry.coordinates[res[2]];
                curPoint = res[3];
            } else {
                continue;
            }

            var vN = ePoint.minus(sPoint);

            var angle = vY.angleTo(vN);
            var finalAngle = 0;

            if (vN.x === 0 && vN.y === 0) {
                // 处理零向量
                finalAngle = 0;
                if (isVerticalToLine) {
                    finalAngle += 90;
                }
            } else if (vN.x > 0 && vN.y === 0) {
                // x正轴上逆时针旋转
                finalAngle = -angle;
                if (isVerticalToLine) {
                    finalAngle += 90;
                }
            } else if (vN.x < 0 && vN.y === 0) {
                // x负轴上逆时针旋转
                finalAngle = angle;
                if (isVerticalToLine) {
                    finalAngle -= 90;
                }
            } else if (vN.x === 0 && vN.y > 0) {
                // y正轴上顺时针旋转
                finalAngle = angle;
                if (isVerticalToLine) {
                    finalAngle += 90;
                }
            } else if (vN.x === 0 && vN.y < 0) {
                // y负轴上顺时针旋转angle + 180
                finalAngle = angle + 180;
                if (isVerticalToLine) {
                    finalAngle += 90;
                }
            } else if (vN.x > 0 && vN.y > 0) {
                // 第一象限,逆时针旋转
                finalAngle = -angle;
                if (isVerticalToLine) {
                    finalAngle += 90;
                }
            } else if (vN.x < 0 && vN.y > 0) {
                // 第二象限,顺时针旋转
                finalAngle = angle;
                if (isVerticalToLine) {
                    finalAngle -= 90;
                }
            } else if (vN.x < 0 && vN.y < 0) {
                // 第三象限，顺时针旋转angle + 180
                finalAngle = angle + 180;
                if (isVerticalToLine) {
                    finalAngle += 90;
                }
            } else {
                // 第四象限，逆时针旋转angle + 180
                finalAngle = -angle + 180;
                if (isVerticalToLine) {
                    finalAngle -= 90;
                }
            }

            var matrix = new fastmap.mapApi.symbol.Matrix();
            var vV = vN.crossMatrix(matrix.makeRotate(90));
            vV.normalize();
            vV = vV.multiNumber(this.offset);
            curPoint = curPoint.plusVector(vV);

            this.drawChar(ctx, text[i], finalAngle, curPoint);
        }
    },

    /**
     * 决定文字的绘制方向和是否垂直于Link
     * @param geometry
     * @param position
     * @returns {{isReverse: boolean, isVerticalToLine: boolean}}
     */
    getTextDirection: function (geometry, position) {
        var res = geometry.getPointByLength(position);
        var sPoint = null;
        var ePoint = null;
        var curPoint = null;
        if (res[0] === 'vertex') {
            sPoint = this.geometry.coordinates[res[1]];
            ePoint = res[3];
            curPoint = ePoint;
        } else if (res[0] === 'betweenVertex') {
            sPoint = this.geometry.coordinates[res[1]];
            ePoint = this.geometry.coordinates[res[2]];
            curPoint = res[3];
        } else {
            throw new Error('计算错误，坐标不在Link内');
        }

        var vN = ePoint.minus(sPoint);

        var isReverse = false;
        var isVerticalToLine = false;

        var vY = new fastmap.mapApi.symbol.Vector(0, 1);
        var angle = vY.angleTo(vN);

        if (vN.x === 0 && vN.y === 0) {
            // 零向量不需要翻转文字,文字不垂直于线
            isReverse = false;
            isVerticalToLine = false;
        } else if (vN.x === 0 && vN.y > 0) {
            // y正轴上不需要翻转文字,文字不垂直于线
            isReverse = false;
            isVerticalToLine = false;
        } else if (vN.x > 0 && vN.y === 0) {
            // x正轴上不需要翻转文字,文字垂直于线
            isReverse = false;
            isVerticalToLine = true;
        } else if (vN.x === 0 && vN.y < 0) {
            // y负轴上需要翻转文字,文字不垂直于线
            isReverse = true;
            isVerticalToLine = false;
        } else if (vN.x < 0 && vN.y === 0) {
            // x负轴上需要翻转文字,文字垂直于线
            isReverse = true;
            isVerticalToLine = true;
        } else if (vN.x > 0 && vN.y > 0) {
            // 第一象限不需要翻转文字
            if (angle < 45) {
                isVerticalToLine = false;
            } else {
                isVerticalToLine = true;
            }
            isReverse = false;
        } else if (vN.x < 0 && vN.y > 0) {
            // 第二象限
            if (angle < 45) {
                // 不需要翻转文字
                isReverse = false;
                isVerticalToLine = false;
            } else {
                // 翻转文字
                isReverse = true;
                isVerticalToLine = true;
            }
        } else if (vN.x < 0 && vN.y < 0) {
            // 第三象限需要翻转文字
            // 第一象限不需要翻转文字
            if (angle > 135) {
                isVerticalToLine = false;
            } else {
                isVerticalToLine = true;
            }

            isReverse = true;
        } else {
            // 第四象限
            // 不需要翻转文字
            isReverse = false;
            isVerticalToLine = true;

            if (angle > 135) {
                // 翻转文字
                isReverse = true;
                isVerticalToLine = false;
            }
        }

        // 忽略线走向,文字总是垂直于线
        if (this.alwaysisVerticalToLine) {
            isVerticalToLine = true;
        }

        return {
            isReverse: isReverse,
            isVerticalToLine: isVerticalToLine
        };
    },

    drawChar: function (ctx, char, angle, geometry) {
        this.marker.align = 'center';
        this.marker.baseline = 'middle';
        this.marker.direction = 'ltr';
        this.marker.text = char;
        this.marker.angle = angle;
        this.marker.geometry = geometry;
        this.marker.draw(ctx);
    },

    getTextSize: function (text) {
        this.marker.text = text;
        var size = this.marker.getOriginBound().getSize();
        return size;
    }
});

/**
 * Created by xujie on 2016/5/13 0013.
 */

fastmap.mapApi.symbol.CenterTextLineSymbol = fastmap.mapApi.symbol.LineSymbol.extend({
    initialize: function (options) {
        // 执行父类初始化
        fastmap.mapApi.symbol.LineSymbol.prototype.initialize.apply(this, arguments);

        this.type = 'CenterTextLineSymbol';

        this.text = '';
        this.spaceCount = 0;
        this.offset = 0;
        this.times = 2;
        this.alwaysisVerticalToLine = false;
        this.marker = null;

        this.fromJson(options);
    },

    fromJson: function (json) {
        fastmap.mapApi.symbol.LineSymbol.prototype.fromJson.apply(this, arguments);

        this.setValue('text', json.text);
        this.setValue('spaceCount', json.spaceCount);
        this.setValue('offset', json.offset);
        this.setValue('times', json.times);
        this.setValue('alwaysisVerticalToLine', json.alwaysisVerticalToLine);
        var symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();
        if (json.marker) {
            this.marker = symbolFactory.createSymbol(json.marker);
        }
    },

    toJson: function () {
        var json = fastmap.mapApi.symbol.LineSymbol.prototype.toJson.apply(this, arguments);

        json.text = this.text;
        json.spaceCount = this.spaceCount;
        json.offset = this.offset;
        json.times = this.times;
        json.alwaysisVerticalToLine = this.alwaysisVerticalToLine;
        if (this.marker) {
            json.marker = this.marker.toJson();
        }

        return json;
    },

    draw: function (ctx) {
        if (!this.geometry || !this.geometry.coordinates) {
            return;
        }

        if (this.geometry.coordinates.length < 2) {
            return;
        }

        if (!this.text) {
            return;
        }

        if (!this.marker) {
            return;
        }

        var text = this.text;
        if (this.spaceCount) {
            text = this.addSpaceToText(this.text);
        }

        // 粗略估算文本长度
        var size = this.getTextSize(text);
        var textLength = size.width > size.height ? size.width : size.height;

        // 计算link长度
        var length = this.geometry.length();

        if (length < textLength * this.times) {
            return;
        }

        // 去除所有文本长度后gap应该占用的长度
        var remainderLength = length - textLength;

        // 计算文本绘制的开始坐标
        var position = remainderLength / 2;

        // 根据文本中间点坐标所在形状边的斜率决定是否反转文字内容
        var info = this.getTextDirection(this.geometry, position + textLength / 2);
        if (info.isReverse) {
            text = text.split('').reverse().join('');
        }

        this.drawTextAtPosition(ctx, this.geometry, position, text, info.isVerticalToLine);
    },

    addSpaceToText: function (text) {
        var spaces = this.getSpaces(this.spaceCount);
        var textWithSpace = '';
        for (var i = 0; i < text.length; ++i) {
            textWithSpace = textWithSpace + text[i] + spaces;
        }
        textWithSpace = textWithSpace.substr(0, textWithSpace.length - spaces.length);
        return textWithSpace;
    },

    getSpaces: function (count) {
        var spaces = '';
        for (var i = 0; i < count; ++i) {
            spaces += ' ';
        }
        return spaces;
    },

    drawTextAtPosition: function (ctx, geometry, position, text, isVerticalToLine) {
        var curPos = position;
        var vY = new fastmap.mapApi.symbol.Vector(0, 1);
        for (var i = 0; i < text.length; ++i) {
            var size = this.getTextSize(text[i]);
            var res = geometry.getPointByLength(curPos);
            var sPoint = null;
            var ePoint = null;
            var curPoint = null;
            if (res[0] === 'vertex') {
                sPoint = geometry.coordinates[res[1]];
                ePoint = res[3];
                curPoint = ePoint;
            } else if (res[0] === 'betweenVertex') {
                sPoint = geometry.coordinates[res[1]];
                ePoint = geometry.coordinates[res[2]];
                curPoint = res[3];
            } else {
                continue;
            }

            var vN = ePoint.minus(sPoint);

            var angle = vY.angleTo(vN);
            var finalAngle = 0;

            if (vN.x === 0 && vN.y === 0) {
                // 处理零向量
                finalAngle = 0;
                if (isVerticalToLine) {
                    finalAngle += 90;
                }
            } else if (vN.x > 0 && vN.y === 0) {
                // x正轴上逆时针旋转
                finalAngle = -angle;
                if (isVerticalToLine) {
                    finalAngle += 90;
                }
            } else if (vN.x < 0 && vN.y === 0) {
                // x负轴上逆时针旋转
                finalAngle = angle;
                if (isVerticalToLine) {
                    finalAngle -= 90;
                }
            } else if (vN.x === 0 && vN.y > 0) {
                // y正轴上顺时针旋转
                finalAngle = angle;
                if (isVerticalToLine) {
                    finalAngle += 90;
                }
            } else if (vN.x === 0 && vN.y < 0) {
                // y负轴上顺时针旋转angle + 180
                finalAngle = angle + 180;
                if (isVerticalToLine) {
                    finalAngle += 90;
                }
            } else if (vN.x > 0 && vN.y > 0) {
                // 第一象限,逆时针旋转
                finalAngle = -angle;
                if (isVerticalToLine) {
                    finalAngle += 90;
                }
            } else if (vN.x < 0 && vN.y > 0) {
                // 第二象限,顺时针旋转
                finalAngle = angle;
                if (isVerticalToLine) {
                    finalAngle -= 90;
                }
            } else if (vN.x < 0 && vN.y < 0) {
                // 第三象限，顺时针旋转angle + 180
                finalAngle = angle + 180;
                if (isVerticalToLine) {
                    finalAngle += 90;
                }
            } else {
                // 第四象限，逆时针旋转angle + 180
                finalAngle = -angle + 180;
                if (isVerticalToLine) {
                    finalAngle -= 90;
                }
            }

            if (isVerticalToLine) {
                curPos += size.width;
            } else {
                curPos += size.height;
            }

            var matrix = new fastmap.mapApi.symbol.Matrix();
            var vV = vN.crossMatrix(matrix.makeRotate(90));
            vV.normalize();
            vV = vV.multiNumber(this.offset);
            curPoint = curPoint.plusVector(vV);

            this.drawChar(ctx, text[i], finalAngle, curPoint);
        }
    },

    /**
     * 决定文字的绘制方向和是否垂直于Link
     * @param geometry
     * @param position
     * @returns {{isReverse: boolean, isVerticalToLine: boolean}}
     */
    getTextDirection: function (geometry, position) {
        var res = geometry.getPointByLength(position);
        var sPoint = null;
        var ePoint = null;
        var curPoint = null;
        if (res[0] === 'vertex') {
            sPoint = this.geometry.coordinates[res[1]];
            ePoint = res[3];
            curPoint = ePoint;
        } else if (res[0] === 'betweenVertex') {
            sPoint = this.geometry.coordinates[res[1]];
            ePoint = this.geometry.coordinates[res[2]];
            curPoint = res[3];
        } else {
            throw new Error('计算错误，错标不在Link内');
        }

        var vN = ePoint.minus(sPoint);

        var isReverse = false;
        var isVerticalToLine = false;

        var vY = new fastmap.mapApi.symbol.Vector(0, 1);
        var angle = vY.angleTo(vN);

        if (vN.x === 0 && vN.y === 0) {
            // 零向量不需要翻转文字,文字不垂直于线
            isReverse = false;
            isVerticalToLine = false;
        } else if (vN.x === 0 && vN.y > 0) {
            // y正轴上不需要翻转文字,文字不垂直于线
            isReverse = false;
            isVerticalToLine = false;
        } else if (vN.x > 0 && vN.y === 0) {
            // x正轴上不需要翻转文字,文字垂直于线
            isReverse = false;
            isVerticalToLine = true;
        } else if (vN.x === 0 && vN.y < 0) {
            // y负轴上需要翻转文字,文字不垂直于线
            isReverse = true;
            isVerticalToLine = false;
        } else if (vN.x < 0 && vN.y === 0) {
            // x负轴上需要翻转文字,文字垂直于线
            isReverse = true;
            isVerticalToLine = true;
        } else if (vN.x > 0 && vN.y > 0) {
            // 第一象限不需要翻转文字
            if (angle < 45) {
                isVerticalToLine = false;
            } else {
                isVerticalToLine = true;
            }
            isReverse = false;
        } else if (vN.x < 0 && vN.y > 0) {
            // 第二象限
            if (angle < 45) {
                // 不需要翻转文字
                isReverse = false;
                isVerticalToLine = false;
            } else {
                // 翻转文字
                isReverse = true;
                isVerticalToLine = true;
            }
        } else if (vN.x < 0 && vN.y < 0) {
            // 第三象限需要翻转文字
            if (angle > 135) {
                isVerticalToLine = false;
            } else {
                isVerticalToLine = true;
            }
            isReverse = true;
        } else {
            // 第四象限
            // 不需要翻转文字
            isReverse = false;
            isVerticalToLine = true;

            if (angle > 135) {
                // 翻转文字
                isReverse = true;
                isVerticalToLine = false;
            }
        }

        // 忽略线走向,文字总是垂直于线
        if (this.alwaysisVerticalToLine) {
            isVerticalToLine = true;
        }

        return {
            isReverse: isReverse,
            isVerticalToLine: isVerticalToLine
        };
    },

    drawChar: function (ctx, char, angle, geometry) {
        this.marker.align = 'center';
        this.marker.baseline = 'middle';
        this.marker.direction = 'ltr';
        this.marker.text = char;
        this.marker.angle = angle;
        this.marker.geometry = geometry;
        this.marker.draw(ctx);
    },

    getTextSize: function (text) {
        this.marker.text = text;
        var size = this.marker.getOriginBound().getSize();
        return size;
    }
});

/**
 * Created by xujie on 2016/5/13 0013.
 */

fastmap.mapApi.symbol.EndMarkerLineSymbol = fastmap.mapApi.symbol.LineSymbol.extend({
    initialize: function (options) {
        // 执行父类初始化
        fastmap.mapApi.symbol.LineSymbol.prototype.initialize.apply(this, arguments);

        this.type = 'EndMarkerLineSymbol';

        this.marker = null;
        this.position = 'e';
        this.times = 10;

        this.fromJson(options);
    },

    fromJson: function (json) {
        fastmap.mapApi.symbol.LineSymbol.prototype.fromJson.apply(this, arguments);

        this.setValue('position', json.position);
        this.setValue('times', json.times);
        var symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();
        if (json.marker) {
            this.marker = symbolFactory.createSymbol(json.marker);
        }
    },

    toJson: function () {
        var json = fastmap.mapApi.symbol.LineSymbol.prototype.toJson.apply(this, arguments);

        json.position = this.position;
        json.times = this.times;
        if (this.marker) {
            json.marker = this.marker.toJson();
        }

        return json;
    },

    draw: function (ctx) {
        if (!this.geometry || !this.geometry.coordinates) {
            return;
        }

        if (this.geometry.coordinates.length < 2) {
            return;
        }

        if (!this.marker) {
            return;
        }

        var length = this.geometry.length();
        var size = this.marker.getOriginBound().getSize();
        var maxSize = size.height > size.width ? size.height : size.width;

        if (length < maxSize * this.times) {
            return;
        }

        // 为了让marker不超出线，marker向线内移动半个高度
        var offset = size.height / 2;
        var geometry = this.geometry;
        if (this.position === 's') {
            geometry = geometry.reverse();
        }
        var res = geometry.getPointByLength(length - offset);
        var sP = null;
        var eP = null;
        if (res[0] === 'vertex') {
            sP = geometry.coordinates[res[1]];
            eP = res[3];
        } else if (res[0] === 'betweenVertex') {
            sP = geometry.coordinates[res[1]];
            eP = res[3];
        } else {
            throw new Error('计算错误，坐标不在Link内');
        }

        this.drawMarker(ctx, sP, eP);
    },

    drawMarker: function (ctx, sP, eP) {
        var vY = new fastmap.mapApi.symbol.Vector(0, -1);
        var vN = eP.minus(sP);
        var angle = vY.angleTo(vN);
        var signal = vY.cross(vN);

        if (signal < 0) {
            angle = -angle;
        }

        this.marker.angle = angle;
        this.marker.geometry = eP;
        this.marker.draw(ctx);
    }
});

/**
 * Created by xujie on 2016/5/13 0013.
 */

fastmap.mapApi.symbol.CenterMarkerLineSymbol = fastmap.mapApi.symbol.LineSymbol.extend({
    initialize: function (options) {
        // 执行父类初始化
        fastmap.mapApi.symbol.LineSymbol.prototype.initialize.apply(this, arguments);

        this.type = 'CenterMarkerLineSymbol';

        this.marker = null;
        this.direction = 's2e';
        this.times = 10;

        this.fromJson(options);
    },

    fromJson: function (json) {
        fastmap.mapApi.symbol.LineSymbol.prototype.fromJson.apply(this, arguments);

        this.setValue('direction', json.direction);
        this.setValue('times', json.times);
        var symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();
        if (json.marker) {
            this.marker = symbolFactory.createSymbol(json.marker);
        }
    },

    toJson: function () {
        var json = fastmap.mapApi.symbol.LineSymbol.prototype.toJson.apply(this, arguments);

        json.direction = this.direction;
        json.times = this.times;
        if (this.marker) {
            json.marker = this.marker.toJson();
        }

        return json;
    },

    draw: function (ctx) {
        if (!this.geometry || !this.geometry.coordinates) {
            return;
        }

        if (this.geometry.coordinates.length < 2) {
            return;
        }

        if (!this.marker) {
            return;
        }

        var length = this.geometry.length();
        var size = this.marker.getOriginBound().getSize();
        var maxSize = size.height > size.width ? size.height : size.width;

        if (length < maxSize * this.times) {
            return;
        }

        var res = this.geometry.getPointByLength(length / 2);
        var sP = null;
        var eP = null;
        if (res[0] === 'vertex') {
            sP = this.geometry.coordinates[res[1]];
            eP = res[3];
        } else if (res[0] === 'betweenVertex') {
            sP = this.geometry.coordinates[res[1]];
            eP = res[3];
        } else {
            throw new Error('计算错误，坐标不在Link内');
        }

        this.drawMarker(ctx, sP, eP);
    },

    drawMarker: function (ctx, sP, eP) {
        var vN = null;
        if (this.direction === 's2e') {
            vN = eP.minus(sP);
        } else if (this.direction === 'e2s') {
            vN = sP.minus(eP);
        } else {
            throw new Error('direction属性只能是s2e或e2s');
        }
        var vY = new fastmap.mapApi.symbol.Vector(0, -1);
        var angle = vY.angleTo(vN);
        var signal = vY.cross(vN);

        if (signal < 0) {
            angle = -angle;
        }

        this.marker.angle = angle;
        this.marker.geometry = eP;
        this.marker.draw(ctx);
    }
});

/**
 * Created by xujie on 2016/5/13 0013.
 */

fastmap.mapApi.symbol.CompositeLineSymbol = fastmap.mapApi.symbol.LineSymbol.extend({
    initialize: function (options) {
        // 执行父类初始化
        fastmap.mapApi.symbol.LineSymbol.prototype.initialize.apply(this, arguments);

        this.type = 'CompositeLineSymbol';

        this.symbols = [];

        this.fromJson(options);
    },

    fromJson: function (json) {
        fastmap.mapApi.symbol.LineSymbol.prototype.fromJson.apply(this, arguments);

        if (!json.symbols) {
            return;
        }

        var symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();
        for (var i = 0; i < json.symbols.length; ++i) {
            this.symbols.push(symbolFactory.createSymbol(json.symbols[i]));
        }
    },

    toJson: function () {
        var json = fastmap.mapApi.symbol.LineSymbol.prototype.toJson.apply(this, arguments);

        json.symbols = [];
        for (var i = 0; i < this.symbols.length; ++i) {
            json.symbols.push(this.symbols[i].toJson());
        }

        return json;
    },

    draw: function (ctx) {
        if (!this.geometry || !this.geometry.coordinates) {
            return;
        }

        if (this.geometry.coordinates.length < 2) {
            return;
        }

        if (this.symbols.length === 0) {
            return;
        }

        for (var i = 0; i < this.symbols.length; ++i) {
            this.symbols[i].geometry = this.geometry;
            this.symbols[i].draw(ctx);
        }
    }
});

/**
 * Created by xujie on 2016/5/13 0013.
 */

fastmap.mapApi.symbol.FillSymbol = fastmap.mapApi.symbol.Symbol.extend({
    initialize: function (options) {
        // 执行父类初始化
        fastmap.mapApi.symbol.Symbol.prototype.initialize.apply(this, arguments);

        this.opacity = 1;
        this.outLine = null;
    },

    fromJson: function (json) {
        fastmap.mapApi.symbol.Symbol.prototype.fromJson.apply(this, arguments);

        this.setValue('opacity', json.opacity);
        var symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();
        if (json.outLine) {
            this.outLine = symbolFactory.createSymbol(json.outLine);
        }
    },

    toJson: function () {
        var json = fastmap.mapApi.symbol.Symbol.prototype.toJson.apply(this, arguments);

        json.opacity = this.opacity;
        if (this.outLine) {
            json.outLine = this.outLine.toJson();
        }
        return json;
    },

    draw: function (ctx) {
        if (!this.geometry || !this.geometry.coordinates) {
            return;
        }

        // 至少需要有一条闭合线
        if (this.geometry.coordinates.length === 0) {
            return;
        }

        // 面至少需要四个点
        if (this.geometry.coordinates[0].length < 4) {
            return;
        }

        // 保存当前状态，方便绘制完成后恢复状态
        ctx.save();

        this.drawSymbol(ctx);

        // 绘制完成后恢复到上次保存的状态，避免影响以后的绘制
        ctx.restore();
    },

    drawSymbol: function (ctx) {
        // 绘制符号内容
        this.drawContent(ctx);

        // 绘制符号轮廓线
        if (this.outLine) {
            this.drawOutLine(ctx);
        }
    },

    drawContent: function (ctx) {
        return;
    },

    drawOutLine: function (ctx) {
        this.outLine.geometry = this.geometry.coordinates[0];
        this.outLine.draw(ctx);
    },

    getBound: function () {
        var gf = fastmap.mapApi.symbol.GeometryFactory.getInstance();

        var bound = this.geometry.getBound();

        return bound;
    }
});

/**
 * Created by xujie on 2016/5/13 0013.
 */

fastmap.mapApi.symbol.SimpleFillSymbol = fastmap.mapApi.symbol.FillSymbol.extend({
    initialize: function (options) {
        // 执行父类初始化
        fastmap.mapApi.symbol.FillSymbol.prototype.initialize.apply(this, arguments);

        this.type = 'SimpleFillSymbol';

        this.color = 'black';

        this.fromJson(options);
    },

    fromJson: function (json) {
        fastmap.mapApi.symbol.FillSymbol.prototype.fromJson.apply(this, arguments);
        this.setValue('color', json.color);
    },

    toJson: function () {
        var json = fastmap.mapApi.symbol.FillSymbol.prototype.toJson.apply(this, arguments);
        json.color = this.color;
        return json;
    },

    drawContent: function (ctx) {
        // 设置绘制环境
        ctx.fillStyle = this.color;
        ctx.globalAlpha = this.opacity;

        // 绘制
        ctx.beginPath();
        this.drawLineString(ctx, this.geometry.coordinates[0]);
        ctx.fill();
    }
});

/**
 * Created by xujie on 2016/5/13 0013.
 */

fastmap.mapApi.symbol.PatternFillSymbol = fastmap.mapApi.symbol.FillSymbol.extend({
    initialize: function (options) {
        // 执行父类初始化
        fastmap.mapApi.symbol.FillSymbol.prototype.initialize.apply(this, arguments);

        this.type = 'PatternFillSymbol';

        this.patternWidth = 10;
        this.patternHeight = 10;
        this.patternPath = '';
        this.patternColor = 'black';
        this.patternLineDash = [];
        this.patternLineWidth = 1;

        this.fromJson(options);
    },

    fromJson: function (json) {
        fastmap.mapApi.symbol.FillSymbol.prototype.fromJson.apply(this, arguments);
        this.setValue('patternWidth', json.patternWidth);
        this.setValue('patternHeight', json.patternHeight);
        this.setValue('patternPath', json.patternPath);
        this.setValue('patternColor', json.patternColor);
        this.setValue('patternLineDash', json.patternLineDash);
        this.setValue('patternLineWidth', json.patternLineWidth);
    },

    toJson: function () {
        var json = fastmap.mapApi.symbol.FillSymbol.prototype.toJson.apply(this, arguments);
        json.patternWidth = this.patternWidth;
        json.patternHeight = this.patternHeight;
        json.patternPath = this.patternPath;
        json.patternColor = this.patternColor;
        json.patternLineDash = this.patternLineDash;
        json.patternLineWidth = this.patternLineWidth;
        return json;
    },

    drawContent: function (ctx) {
        // 获取填充的pattern
        var pattern = this.getPattern(ctx);

        // 设置绘制环境
        ctx.fillStyle = pattern;
        ctx.globalAlpha = this.opacity;

        // 绘制
        ctx.beginPath();
        this.drawLineString(ctx, this.geometry.coordinates[0]);
        ctx.fill();
    },

    getPattern: function (ctx) {
        var canvas = document.createElement('canvas');
        canvas.width = this.patternWidth;
        canvas.height = this.patternHeight;
        var ctx1 = canvas.getContext('2d');
        ctx1.setLineDash(this.patternLineDash);
        ctx1.lineWidth = this.patternLineWidth;
        ctx1.strokeStyle = this.patternColor;

        // 使用白色作为背景色
        ctx1.fillStyle = 'white';
        ctx1.fillRect(0, 0, this.patternWidth, this.patternHeight);

        var path = new Path2D(this.patternPath);
        ctx1.stroke(path);

        var pattern = ctx.createPattern(canvas, 'repeat');

        return pattern;
    }
});

/**
 * Created by xujie on 2016/5/13 0013.
 */

fastmap.mapApi.symbol.LinearGradientFillSymbol = fastmap.mapApi.symbol.FillSymbol.extend({
    initialize: function (options) {
        // 执行父类初始化
        fastmap.mapApi.symbol.FillSymbol.prototype.initialize.apply(this, arguments);

        this.type = 'LinearGradientFillSymbol';

        this.direction = 't2b';
        this.startColor = 'gray';
        this.endColor = 'black';

        this.fromJson(options);
    },

    fromJson: function (json) {
        fastmap.mapApi.symbol.FillSymbol.prototype.fromJson.apply(this, arguments);
        this.setValue('direction', json.direction);
        this.setValue('startColor', json.startColor);
        this.setValue('endColor', json.endColor);
    },

    toJson: function () {
        var json = fastmap.mapApi.symbol.FillSymbol.prototype.toJson.apply(this, arguments);
        json.direction = this.direction;
        json.startColor = this.startColor;
        json.endColor = this.endColor;
        return json;
    },

    drawContent: function (ctx) {
        // 获取渐变对象
        var gradient = this.createGradient(ctx);

        // 设置绘制环境
        ctx.globalAlpha = this.opacity;
        ctx.fillStyle = gradient;

        // 绘制
        ctx.beginPath();
        this.drawLineString(ctx, this.geometry.coordinates[0]);
        ctx.fill();
    },

    createGradient: function (ctx) {
        var bound = this.getBound();
        var startX = 0;
        var startY = 0;
        var endX = 0;
        var endY = 0;
        switch (this.direction) {
            case 't2b':
                startX = 0;
                startY = bound.top;
                endX = 0;
                endY = bound.buttom;
                break;
            case 'b2t':
                startX = 0;
                startY = bound.buttom;
                endX = 0;
                endY = bound.top;
                break;
            case 'l2r':
                startX = 0;
                startY = bound.left;
                endX = 0;
                endY = bound.right;
                break;
            case 'r2l':
                startX = 0;
                startY = bound.right;
                endX = 0;
                endY = bound.left;
                break;
            case 'lt2rb':
                startX = bound.left;
                startY = bound.top;
                endX = bound.right;
                endY = bound.buttom;
                break;
            case 'rb2lt':
                startX = bound.right;
                startY = bound.buttom;
                endX = bound.left;
                endY = bound.top;
                break;
            case 'lb2rt':
                startX = bound.left;
                startY = bound.buttom;
                endX = bound.right;
                endY = bound.top;
                break;
            case 'rt2lb':
                startX = bound.right;
                startY = bound.top;
                endX = bound.left;
                endY = bound.buttom;
                break;
            default:
                throw new Error('线性填充方向设置错误');
        }

        var gradient = ctx.createLinearGradient(startX, startY, endX, endY);
        gradient.addColorStop(0, this.startColor);
        gradient.addColorStop(1, this.endColor);

        return gradient;
    }
});

/**
 * Created by xujie on 2016/5/13 0013.
 */

fastmap.mapApi.symbol.RadialGradientFillSymbol = fastmap.mapApi.symbol.FillSymbol.extend({
    initialize: function (options) {
        // 执行父类初始化
        fastmap.mapApi.symbol.FillSymbol.prototype.initialize.apply(this, arguments);

        this.type = 'RadialGradientFillSymbol';

        this.direction = 'c2o';
        this.startColor = 'gray';
        this.endColor = 'black';

        this.fromJson(options);
    },

    fromJson: function (json) {
        fastmap.mapApi.symbol.FillSymbol.prototype.fromJson.apply(this, arguments);
        this.setValue('direction', json.direction);
        this.setValue('startColor', json.startColor);
        this.setValue('endColor', json.endColor);
    },

    toJson: function () {
        var json = fastmap.mapApi.symbol.FillSymbol.prototype.toJson.apply(this, arguments);
        json.direction = this.direction;
        json.startColor = this.startColor;
        json.endColor = this.endColor;
        return json;
    },

    drawContent: function (ctx) {
        // 获取渐变对象
        var gradient = this.createGradient(ctx);

        // 设置绘制环境
        ctx.globalAlpha = this.opacity;
        ctx.fillStyle = gradient;

        // 绘制
        ctx.beginPath();
        this.drawLineString(ctx, this.geometry.coordinates[0]);
        ctx.fill();
    },

    createGradient: function (ctx) {
        var bound = this.getBound();
        var width = bound.right - bound.left;
        var length = bound.buttom - bound.top;
        var radius = length > width ? length : width;
        radius /= 2;
        var startRadius = 0;
        var endRadius = 0;
        switch (this.direction) {
            case 'c2o':
                startRadius = 0;
                endRadius = radius;
                break;
            case 'o2c':
                startRadius = radius;
                endRadius = 0;
                break;
            default:
                throw new Error('径向填充方向设置错误');
        }

        var centerX = bound.left + radius;
        var centerY = bound.top + radius;
        var gradient = ctx.createRadialGradient(centerX, centerY, startRadius, centerX, centerY, endRadius);
        gradient.addColorStop(0, this.startColor);
        gradient.addColorStop(1, this.endColor);

        return gradient;
    }
});

/**
 * Created by xujie on 2016/5/13 0013.
 */

fastmap.mapApi.symbol.CenterMarkerFillSymbol = fastmap.mapApi.symbol.FillSymbol.extend({
    initialize: function (options) {
        // 执行父类初始化
        fastmap.mapApi.symbol.FillSymbol.prototype.initialize.apply(this, arguments);

        this.type = 'CenterMarkerFillSymbol';

        this.marker = null;

        this.fromJson(options);
    },

    fromJson: function (json) {
        fastmap.mapApi.symbol.FillSymbol.prototype.fromJson.apply(this, arguments);
        var symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();
        if (json.marker) {
            this.marker = symbolFactory.createSymbol(json.marker);
        }
    },

    toJson: function () {
        var json = fastmap.mapApi.symbol.FillSymbol.prototype.toJson.apply(this, arguments);
        if (this.marker) {
            json.marker = this.marker.toJson();
        }

        return json;
    },

    drawContent: function (ctx) {
        var geometryAlgorithm = fastmap.mapApi.geometry.GeometryAlgorithm.getInstance();
        var geometryFactory = fastmap.mapApi.symbol.GeometryFactory.getInstance();
        var geojsonPolygon = geometryFactory.toGeojson(this.geometry);
        var geojsonPoint = geometryAlgorithm.centroid(geojsonPolygon);
        this.marker.geometry = geometryFactory.fromGeojson(geojsonPoint);
        this.marker.draw(ctx);
    }
});

/**
 * Created by xujie on 2016/5/13 0013.
 */

fastmap.mapApi.symbol.CompositeFillSymbol = fastmap.mapApi.symbol.FillSymbol.extend({
    initialize: function (options) {
        // 执行父类初始化
        fastmap.mapApi.symbol.FillSymbol.prototype.initialize.apply(this, arguments);

        this.type = 'CompositeFillSymbol';

        this.symbols = [];

        this.fromJson(options);
    },

    fromJson: function (json) {
        fastmap.mapApi.symbol.FillSymbol.prototype.fromJson.apply(this, arguments);

        if (!json.symbols) {
            return;
        }

        var symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();
        for (var i = 0; i < json.symbols.length; ++i) {
            this.symbols.push(symbolFactory.createSymbol(json.symbols[i]));
        }
    },

    toJson: function () {
        var json = fastmap.mapApi.symbol.FillSymbol.prototype.toJson.apply(this, arguments);

        json.symbols = [];
        for (var i = 0; i < this.symbols.length; ++i) {
            json.symbols.push(this.symbols[i].toJson());
        }

        return json;
    },

    draw: function (ctx) {
        if (!this.symbols.length) {
            return;
        }

        if (this.symbols.length === 0) {
            return;
        }

        fastmap.mapApi.symbol.FillSymbol.prototype.draw.apply(this, arguments);
    },

    drawContent: function (ctx) {
        for (var i = 0; i < this.symbols.length; ++i) {
            this.symbols[i].geometry = this.geometry;
            this.symbols[i].draw(ctx);
        }
    }
});

/**
 * Created by xujie on 2016/11/26.
 */
fastmap.mapApi.symbol.ResourceFactory = L.Class.extend({

    initialize: function () {
        this.resources = {};
    },

    add: function (key, resource) {
        if (!key || !resource) {
            return;
        }

        if (this.resources[key]) {
            return;
        }

        this.resources[key] = resource;
    },

    del: function (key) {
        if (!key) {
            return;
        }

        if (!this.resources.hasOwnProperty(key)) {
            return;
        }

        delete this.resources[key];
    },

    getResource: function (key) {
        return this.resources[key];
    },

    containResource: function (key) {
        return this.resources.hasOwnProperty(key);
    },

    clear: function () {
        this.resources = {};
    },

    destroy: function () {
        fastmap.mapApi.symbol.ResourceFactory.instance = null;
    },

    statics: {
        instance: null,

        getInstance: function () {
            if (!fastmap.mapApi.symbol.ResourceFactory.instance) {
                fastmap.mapApi.symbol.ResourceFactory.instance =
                    new fastmap.mapApi.symbol.ResourceFactory();
            }
            return fastmap.mapApi.symbol.ResourceFactory.instance;
        }
    }
});

/**
 * Created by xujie on 2016/5/11 0011.
 */
fastmap.mapApi.symbol.GetSymbolFactory = (function () {
    var instantiated;
    var symbolGallery = {};

    var SymbolFactory = L.Class.extend({
        /**
         * 解析配置文件，创建符号
         * @method loadSymbols
         * @param symbolData
         */
        loadSymbols: function (symbolData) {
            for (var i = 0; i < symbolData.length; ++i) {
                var data = symbolData[i];
                var symbol = this.createSymbol(data);
                this.addSymbol(data.name, symbol);
            }
        },

        /**
         * 创建符号对象
         * @method createSymbol
         * @param symbolType
         */
        createSymbol: function (json) {
            var symbolType = json.type;
            switch (symbolType) {
                case 'CircleMarkerSymbol':
                    return new fastmap.mapApi.symbol.CircleMarkerSymbol(json);
                case 'SquareMarkerSymbol':
                    return new fastmap.mapApi.symbol.SquareMarkerSymbol(json);
                case 'RectangleMarkerSymbol':
                    return new fastmap.mapApi.symbol.RectangleMarkerSymbol(json);
                case 'CrossMarkerSymbol':
                    return new fastmap.mapApi.symbol.CrossMarkerSymbol(json);
                case 'TiltedCrossMarkerSymbol':
                    return new fastmap.mapApi.symbol.TiltedCrossMarkerSymbol(json);
                case 'TriangleMarkerSymbol':
                    return new fastmap.mapApi.symbol.TriangleMarkerSymbol(json);
                case 'ImageMarkerSymbol':
                    return new fastmap.mapApi.symbol.ImageMarkerSymbol(json);
                case 'MultiImageMarkerSymbol':
                    return new fastmap.mapApi.symbol.MultiImageMarkerSymbol(json);
                case 'TextMarkerSymbol':
                    return new fastmap.mapApi.symbol.TextMarkerSymbol(json);
                case 'CompositeMarkerSymbol':
                    return new fastmap.mapApi.symbol.CompositeMarkerSymbol(json);
                case 'SimpleLineSymbol':
                    return new fastmap.mapApi.symbol.SimpleLineSymbol(json);
                case 'CartoLineSymbol':
                    return new fastmap.mapApi.symbol.CartoLineSymbol(json);
                case 'MarkerLineSymbol':
                    return new fastmap.mapApi.symbol.MarkerLineSymbol(json);
                case 'HashLineSymbol':
                    return new fastmap.mapApi.symbol.HashLineSymbol(json);
                case 'TextLineSymbol':
                    return new fastmap.mapApi.symbol.TextLineSymbol(json);
                case 'CenterTextLineSymbol':
                    return new fastmap.mapApi.symbol.CenterTextLineSymbol(json);
                case 'EndMarkerLineSymbol':
                    return new fastmap.mapApi.symbol.EndMarkerLineSymbol(json);
                case 'CenterMarkerLineSymbol':
                    return new fastmap.mapApi.symbol.CenterMarkerLineSymbol(json);
                case 'CompositeLineSymbol':
                    return new fastmap.mapApi.symbol.CompositeLineSymbol(json);
                case 'SimpleFillSymbol':
                    return new fastmap.mapApi.symbol.SimpleFillSymbol(json);
                case 'PatternFillSymbol':
                    return new fastmap.mapApi.symbol.PatternFillSymbol(json);
                case 'LinearGradientFillSymbol':
                    return new fastmap.mapApi.symbol.LinearGradientFillSymbol(json);
                case 'RadialGradientFillSymbol':
                    return new fastmap.mapApi.symbol.RadialGradientFillSymbol(json);
                case 'CenterMarkerFillSymbol':
                    return new fastmap.mapApi.symbol.CenterMarkerFillSymbol(json);
                case 'CompositeFillSymbol':
                    return new fastmap.mapApi.symbol.CompositeFillSymbol(json);
                default:
                    throw new Error('不支持的符号类型: ' + symbolType);
            }
        },

        /**
         * 根据名称查找预定义的符号
         * @method getSymbol
         * @param symbolName
         */
        getSymbol: function (symbolName) {
            return symbolGallery[symbolName];
        },

        /**
         * 检查符号库是否包含指定名字的符号
         * @method containSymbol
         * @param symbolName
         */
        containSymbol: function (symbolName) {
            return symbolGallery.hasOwnProperty(symbolName);
        },

        /**
         * 返回符号库中所有的符号名字
         * @method getSymbols
         */
        getSymbolNames: function () {
            var symbols = [];
            for (var p in symbolGallery) {
                if (symbolGallery.hasOwnProperty(p)) {
                    symbols.push(p);
                }
            }
            return symbols;
        },

        /**
         * 向符号库中添加指定名字的符号
         * 如果已经存在同名符号，添加失败，返回false
         * @method addSymbol
         * @param symbol
         * @param symbolName
         */
        addSymbol: function (symbolName, symbol) {
            if (symbolGallery.hasOwnProperty(symbolName)) {
                return false;
            }

            symbolGallery[symbolName] = symbol;
            return true;
        },

        /**
         * 根据名称删除符号，如果不存在指定名称的符号，什么也不做
         * @method removeSymbol
         * @param symbolName
         */
        removeSymbol: function (symbolName) {
            if (symbolGallery.hasOwnProperty(symbolName)) {
                delete symbolGallery[symbolName];
            }
        },

        /**
         * 从符号中获取符号所依赖的图片urls
         * @param symbol
         * @returns {Array}
         */
        getUrlsFromSymbol: function (symbol) {
            var urls = [];
            var type = symbol.type;
            switch (type) {
                case 'ImageMarkerSymbol':
                    urls.push(symbol.url);
                    break;
                case 'MultiImageMarkerSymbol':
                    symbol.urls.forEach(function (item) {
                        item.forEach(function (it) {
                            if (it) {
                                urls.push(it);
                            }
                        });
                    });
                    break;
                case 'MarkerLineSymbol':
                case 'CenterMarkerLineSymbol':
                case 'EndMarkerLineSymbol':
                    urls = this.getUrlsFromSymbol(symbol.marker);
                    break;
                case 'CompositeMarkerSymbol':
                case 'CompositeLineSymbol':
                    symbol.symbols.forEach(function (item) {
                        var itemUrls = this.getUrlsFromSymbol(item);
                        urls = urls.concat(itemUrls);
                    }, this);
                    break;
                default:
                    break;
            }

            return urls;
        },

        getGeometryTypeBySymbol: function (symbol) {
            if (symbol instanceof fastmap.mapApi.symbol.MarkerSymbol) {
                return 'Point';
            }
            if (symbol instanceof fastmap.mapApi.symbol.LineSymbol) {
                return 'LineString';
            }
            if (symbol instanceof fastmap.mapApi.symbol.FillSymbol) {
                return 'Polygon';
            }

            throw new Error('非法的符号类型!');
        },

        /**
         * 销毁单例对象
         */
        destroy: function () {
            instantiated = null;
            symbolGallery = {};
        }
    });

    return function () {
        if (!instantiated) {
            instantiated = new SymbolFactory();
        }
        return instantiated;
    };
}());

/**
 * Created by xujie on 2016/5/11 0011.
 */
fastmap.mapApi.symbol.GeometryFactory = L.Class.extend({

    initialize: function () {
    },

    createPoint: function (coordinates) {
        return new fastmap.mapApi.symbol.Point(coordinates[0], coordinates[1]);
    },

    createLineString: function (coordinates) {
        var lineString = new fastmap.mapApi.symbol.LineString();
        for (var i = 0; i < coordinates.length; ++i) {
            var point = this.createPoint(coordinates[i]);
            lineString.coordinates.push(point);
        }
        return lineString;
    },

    createPolygon: function (coordinates) {
        var polygon = new fastmap.mapApi.symbol.Polygon();
        for (var i = 0; i < coordinates.length; ++i) {
            var lineString = this.createLineString(coordinates[i]);
            polygon.coordinates.push(lineString);
        }
        return polygon;
    },

    toGeojson: function (geometry) {
        var type = geometry.type;
        var coordinates = [];
        switch (type) {
            case 'Point':
                coordinates = [geometry.x, geometry.y];
                break;
            case 'LineString':
                coordinates = geometry.coordinates.map(function (point) {
                    return [point.x, point.y];
                }, this);
                break;
            case 'Polygon':
                coordinates = geometry.coordinates.map(function (ls) {
                    return ls.coordinates.map(function (point) {
                        return [point.x, point.y];
                    }, this);
                }, this);
                break;
            default:
                throw new Error('不支持的类型:' + type);
        }

        var geojson = {
            type: type,
            coordinates: coordinates
        };

        return geojson;
    },

    fromGeojson: function (geojson) {
        var type = geojson.type;
        switch (type) {
            case 'Point':
                var point = new fastmap.mapApi.symbol.Point(geojson.coordinates[0], geojson.coordinates[1]);
                return point;
            case 'LineString':
                var lineString = this.createLineString(geojson.coordinates);
                return lineString;
            case 'Polygon':
                var polygon = this.createPolygon(geojson.coordinates);
                return polygon;
            default:
                throw new Error('不支持的类型:' + type);
        }
    },

    /**
     * 根据中心点，宽度，高度构造bound
     * x方向为宽度，y方向为高度
     * 如果center为null或undefined，则使用[0,0]作为中心点
     * @param center
     * @param width
     * @param height
     */
    createBound: function (center, width, height) {
        var cX = 0;
        var cY = 0;
        if (center) {
            cX = center.x;
            cY = center.y;
        }
        var halfWidth = width / 2;
        var halfHeight = height / 2;
        var left = cX - halfWidth;
        var top = cY - halfHeight;
        var right = cX + halfWidth;
        var buttom = cY + halfHeight;
        var bound = new fastmap.mapApi.symbol.Bound(
            left,
            top,
            right,
            buttom
        );
        return bound;
    },

    destroy: function () {
        fastmap.mapApi.symbol.GeometryFactory.instance = null;
    },

    statics: {
        instance: null,

        getInstance: function () {
            if (!fastmap.mapApi.symbol.GeometryFactory.instance) {
                fastmap.mapApi.symbol.GeometryFactory.instance =
                    new fastmap.mapApi.symbol.GeometryFactory();
            }
            return fastmap.mapApi.symbol.GeometryFactory.instance;
        }
    }
});

/**
 * Created by xujie on 2016/11/32
 * 转换geometry坐标辅助类
 */
fastmap.mapApi.symbol.GeometryTransform = L.Class.extend({

    initialize: function () {
        this.convertFunction = null;
        this.map = null;
        this.tile = null;
    },

    /**
     * 设置转换环境
     * @param map
     * @param tile
     * @param convertFuc
     */
    setEnviroment: function (map, tile, convertFuc) {
        this.map = map;
        this.tile = tile;
        this.convertFunction = convertFuc;
    },

    /**
    * 遍历geometry对象，使用给定的方法转换坐标
    * 不会改变原对象
    * @param geometry
    * @returns geometry对象
    */
    convertGeometry: function (geometry) {
        var newGeometry = geometry.clone();
        var type = newGeometry.type;
        switch (type) {
            case 'Point':
                return this.convertPoint(newGeometry);
            case 'LineString':
                return this.convertLineString(newGeometry);
            case 'Polygon':
                return this.convertPolygon(newGeometry);
            default:
                throw new Error('不支持的类型:' + type);
        }
    },

    convertPoint: function (geometry) {
        return this.convertFunction(this.map, this.tile, geometry);
    },

    convertLineString: function (geometry) {
        geometry.coordinates = geometry.coordinates.map(function (element, index, array) {
            return this.convertPoint(element);
        }, this);
        return geometry;
    },

    convertPolygon: function (geometry) {
        geometry.coordinates = geometry.coordinates.map(function (element, index, array) {
            return this.convertLineString(element);
        }, this);
        return geometry;
    },

    destroy: function () {
        fastmap.mapApi.symbol.GeometryTransform.instance = null;
    },

    statics: {
        instance: null,

        getInstance: function () {
            if (!fastmap.mapApi.symbol.GeometryTransform.instance) {
                fastmap.mapApi.symbol.GeometryTransform.instance =
                    new fastmap.mapApi.symbol.GeometryTransform();
            }
            return fastmap.mapApi.symbol.GeometryTransform.instance;
        }
    }
});

FM.mapApi.render = {
    data: {},
    renderer: {},
    highlight: {}
};

FM.mapApi.render.data.DataModel = L.Class.extend({
    symbolFactory: FM.mapApi.symbol.GetSymbolFactory(),
    geometryFactory: FM.mapApi.symbol.GeometryFactory.getInstance(),

    initialize: function (data) {
        this.type = 'RenderData';
        this.geometry = null;
        this.properties = null;

        if (data) {
            this.geometry = {};
            this.geometry.coordinates = data.g;

            this.properties = {};
            this.properties.id = parseInt(data.i, 10);
        }

        this.setAttribute.apply(this, arguments);
    },

    setAttribute: function () {
        throw new Error('未实现setAttribute方法');
    },

    statics: {
        create: function (data, tile) {
            throw new Error('未实现create方法');
        },

        transform: function (data, tile, caller) {
            var list = [];
            var key,
                i,
                n,
                temp,
                tmp;
            if (FM.Util.isObject(data)) {
                for (key in data) {
                    if (data.hasOwnProperty(key)) {
                        for (i = 0, n = data[key].length; i < n; i++) {
                            tmp = caller.create(data[key][i], tile);
                            if (FM.Util.isObject(tmp)) {
                                list.push(tmp);
                            } else if (FM.Util.isArray(tmp)) {
                                list = list.concat(tmp);
                            }
                        }
                    }
                }
            } else if (FM.Util.isArray(data)) {
                temp = data;
                if (FM.Util.isArray(data[0])) {
                    temp = data[0];
                }
                for (i = 0, n = temp.length; i < n; i++) {
                    tmp = caller.create(temp[i], tile);
                    if (FM.Util.isObject(tmp)) {
                        list.push(tmp);
                    } else if (FM.Util.isArray(tmp)) {
                        Array.prototype.push.apply(list, tmp);
                    }
                }
            }
            return list;
        }
    }
});

/*
    add by Chenx on 2017-5-9
    渲染器的基类
 */
FM.mapApi.render.Render = L.Class.extend({
    getSymbol: function (feature, zoom) {
        var renderer = this.getRenderer(feature, zoom);
        if (!renderer) {
            throw new Error('未实现符号化:' + feature.properties.geoLiveType);
        }
        return renderer.getSymbol();
    },

    getHighlightSymbol: function (feature, zoom) {
        var renderer = this.getRenderer(feature, zoom);
        if (!renderer) {
            throw new Error('未实现高亮符号化:' + feature.properties.geoLiveType);
        }
        return renderer.getHighlightSymbol();
    },

    /**
     * @param  {Object}
     * @param  {int}
     * @return {Object}
     * 在子类中重写此方法
     */
    getRenderer: function (feature, zoom) {
        return null;
    }
});

/*
    add by Chenx on 2017-5-9
    要素渲染类的基类
 */
FM.mapApi.render.Renderer = L.Class.extend({
    _symbolFactory: fastmap.mapApi.symbol.GetSymbolFactory(),
    _geometryFactory: fastmap.mapApi.symbol.GeometryFactory.getInstance(),

    initialize: function (feature, zoom) {
        this._feature = feature;
        this._zoom = zoom;
    },

    /**
     * @param  {Object}
     * @param  {int}
     * @return {Object}
     * 在子类中重写此方法
     */
    getSymbol: function (feature, zoom) {
        throw new Error('Renderer未实现getSymbol方法');
    },

    /**
     * @param  {Object}
     * @param  {int}
     * @return {Object}
     * 在子类中重写此方法
     */
    getHighlightSymbol: function (feature, zoom) {
        throw new Error('Renderer未实现getHighlightSymbol方法');
    }
});

/**
 * Created by xujie on 2016/11/26.
 */
FM.mapApi.render.GeoLiveHighlight = L.Class.extend({
    initialize: function (options) {
        this.geoLiveObject = options;
        this.items = [];
        this.highlightConfig = FM.mapApi.render.highlight;
        this.feedback = new fastmap.mapApi.Feedback();

        this.symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();
        this.featureSelector = fastmap.mapApi.FeatureSelector.getInstance();
        this.geometryAlgorithm = fastmap.mapApi.geometry.GeometryAlgorithm.getInstance();
    },

    highlight: function () {
        if (!this.geoLiveObject) {
            return;
        }

        var type = this.geoLiveObject.geoLiveType;
        var rule = this.getRuleByType(type);

        // 高亮要素
        this.highlightObject(this.geoLiveObject, rule);

        this.addToFeedback();
    },

    refresh: function () {
        this.items = [];
        this.feedback.clear();
        this.highlight();
    },

    addToFeedback: function () {
        this.items = this.items.sort(function (a, b) {
            return a.zIndex - b.zIndex;
        });

        this.items.forEach(function (item, index, array) {
            if (item.geometry) {
                this.feedback.add(item.geometry, item.symbol);
            } else {
                this.feedback.addPid(item.pid, item.featureType, item.symbol);
            }
        }, this);
    },

    getRuleByType: function (type) {
        return this.highlightConfig[type];
    },

    highlightObject: function (geoLiveObject, rule) {
        // 高亮要素主要部分
        this.highlightMain(geoLiveObject, rule);

        // 高亮其他topo要素
        if (rule.topo) {
            this.highlightTopo(geoLiveObject, rule.topo);
        }
    },

    highlightMain: function (value, main) {
        var type = main.type;
        if (!type) {
            return;
        }
        switch (type) {
            case 'geoLiveObject':
                this.highlightGeoLiveObject(value, main);
                break;
            case 'pid':
                this.highlightPid(value, main);
                break;
            case 'symbol':
                this.highlightSymbol(value, main);
                break;
            case 'geometry':
                this.highlightGeometry(value, main);
                break;
            case 'Text':
                this.highlightText(value, main);
                break;
            default:
                throw new Error('不支持的高亮对象类型：【' + type + '】');
        }
    },

    highlightGeoLiveObject: function (geoLiveObject, main) {
        if (!geoLiveObject) {
            return;
        }
        var layerId = main.layer;
        var key = main.key;
        var zIndex = main.zIndex;
        var symbolName = '';
        var pid = geoLiveObject[key];

        if (!layerId || !key || !pid) {
            return;
        }

        symbolName = this.getSymbolNameFromMain(geoLiveObject, main);

        var symbol = FM.Util.clone(this.symbolFactory.getSymbol(symbolName));
        if (!symbol) {
            return;
        }

        var feature = this.featureSelector.selectByFeatureId(pid, layerId);
        var item;
        if (feature) {
            var geometryType = this.symbolFactory.getGeometryTypeBySymbol(symbol);

            var geometry = feature.geometry;

            var geometries = this.geometryAlgorithm.getGeometriesByType(geometry, geometryType);

            for (var i = 0; i < geometries.length; ++i) {
                item = {
                    geometry: geometries[i]
                };
                this.addItem(item, symbol, zIndex);
            }
        } else {
            item = {
                pid: pid,
                featureType: layerId
            };
            this.addItem(item, symbol, zIndex);
        }
    },

    highlightPid: function (pid, main) {
        var layerId = main.layer;
        var key = main.key;
        var zIndex = main.zIndex;
        var symbolName = main.defaultSymbol;

        if (!layerId || !pid) {
            return;
        }

        var symbol = FM.Util.clone(this.symbolFactory.getSymbol(symbolName));
        if (!symbol) {
            return;
        }

        var feature = this.featureSelector.selectByFeatureId(pid, layerId);
        var item;
        if (feature) {
            item = {
                geometry: feature.geometry
            };
            this.addItem(item, symbol, zIndex);
        } else {
            item = {
                pid: pid,
                featureType: layerId
            };
            this.addItem(item, symbol, zIndex);
        }
    },

    highlightSymbol: function (geoLiveObject, main) {
        if (!geoLiveObject) {
            return;
        }
        var layerId = main.layer;
        var key = main.key;
        var zIndex = main.zIndex;
        var symbolName = '';
        var pid = geoLiveObject[key];

        if (!layerId || !key || !pid) {
            return;
        }

        symbolName = this.getSymbolNameFromMain(geoLiveObject, main);

        var symbol = FM.Util.clone(this.symbolFactory.getSymbol(symbolName));
        if (!symbol) {
            return;
        }

        var feature = this.featureSelector.selectByFeatureId(pid, layerId);
        var item;
        if (feature) {
            var geometry = feature.geometry;

            var geometries = this.geometryAlgorithm.getGeometriesByType(geometry, 'Point');

            for (var i = 0; i < geometries.length; ++i) {
                item = {
                    geometry: geometries[i]
                };
                this.addItem(item, symbol, zIndex);
            }
        } else {
            item = {
                pid: pid,
                featureType: layerId
            };
            this.addItem(item, symbol, zIndex);
        }
    },

    highlightGeometry: function (geometry, main) {
        var zIndex = main.zIndex;
        var symbolName = main.defaultSymbol;
        var symbol = FM.Util.clone(this.symbolFactory.getSymbol(symbolName));
        if (!symbol) {
            return;
        }
        var type = geometry.type;
        var item;
        switch (type) {
            case 'Point':
            case 'LineString':
            case 'Polygon':
                item = {
                    geometry: geometry
                };
                this.addItem(item, symbol, zIndex);
                break;
            case 'MultiPoint':
                this.highlightMultiGeometry('Point', geometry.coordinates, symbol, zIndex);
                break;
            case 'MultiLineString':
                this.highlightMultiGeometry('LineString', geometry.coordinates, symbol, zIndex);
                break;
            case 'MultiPolygon':
                this.highlightMultiGeometry('Polygon', geometry.coordinates, symbol, zIndex);
                break;
            default:
                throw new Error('无法处理几何类型:' + type);
        }
    },

    highlightText: function (geoLiveObject, main) {
        if (!geoLiveObject) {
            return;
        }
        var textPropertyName = main.text;
        var geometryPropertyName = main.geometry;
        var zIndex = main.zIndex;

        if (!textPropertyName || !geometryPropertyName || !zIndex) {
            return;
        }

        var text = geoLiveObject[textPropertyName];
        var geometry = geoLiveObject[geometryPropertyName];
        if (!text || !geometry) {
            return;
        }

        var symbolName = this.getSymbolNameFromMain(geoLiveObject, main);

        var symbol = FM.Util.clone(this.symbolFactory.getSymbol(symbolName));
        if (!symbol) {
            return;
        }

        this.setSymbolTextProperty(symbol, text);

        var geometryType = this.symbolFactory.getGeometryTypeBySymbol(symbol);

        var geometries = this.geometryAlgorithm.getGeometriesByType(geometry, geometryType);

        var item;
        for (var i = 0; i < geometries.length; ++i) {
            item = {
                geometry: geometries[i]
            };
            this.addItem(item, symbol, zIndex);
        }
    },

    setSymbolTextProperty: function (symbol, text) {
        var type = symbol.type;
        switch (type) {
            case 'TextMarkerSymbol':
            case 'TextLineSymbol':
            case 'CenterTextLineSymbol':
            case 'TextFillSymbol':
                symbol.text = text;
                break;
            case 'CompositeMarkerSymbol':
            case 'CompositeLineSymbol':
            case 'CompositeFillSymbol':
                for (var i = 0; i < symbol.symbols.length; i++) {
                    var subSymbol = symbol.symbols[i];
                    this.setSymbolTextProperty(subSymbol, text);
                }
                break;
            default:
                break;
        }
    },

    highlightMultiGeometry: function (type, coordinates, symbol, zIndex) {
        for (var i = 0; i < coordinates.length; ++i) {
            var item = {};
            item.geometry = {
                type: type,
                coordinates: coordinates[i]
            };
            this.addItem(item, symbol, zIndex);
        }
    },

    addItem: function (item, symbol, zIndex) {
        if (!item || !symbol) {
            return;
        }

        var temp;
        if (item.geometry) {
            temp = {
                geometry: item.geometry,
                symbol: symbol,
                zIndex: zIndex
            };
        } else if (item.pid && item.featureType) {
            temp = {
                pid: item.pid,
                featureType: item.featureType,
                symbol: symbol,
                zIndex: zIndex
            };
        }

        if (temp) {
            this.items.push(temp);
        }
    },

    getSymbolNameFromMain: function (geoLiveObject, main) {
        var symbolName = '';
        if (main.rule) {
            symbolName = this.getSymbolNameFromRule(geoLiveObject, main.rule);
        }

        if (!symbolName) {
            symbolName = main.defaultSymbol;
        }

        return symbolName;
    },

    highlightTopo: function (geoLiveObject, topo) {
        var self = this;
        for (var i = 0; i < topo.length; ++i) {
            var part = topo[i];
            var joinKey = part.joinKey;
            var rule = part.highlight;
            var topoObject = geoLiveObject[joinKey];
            if (FM.Util.isArray(topoObject)) {
                this.highlightObjects(topoObject, rule);
            } else {
                this.highlightObject(topoObject, rule);
            }
        }
    },

    highlightObjects: function (objectArray, rule) {
        objectArray.forEach(function (element, index, array) {
            this.highlightObject(element, rule);
        }, this);
    },

    getSymbolNameFromRule: function (geoLiveObject, rule) {
        var attribute = rule.attribute;
        var value = geoLiveObject[attribute];
        var symbolName = this.getSymbolNameFromForks(rule.forks, value);
        if (!symbolName) {
            symbolName = rule.defaultSymbol;
        }
        return symbolName;
    },

    getSymbolNameFromForks: function (forks, value) {
        for (var i = 0; i < forks.length; ++i) {
            var fork = forks[i];
            if (value === fork.value) {
                return fork.symbol;
            }
        }

        return null;
    }
});

/**
 * Created by xujie on 2016/11/26.
 */
FM.mapApi.render.HighlightController = L.Class.extend({
    initialize: function () {
        this.feedbackController = fastmap.mapApi.FeedbackController.getInstance();
        this.highlightItems = {};
    },

    highlight: function (geoLiveObject) {
        if (!geoLiveObject) {
            return;
        }
        var key = geoLiveObject.rowId;
        if (geoLiveObject instanceof fastmap.dataApi.Tip) {
            key = geoLiveObject.pid;
        }
        if (geoLiveObject instanceof fastmap.dataApi.Info) {
            key = geoLiveObject.globalId;
        }
        if (this.highlightItems[key]) {
            return;
        }

        var highlight = new FM.mapApi.render.GeoLiveHighlight(geoLiveObject);
        highlight.highlight();
        this.highlightItems[key] = highlight;
        this.feedbackController.add(highlight.feedback);
        this.feedbackController.refresh();
    },

    unHighlight: function (geoLiveObject) {
        if (!geoLiveObject) {
            return;
        }

        var key = geoLiveObject.rowId;
        if (geoLiveObject instanceof fastmap.dataApi.Tip) {
            key = geoLiveObject.pid;
        }

        var highlight = this.highlightItems[key];
        if (!highlight) {
            return;
        }

        this.feedbackController.del(highlight.feedback);
        this.feedbackController.refresh();
        delete this.highlightItems[key];
    },

    clear: function () {
        var keys = Object.getOwnPropertyNames(this.highlightItems);
        keys.forEach(function (element, index, array) {
            var highlight = this.highlightItems[element];
            this.feedbackController.del(highlight.feedback);
            delete this.highlightItems[element];
        }, this);

        this.feedbackController.refresh();
    },

    isCleared: function () {
        var keys = Object.getOwnPropertyNames(this.highlightItems);
        return keys.length === 0;
    },

    refresh: function () {
        var keys = Object.getOwnPropertyNames(this.highlightItems);
        keys.forEach(function (element, index, array) {
            var highlight = this.highlightItems[element];
            this.feedbackController.del(highlight.feedback);
            highlight.refresh();
            this.feedbackController.add(highlight.feedback);
        }, this);

        this.feedbackController.refresh();
    },

    destroy: function () {
        FM.mapApi.render.HighlightController.instance = null;
    },

    statics: {
        instance: null,

        getInstance: function () {
            if (!FM.mapApi.render.HighlightController.instance) {
                FM.mapApi.render.HighlightController.instance =
                    new FM.mapApi.render.HighlightController();
            }
            return FM.mapApi.render.HighlightController.instance;
        }
    }
});

/**
 * Created by Chenx on 2017/7/7.
 * 用于闪烁高亮
 */
FM.mapApi.render.FlashHighlightController = FM.Class.extend({
    options: {},

    initialize: function (option) {
        FM.setOptions(this, option);

        this.highlightCtrl = FM.mapApi.render.HighlightController.getInstance();
        this.symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();
        this.feedbackCtrl = fastmap.mapApi.FeedbackController.getInstance();
        this.feedback = new fastmap.mapApi.Feedback();
        this.feedback.priority = 1;
        this.feedbackCtrl.add(this.feedback);

        this.interval = null;
    },
    _clearFeedback: function () {
        if (this.interval) {
            clearInterval(this.interval);
            this.interval = null;
        }
        this.feedback.clear();
    },
    resetFeedback: function (data) {
        data = data || [];
        this._clearFeedback();

        if (data.length > 0) {
            var item,
                symbol;
            for (var i = 0; i < data.length; i++) {
                item = data[i];
                if (item.featureType && item.pid && item.symbolName) {
                    symbol = this.symbolFactory.getSymbol(item.symbolName);
                    this.feedback.addPid(item.pid, item.featureType, symbol);
                }
            }

            var that = this;
            var items = this.feedback.getDrawItems().slice();
            this.interval = setInterval(function () {
                // 要素组成部分选中高亮依赖于要素的高亮
                // 当要素高亮被清空时，应终止要素组成部分选中高亮
                // 一般在启动topo编辑工具（editControl）时会清理要素高亮
                if (that.highlightCtrl.isCleared()) {
                    that.clearFeedback();
                    return;
                }

                if (that.feedback.getDrawItems().length > 0) {
                    that.feedback.clear();
                } else {
                    that.feedback.setDrawItems(items);
                }
                that.feedbackCtrl.refresh();
            }, 300);
        }

        this.feedbackCtrl.refresh();
    },

    clearFeedback: function () {
        this._clearFeedback();
        this.feedbackCtrl.refresh();
    },

    destroy: function () {
        FM.mapApi.render.FlashHighlightController.instance = null;
    },

    statics: {
        instance: null,

        getInstance: function () {
            if (!FM.mapApi.render.FlashHighlightController.instance) {
                FM.mapApi.render.FlashHighlightController.instance =
                    new FM.mapApi.render.FlashHighlightController();
            }
            return FM.mapApi.render.FlashHighlightController.instance;
        }
    }
});

//# sourceMappingURL=mapApi.min.js.map
